
;;; XGP Command Interpreter for the Gould Spooling System

(Comment XGP Command Interpreter)

;known bugs - truncation does not happen with print-page-no command
;wrong page no inserted when page overflow occurs

(declare (special lftmar topmar botmar vsp skip size rotate current-height
		  current-font current-font-no current-baseline current-rot
		  current-width defwidth lsp eoffn mainarray file-spec-tab
		  xgp-xorg xgp-yorg wrap-pos wrap-around pagen ppn pb-size-y
		  pb-size-x headrf text-ptr textarray headarray xgp-defaults
		  dfont xgp-rot clear-page-buffer grf-scale grf-xorg grf-yorg grf-rot
		  grf-thick last-x last-y grf-mode xorg yorg in-file npbpos
		  file-command output kset)
	 (flonum size grf-scale)
	 (fixnum lftmar topmar botmar vsp skip current-height current-font-no
		 current-baseline current-rot current-width defwidth lsp pagen
		 ppn botmar1 ch i j ollow pbpos rvsp skpcnt basel chrrct ovsp
		 tlcnt seper sksl yoff bitpos stubit tmp cnt x y x1 y1 x2 y2
		 wid wrap-pos text-ptr savefont xgp-rot k fontno npbpos
		 baseline height rot grf-xorg grf-yorg grf-rot grf-thick
		 xorg yorg xgp-xorg xgp-yorg last-x last-y pb-size-y pb-size-x)
	 (fixnum (ctyi notype) (xgp-x fixnum fixnum) (xgp-y fixnum fixnum)
		 (rot-x fixnum fixnum fixnum) (rot-y fixnum fixnum fixnum)
		 (ftyoq notype fixnum fixnum fixnum fixnum)
		 (ftyo1 fixnum notype fixnum fixnum fixnum fixnum fixnum)
		 (grf-x fixnum fixnum) (grf-y fixnum fixnum)
		 (ards-to-pb-setpoint) (ards-to-pb-long) (ards-to-pb-short))
	 (notype (lsetup notype notype fixnum) (clear-page-buffer)
		 (switch-font fixnum) (font-init) (set-file-info) (set-filepos-info)
		 (ksubset fixnum fixnum fixnum fixnum fixnum)
		 (multstore notype fixnum fixnum fixnum fixnum fixnum)
		 (u-score notype fixnum fixnum fixnum fixnum fixnum)
		 (font fixnum notype fixnum) (output-page-buffer)
		 (ftyo2 fixnum notype fixnum fixnum fixnum fixnum fixnum)
		 (pb-line fixnum fixnum fixnum fixnum) (skip-pages)
		 (xgp-line fixnum fixnum fixnum fixnum)
		 (parse-file-spec notype))
	 (array* (notype font-table 1 font-names 1))
	 (*expr grf-x grf-y ards-to-pb-long ards-to-pb-short ards-to-pb-setpoint
		parse-kset-specs set-file-info output-page-buffer pb-line
		clear-page-buffer ftyo2 ftyo1 font font-init switch-font
		ksubset set-filepos-info)
	 (*lexpr cfilepos user-error))

(eval-when (eval compile)
      (cond ((not (status feature lspmac))
	     (fasload lspmac fasl dsk glpspl)))
      (setsyntax '/# 'macro '/#macro))

(or (get 'ards-to-pb-setpoint 'subr) (get 'ards-to-pb-setpoint 'expr)
    (defprop ards-to-pb-setpoint ((dsk glpspl) ards fasl) autoload))

(special-init wrap-around nil)
(special-init in-file nil)

;lines of text get buffered into mainarray
;format of array: row 0 is used for saving rvsp, basel,scanline and chrcct
;row 1 contains a count of the items in the remaining rows of the array
;and the char that ended the line
;remaining rows contain font-no, index of char in font array, xpos and yoffset
;or for underlines -width, depth of underline, beginning and end xpos's

(setq mainarray (array nil fixnum 500. 4))
(setq headarray (array nil fixnum 200. 4))	; header must have less than 128. chars

(setq xgp-defaults '((topmar . 128.)
		     (lftmar . 128.)
		     (botmar . 124.)
		     (vsp . 6)
		     (lsp . 32.)
		     (skip . 0)
		     (size . 11.0)
		     (headrf . nil))
      dfont '((dsk fonts) 25fg kst))

(defun process-xgp-file (commands)
(*catch  'xgp-error
 (prog (lsp defwidth botmar1 eoffn ppn pagen)
       (clear-page-buffer)
       (font-init)
       (when in-file
	     (setq in-file (open in-file '(in dsk ascii)))
	     (set-file-info))
       ; should be able to set eoffn so that file is not closed when end is hit
       (scrimp-commands in-file commands)
       (if (and (filep in-file) (status filemode in-file)) (filepos in-file 0)
	   (setq in-file (open in-file '(in dsk ascii))))
       (switch-font 0)
       (setq botmar1 (- (fix (*$ size 192.0)) botmar)
	     pagen 0
	     ppn 0
	     defwidth (cond ((= current-width 0) 20.) (t current-width))
	     xgp-yorg (cond ((or (= 1 xgp-rot) (= 2 xgp-rot)) pb-size-x)
			    (t 0))
	     xgp-xorg (cond ((or (= 1 xgp-rot) (= 0 xgp-rot)) 0)
			    (t (1- (lsh pb-size-y 5))))
	     wrap-pos (- (fix (*$ 8.5 200.0)) 100.))
       (cond ((> (+ topmar lsp) botmar1)
	      (user-error
	       '|topmar | topmar '| and botmar | botmar '| overlap, listing aborted/
| '| lsp | lsp '| botmar1 | botmar1 )
	      (throw nil xgp-error)))
       (skip-pages)
       (cond (eoffn (user-error '|skipped of the end of the file, skip =| skip)
		    (throw nil xgp-error)))
       (setq pagen (1+ pagen))	;first page is 1
       (do ((fff nil nil)	;fff set on ^L and eof
	    (ollow 0 0)		;amount previous line went below its baseline
	    (pagep nil nil)	;set when black on page
	    (pbpos 0 0)		;vert pos
	    (npbpos 0 0)	;next lint vert pos (top)
	    (rvsp topmar topmar);amount of line spacing for this line
	    			;(default lsp set by ^?^A")
	    (ovsp 0)		;amount of line spacing for previous line
	    (linep)		;set when black on line
	    (npf)		;set if last line caused page overflow
	    (basel 0)		;height of line above base line
	    (chrrct 0)		;total height of line
	    (infil in-file)	;source of chars
	    (ary mainarray)	;where the line gets buffered up
	    (grf-mode nil)
	    (saveoffn nil)
	    (savefont 0))
	   ((and eoffn (not fff) (not npf)))
	   (cond ((null infil)
		  (user-error '|header overflowed onto new page, removing header|)
		  (setq headrf nil eoffn saveoffn ary mainarray)
		  (switch-font savefont))
		 (headrf
		  (setq saveoffn eoffn eoffn nil text-ptr 0 ary headarray
			infil nil savefont current-font-no)
		  (switch-font 0)))
	   (do nil
	       (nil)
	       (cond ((or fff
			  (progn (setq ovsp rvsp)
				 (cond ((not (and npf infil))
					(lsetup infil ary (+ rvsp pbpos))))
				 (setq fff (= (arraycall fixnum ary 1 1) 12.))
				 (cond ((and fff (null infil)) (clear-page-buffer) (return nil)))
				 (setq fff (or fff (and eoffn infil))
				       grf-mode
				       (not (= (arraycall fixnum ary 1 2) 0))
				       linep (and (not grf-mode)
						  (not
						   (= (arraycall fixnum ary 1 0) 0)))
				       pagep (or pagep grf-mode
						 (not
						  (= (arraycall fixnum ary 1 2) 0)))
				       rvsp (cond (grf-mode 0)
						  (t (arraycall fixnum ary 0 0)))
				       basel (arraycall fixnum ary 0 1)
				       npbpos (arraycall fixnum ary 0 2)
				       chrrct (arraycall fixnum ary 0 3))
				 (and fff (not linep))))
		      (setq pagen (1+ pagen) ppn 0)
		      (and pagep (output-page-buffer)) (clear-page-buffer)
		      (setq fff nil)
		      (return nil)))
	       (cond ((not linep) (setq rvsp (+ rvsp ovsp)))
		     (t 
		      (setq pbpos (cond ((> npbpos 0) npbpos)
					(t (+ pbpos (- ovsp ollow basel)))))
		      (cond ((or (> pbpos botmar1)
				 (progn (setq ollow (- chrrct basel))
					(not (< (+ pbpos chrrct) botmar1))))
			     (setq ppn (1+ ppn))
			     (cond ((and npf
					 (not (= 0 (arraycall fixnum ary 1 0))))
				    (setq npf nil)
				    (user-error
				     '|line too tall for page at |
					 (cfilepos infil)
					 '| ignoring it|))
				   (t (setq npf t fff nil)
				      (store (arraycall fixnum ary 0 2) -1)
				      (and pagep (output-page-buffer)) (clear-page-buffer)))
			     (return nil)))
		      (setq linep (lineoutput ary (+ pbpos basel)))
		      (and infil (setq npf nil pagep (or pagep linep)))
		      (setq pbpos (+ pbpos chrrct))))
	       (cond ((and eoffn (null infil))
		      (setq infil in-file eoffn saveoffn ary mainarray)
		      (switch-font savefont)))))))
 (and in-file (close in-file)))

;xgp/ards conventions.
;
;^?^E takes 7 bytes setting up ards mode
;  2 bytes of x - org for the ards graphics
;  2 bytes of y - org for the ards graphics
;    (both in xgp coordinates)
;    If the highest bit of the more significant byte is on,
;    it means measure relative to current position (lftmar and
;    vertical position between lines
;    The next bit is intepreted as a sign bit (two's complement).
;  1 byte with high 2 bits of rotation (relative to xgp page)
;    and 5 low order bits with line thickness
;  2 bytes of scale for ards graphics (integer and fraction parts)
;
;^?^E should appear as the first printing thing on a line
;
;in this mode ^\, ^], ^^ and ^_ have their ards meanings.
;  viz:  exit graphics mode, enter setpoint, longvector and
;  shortvector modes
;
;xgp coordinates have x increasing along the line and y
;  increasing down the page (with [0,0] at the top left)
;
;ards coordinates have x increasing to the right and y
;  increasing up the page (with [0,0] at the bottom left)
;
;the vectors and characters are drawn as soon as they are read.
;  thus page overflow won't occur if you try to write below botmar.
;
;the xgp commands which normally cause the start of a new line
;  are ill-defined in this mode.  however baseline adjusts, column
;  selects and underscoring should work.
;
;^\, ^], ^^ and ^_ can be printed by preceding them with a ^?.
;
;ards mode may be exited in three ways.
;  1 end of file
;  2 ^L
;  3 ^?^F (if this method is used, subsequent text should be
;    placed as though the text between ^?^E and ^?^F didn't exist.
;
;^?^F exits grf-mode, see above.
;
;^?^G is used to rotate a font.
;  takes low 5 bits of following byte as font number, and high 2
;  bits as rotation relative to xgp page does not change fonts nor
;  rotate current font immediately. 
;
;this command may be giving outside grf-mode.  however the action
;  of printing rotated fonts is only defined in grf-mode.
;
;^?^N is an extended font change command.  The next byte is a font number
; between 0 and 127.  Note, this command does not cause baseline to get adjusted.
;
;at the beginning of a file font n+16 is defined to be identical to
;  font n.

(defun lsetup (infil ary pbpos)  ; pbpos only needed for grf-mode
       (do ((tlcnt 0)	;count of char stored
	    (seper 0)	;inter-char separation
	    (sksl 0)	;amount top of font is below current top of line
	    (yoff 0)	;offset of font's baseline from line's baseline
	    (rvsp lsp)
	    (basel current-baseline)
	    (scanline -1)	; scan line to start line on (-1 means not set)
	    (chrrct current-height)
	    (bitpos lftmar)	;x position
	    (stubit lftmar)	;start underline position
	    (charflg)	;set when an ards function reads one too many chars
	    (ch (ctyi infil) (cond (charflg (setq charflg nil) ch) (t (ctyi infil))))
	    (tmp)	;random
	    (lftmar1 lftmar)
	    (grf-mode nil)
	    (xorg (xgp-x lftmar pbpos))
	    (yorg (xgp-y lftmar pbpos)))
	   ((or (= ch -1) (and (not grf-mode) (= ch 10.)) (= ch 12.))
	    (if (status filemode in-file) (set-filepos-info))
	    (multstore ary 0 rvsp basel scanline chrrct)
	    (multstore ary 1 tlcnt ch (cond (grf-mode 1) (t 0)) 0)
	    nil)
	   (caseq ch
		  (0)		;null (ignore)
		  (8		;backspace
		   (setq bitpos (max 0 (- bitpos current-width seper))))
		  (9		;tab
		   (setq ch (+ defwidth seper)
			 bitpos (- (1- (+ bitpos ch)) lftmar1)
			 ch (lsh ch 3)
			 bitpos (+ lftmar1 (* ch (1+ (// bitpos ch))))))
		  (10.		;only gets here in grf-mode
		   (setq yoff (- yoff lsp)
			 xorg (+ xorg (rot-x bitpos (- yoff) current-rot))
			 yorg (+ yorg (rot-y bitpos (- yoff) current-rot))
			 yoff 0 bitpos 0))
		  (13.		;carriage return
		   (setq bitpos lftmar1))
		  (127.		;rubout, the XGP escape character
		   (setq ch (ctyi infil))
		   (caseq ch
			  (1	;escape 1
			   (setq ch (ctyi infil))
			   (if (= ch -1) (setq ch 0)) 
			   (caseq ch
				  (32.	;column selector
				   (setq bitpos (+ (* 128. (ctyi infil))
						   (ctyi infil))))
				  ((33. 39. 43.)	;fixed underscores
				   (setq tmp (ctyi infil)
					 tmp (+ 3 (if (= ch 43.) (- basel yoff) basel)
						(if (> tmp 63.) (- tmp 128.) tmp)))
				   (if (< tmp 0) (setq sksl (- sksl tmp)
						       basel (- basel tmp)
						       chrrct (- chrrct tmp) tmp 0))
				   (if (not (< tmp chrrct)) (setq chrrct (+ tmp 1)))
				   (setq tmp (- tmp basel))
				   (cond ((or (= ch 33.) (= ch 43.))	;absolute
					  (u-score ary tlcnt 1 tmp bitpos
						   (+ bitpos (* 128. (ctyi infil))
						      (ctyi infil))))
					 (t	;start and stop
					  (u-score ary tlcnt 1 tmp stubit
						   (- bitpos seper))))
				   (setq tlcnt (1+ tlcnt)))
				  (41.	;variable width flavor
				   (setq ch (ctyi infil)
					 tmp (ctyi infil)
					 tmp (+ 3 basel
						(if (> tmp 63.) (- tmp 128.) tmp)))
				   (cond ((< tmp 0)
					  (setq sksl (- sksl tmp) basel (- basel tmp)
						chrrct (- chrrct tmp) tmp 0)))
				   (cond ((not (< tmp chrrct)) (setq chrrct (+ tmp 1))))
				   (setq tmp (- tmp basel))
				   (u-score ary tlcnt ch tmp stubit
					    (- bitpos seper))
				   (setq chrrct (max chrrct (+ basel tmp ch)))
				   (setq tlcnt (1+ tlcnt)))
				  (34.	;line space, sets rvsp and acts like lf
				   (setq rvsp (ctyi infil))
				   (cond ((not grf-mode)
					  (multstore ary 0 rvsp basel scanline chrrct)
					  (multstore ary 1 tlcnt 10. 0 0)
					  (return nil))))
				  ((35. 42.)	;baseline adjusts
				   (setq tmp (ctyi infil)
					 tmp (cond ((> tmp 63.) (- tmp 128.)) (t tmp)))
				   (cond ((= ch 35.)	;absolute
					  (setq yoff tmp
						sksl (- basel current-baseline tmp)))
					 (t	;relative
					  (setq yoff (+ yoff tmp) sksl (- sksl tmp))))
				   (cond ((< sksl 0)
					  (setq basel (- basel sksl)
						chrrct (- chrrct sksl)
						sksl 0)))
				   (setq ch (+ current-height sksl)
					 chrrct (max chrrct ch)))
				  (36.	;print page number
				   (let ((base 10.)(*nopoint t) (l))
					(setq l (exploden pagen))
					(unless (= ppn 0)
						(setq l (append l '(46.)
								(exploden ppn))))
					(do nil ((null l))
					    (setq ch (ftyoq ary tlcnt
							    (car l) bitpos yoff))
					    (cond ((not (= ch 0)) 
						   (setq bitpos (+ bitpos seper ch))
						   (setq tlcnt (1+ tlcnt))))
					    (setq l (cdr l)))))
				  (37.	;heading text 
				   (setq ch (ctyi infil))
				   (cond ((not (> ch 0)) (setq headrf nil))
					 (t 
					  (cfilepos
					   infil
					   (prog2 nil (cfilepos infil)
						  (do ((j 1 (1+ j)))
						      ((> j ch)
						       (store
							(arraycall fixnum textarray ch)
							-1)
						       nil)
						      (store
						       (arraycall fixnum textarray (1- j))
						       (ctyi infil))))))))
				  (38.	;start underline
				   (setq stubit bitpos))
				  (40.	;interchar spacing
				   (setq seper (ctyi infil)))
				  (t
				   (when (< ch 32.)	;font change
					 (let ((rot current-rot))
					      (switch-font ch)
					      (unless (= current-rot rot)
						      (setq xorg (+ xorg (rot-x bitpos 0
										rot))
							    yorg (+ yorg (rot-y bitpos 0
										rot))
							    bitpos 0)))
					 (setq yoff 0)
					 (cond ((= tlcnt 0)
						(setq basel current-baseline
						      chrrct current-height
						      sksl 0))
					       (t (setq sksl (- basel current-baseline))
						  (cond ((< sksl 0)
							 (setq chrrct (- chrrct sksl)
							       basel current-baseline
							       sksl 0)))
						  (setq ch (+ current-height sksl)
							chrrct (max chrrct ch))))))))
			  (2	;escape 2 - column increment
			   (setq ch (ctyi infil)
				 bitpos (+ bitpos (cond ((> ch 63.) (- ch 128.))
							(t ch))))
			   (or grf-mode (setq bitpos (max 0 bitpos))))
			  (3	;escape 3 - scan line selector (sets scanline)
			   (setq ch (ctyi infil)
				 scanline (+ (* 128. ch) (ctyi infil))))
			  (4	;escape 4 - vectors  (vert & horiz rules)
			   (let* ((tmp 0.)
				  (y0 (progn (setq tmp (ctyi infil))
					     (+ (* tmp 128.) (ctyi infil))))
				  (x0 (progn (setq tmp (ctyi infil))
					     (+ (* tmp 128.) (ctyi infil))))
				  (dx (progn (setq tmp (ctyi infil))
					     (+ (* tmp 128.) (ctyi infil))))
				  (dx* (ctyi infil))	;unused
				  (n  (progn (setq tmp (ctyi infil))
					     (+ (* tmp 128.) (ctyi infil))))
				  (w  (progn (setq tmp (ctyi infil))
					     (+ (* tmp 128.) (ctyi infil)))))
				 (declare (fixnum x0 y0 dx dx* n w tmp))
				 (do ((w w (1- w))(x0 x0 (1+ x0))) ((= w 0))
				     (xgp-line x0 y0
					       (+ (* (boole 1 1 (lsh dx -13.))	;sign
						     (boole 1 3777 (lsh dx -2)));11. bits
						  x0)
					       (+ y0 n)))))
			  (5	;enter ards mode
			   (setq grf-mode t
				 ch (ctyi infil) ch (+ (* ch 128.) (ctyi infil))
				 ch (+ ch (cond ((= (boole 1 ch 1_13.) 0) 0)
						(t (- lftmar 1_13.)))
				       (cond ((= (boole 1 ch 1_12.) 0) 0)
					     (t (- 1_13.))))
				 tmp (ctyi infil) tmp (+ (* tmp 128.) (ctyi infil))
				 tmp (+ tmp (cond ((= (boole 1 tmp 1_13.) 0) 0)
						  (t (- pbpos 1_13.)))
					(cond ((= (boole 1 tmp 1_12.) 0) 0)
					      (t (- 1_13.))))
				 grf-xorg (prog2 nil (xgp-x ch tmp)
						 (setq grf-yorg (xgp-y ch tmp)))
				 ch (ctyi infil)
				 grf-thick (boole 1 31. ch)
				 grf-rot (boole 1 3 (+ xgp-rot (lsh ch -5)))
				 ch (ctyi infil)
				 grf-scale (+$ (float ch)
					       (//$ (float (ctyi infil)) 128.0))))
			  (6	;exit grf-mode and exit lsetup as though by lf.
			   (cond (grf-mode
				  (multstore ary 0 rvsp basel scanline chrrct)
				  (multstore ary 1 tlcnt 10. 1 0)
				  (return nil))))
			  (7	;rotate font
			   (setq ch (ctyi infil) tmp (boole 1 ch 31.)
				 ch (lsh ch -5))
			   (font tmp (cdr (font-names tmp)) (+ ch xgp-rot)))
			  (14.	;extended font change
			   (switch-font (ctyi infil))
			   (setq yoff 0)
			   (cond ((= tlcnt 0)
				  (setq basel current-baseline
					chrrct current-height
					sksl 0))
				 (t (setq sksl (- basel current-baseline))
				    (cond ((< sksl 0)
					   (setq chrrct (- chrrct sksl)
						 basel current-baseline
						 sksl 0)))
				    (setq ch (+ current-height sksl)
					  chrrct (max chrrct ch)))))
			  (t	;anything else is quoted
			   (setq ch (ftyoq ary tlcnt ch bitpos yoff))
			   (cond ((not (= ch 0)) 
				  (setq bitpos (+ bitpos seper ch))
				  (cond ((and wrap-around (> bitpos wrap-pos)
					      (not grf-mode))
					 (cfilepos infil (- (cfilepos infil) 2))
					 (multstore ary 0 rvsp basel scanline chrrct)
					 (multstore ary 1 tlcnt 10. 0 0)
					 (return nil))
					(t (setq tlcnt (1+ tlcnt)))))))))
				;normal chars
		  (t
		   (cond ((and grf-mode (= ch 28.)))	;ards exit-graphics
			 ((and grf-mode (or (= ch 29.) (= ch 30.) (= ch 31.)))
			  (caseq ch
				 (29.	;ards set-point
				  (setq ch (ards-to-pb-setpoint)))
				 (30.	;ards long-vector
				  (setq ch (ards-to-pb-long)))
				 (t	;ards short-vector
				  (setq ch (ards-to-pb-short))))
			  (setq charflg t bitpos 0 yoff 0
				xorg (grf-x last-x last-y)
				yorg (grf-y last-x last-y)))
			 (t (setq ch (ftyoq ary tlcnt ch bitpos yoff))
			    (cond ((not (= ch 0))
				   (setq bitpos (+ bitpos seper ch))
				   (cond ((and wrap-around (> bitpos wrap-pos) (not grf-mode))
					  (cfilepos infil (1- (cfilepos infil)))
					  (multstore ary 0 rvsp basel scanline chrrct)
					  (multstore ary 1 tlcnt 10. 0 0)
					  (return nil))
					 (t (setq tlcnt (1+ tlcnt))))))))))))

;tyi function sets eoffn on end of file.  reads from textarray if infil is nil
(defun ctyi (infil)
       (cond (eoffn -1)
	     (t ((lambda (i)
			 ;(and (= i 3) (setq i -1))
			 (and (= i -1) (setq eoffn t)) i)
		 (cond (infil (tyi infil))
		       (t (arraycall fixnum textarray
				     (prog2 nil text-ptr
					    (setq text-ptr (1+ text-ptr))))))))))

;filepos funtion - uses textarray if first arg is nil
(defun cfilepos i
       (cond ((= i 1)
	      (cond (eoffn -1)
		    (t (cond ((arg 1) (filepos (arg 1)))
				 (t text-ptr)))))
	     ((= i 2)
	      (cond ((arg 1)
		     (unless eoffn
			     (open (arg 1) '(in ascii dsk))
			     (set-file-info))
		     (filepos (arg 1) (arg 2)))
		    (t (setq text-ptr (arg 2)))))))

;stores a row into the line array
(defun multstore (ary cnt x y x1 y1)
       (or (< cnt (cadr (arraydims ary))) (*rearray ary 'fixnum (1+ cnt) 4))
       (store (arraycall fixnum ary cnt 0) x)
       (store (arraycall fixnum ary cnt 1) y)
       (store (arraycall fixnum ary cnt 2) x1)
       (store (arraycall fixnum ary cnt 3) y1)
       nil)

;stores a char into the line array
(defun ftyoq (ary cnt ch x y)
       (cond (grf-mode (ftyo1 ch current-font
			       (+ yorg (rot-y x (- y) current-rot))
			       (+ xorg (rot-x x (- y) current-rot))
			       current-height current-baseline current-rot))
	     (t (setq ch (arraycall fixnum current-font ch))
		(cond ((= ch 0) 0)
		      (t (multstore ary (+ 2 cnt) current-font-no ch x y)
			 (arraycall fixnum current-font (+ ch 2)))))))

;store an underscore into the line array 
(defun u-score (ary cnt wid y x1 x2)
       (cond (grf-mode
	      (do ((j 0 (1+ j)))
		  ((= j wid))
		  (pb-line (+ yorg (rot-y x1 y current-rot))
			   (+ xorg (rot-x x1 y current-rot))
			   (+ yorg (rot-y x2 y current-rot))
			   (+ xorg (rot-x x2 y current-rot)))
		  (setq y (1+ y))))
	     (t (multstore ary (+ 2 cnt) (- wid) y x1 x2))))

;outputs the line array into the pb array with y origin pbpos.  returns nil
; if eoffn is t and there are only ^C's on the line
(defun lineoutput (ary pbpos)
       (let ((j (1+ (arraycall fixnum ary 1 0))))
	    (when eoffn
		  (do ((i j (1- i)) (k (arraycall fixnum ary j 0)) (ch))
		      ((or (< i 2) (< k 0)
			   (not (= k (arraycall fixnum ary i 0)))))
		      (when (= i j)
			    (setq ch (arraycall fixnum (font-table k) 3)))
		      (cond ((= (arraycall fixnum ary i 1) ch)
			     (setq j (1- j)))
			    (t (return nil)))))
       (do ((i 2 (1+ i)) (k) (fontno -1) (font) (baseline 0) (height 0) (rot 0))
	   ((> i j) (> j 1))
	   (setq k (arraycall fixnum ary i 0))
	   (cond ((< k 0)
		  (do ((j 0 (1- j))
		       (y (+ pbpos (arraycall fixnum ary i 1)) (1+ y))
		       (x1 (arraycall fixnum ary i 2))
		       (x2 (arraycall fixnum ary i 3)))
		      ((= j k))
		      (pb-line (xgp-y x1 y) (xgp-x x1 y) (xgp-y x2 y) (xgp-x x2 y))))
		 (t (cond ((not (= k fontno))
			   (setq font (font-table k)
				 height (arraycall fixnum font 128.)
				 baseline (arraycall fixnum font 129.)
				 rot (arraycall fixnum font 130.)
				 fontno k)))
		    (let ((x (arraycall fixnum ary i 2))
			  (y (- pbpos (arraycall fixnum ary i 3))))
			 (ftyo2 (arraycall fixnum ary i 1) font
				(xgp-y x y) (xgp-x x y)
				height baseline rot)))))))

(defun xgp-x (x y) (+ xgp-xorg (rot-x x y xgp-rot)))

(defun xgp-y (x y) (+ xgp-yorg (rot-y x y xgp-rot)))

(defun rot-x (x y rot) (cond ((oddp rot) (* (- 2 rot) y)) (t (* (- 1 rot) x))))

(defun rot-y (x y rot) (cond ((oddp rot) (* (- rot 2) x)) (t (* (- 1 rot) y))))

;;; xgp x,y coordinates into PB x coordinate
(defun xgp-to-pb-x (x y)
   (caseq xgp-rot
	  (0 y)
	  (1 (- pb-size-x x))
	  (2 (- pb-size-x y))
	  (3 x)))

;;; xgp x,y coordinates into PB y coordinate
(defun xgp-to-pb-y (x y)
   (caseq xgp-rot
	  (0 x)
	  (1 y)
	  (2 (- (1- (lsh pb-size-y 5)) x))
	  (3 (- (1- (lsh pb-size-y 5)) y))))

(defun xgp-line (x y x1 y1)
   (pb-line (xgp-to-pb-x x y)   (xgp-to-pb-y x y)
	    (xgp-to-pb-x x1 y1) (xgp-to-pb-y x1 y1)))

;;; Read the scrimp commands at the beginning of the file

(defun scrimp-commands (infil flags)
   (mapc (function (lambda (l) (set (car l) (cdr l)))) xgp-defaults)
   (setq xgp-rot (if (eq 'xgp output) 0 3))		;default rotations
   (let ((txtcmd) (val))
	 (when (setq val (assq 'rotate flags))		;need rotate bfore kset
	       (setq val (cdr val)
		     xgp-rot (if (fixp val) (boole 1 3 val)
				 xgp-rot)))
	 (unless (assq 'sample flags)			;don't bother if ;SAMPL
		 (unless (filep infil)
			 (setq infil (if infil (open infil '(in ascii dsk)))))
		 (do ((i (ctyi infil) (ctyi infil)) (command))
		     ((or (= i #^L)
			  (not (or (= i #^J) (= i #^M)
				   (= i #=/ ) (= i #=/;)))))
		     (unless (= i #=/;) (return nil))
		     (setq command (errset (read infil) nil))
		     (unless command (return nil))
		     (setq command (car command))
		     (caseq command
			    ((reset squish))		;ignore these
			    (ksubset
			     (let ((ln (read infil)) (l))
				  (do ((i 0 (1+ i)) (ibase 8.) (l1))
				      ((= i 4))
				      (setq l1 (read infil))
				      (unless (fixp l1) (setq l1 -1))
				      (setq l (cons l1 l)))
				  (when (fixp ln)
					(apply 'ksubset
					       (cons ln (nreverse l))))))
			    (rotate (setq xgp-rot (read infil)))
			    ((skip topmar botmar lftmar vsp lsp)
			     (set command
				  (let ((l (read infil)))
				       (if (fixp l) l
					   (cdr (assoc command xgp-defaults))))))
			    (size
			     (setq size
				   (let ((l (read infil)))
					(if (numberp l) (float l)
					    (cdr (assoc 'size xgp-defaults))))))
			    (kset
			     (do ((i 0 (1+ i))
				  (l (parse-kset-specs (readline infil)) (cdr l)))
				 ((null l))
				 (if (car l) (font i (car l) xgp-rot)))))
		     (setq txtcmd t)))
	 (do ((l flags (cdr l)) (command) (l1) (val))
	     ((null l))
	     (setq l1 (car l))
	     (desetq (command . val) l1)
	     (caseq command
		    ((skip topmar botmar lftmar vsp lsp)
		     (set command (if (fixp val) val
				      (cdr (assoc command xgp-defaults)))))
		    (sample
		     (font 1 (mergef (namelist val) '((dsk fonts) 25fg kst)) xgp-rot)
		     (setq headrf t)
		     (textsetup (defheadr (cdr (font-names 1))))
		     (setq in-file (open '((dsk fonts) codes >) '(in dsk ascii))))))
	 (if kset (do ((i 0 (1+ i))
		       (l kset (cdr l)))
		      ((null l))
		      (if (car l) (font i (car l) xgp-rot))))
	 (when (or (eq 'list file-command) (null txtcmd))
	       (setq headrf t wrap-around t)
	       (textsetup (defheadr (probef in-file))))))

(defun skip-pages nil
   (unless (= skip 0)
	   (do ((ch (ctyi in-file) (ctyi in-file)))
	       (eoffn)
	       (caseq ch
		      (12.
		       (setq pagen (1+ pagen))
		       (unless (< pagen skip) (return t)))
		      (127.
		       (setq ch (ctyi in-file))
		       (caseq ch
			      (1
			       (setq ch (ctyi in-file))
			       (caseq ch
				      ((32. 41.) (ctyi in-file) (ctyi in-file))
				      (33. (ctyi in-file) (ctyi in-file)
					   (ctyi in-file))
				      ((34. 35. 39. 40. 42.) (ctyi in-file))
				      (37.
				       (setq ch (ctyi in-file))
				       (do ((j 1 (1+ j)))
					   ((> j ch))
					   (ctyi in-file)))))
			      (2 (ctyi in-file))
			      (3 (ctyi in-file) (ctyi in-file))
			      (4 (do ((j 0 (1+ j)))
				     ((= j 11.))
				     (ctyi in-file)))))))))

(defun defheadr (file)
   (let ((time (status daytime))
	 (day (status dow))
	 (date (status date))
	 (base 10.) (*nopoint t))
	(setq time (mapcar (function
			    (lambda (i)
				    (cond ((< i base) (cons 48. (exploden i)))
					  (t (exploden i)))))
			   time)
	      time (append (car time) '(58.) (cadr time) '(58.) (caddr time))
	      day (exploden day)
	      day (cons (car day) (mapcar (function (lambda (i) (+ i 32.)))
					  (cdr day)))
	      date (append (exploden (cdr (assoc (cadr date)
						 '((1 . |January|)
						   (2 . |February|)
						   (3 . |March|)
						   (4 . |April|)
						   (5 . |May|)
						   (6 . |June|)
						   (7 . |July|)
						   (8 . |August|)
						   (9 . |September|)
						   (10. . |October|)
						   (11. . |November|)
						   (12. . |December|)))))
			   '(32.)
			   (exploden (caddr date))
			   '(44. 32. 49. 57.) (exploden (car date))))
		(maknam (append day '(44. 32.) date '(32. 32. 32.) time
				(exploden '|          |)
				(exploden (namestring file))
				(exploden '|          |)
				(exploden '|Page |)
				'(127. 1 36. 13. 10.)))))


(or (boundp 'textarray) (setq textarray (array nil fixnum 270.)))

(defun textsetup (text)
       (do ((l (exploden text) (cdr l)) (i 0 (1+ i)))
	   ((or (null l) (= i (cadr (arraydims textarray))))
	    (store (arraycall fixnum textarray i) -1)
	    (setq text-ptr 0)
	    nil)
	   (store (arraycall fixnum textarray i) (car l))))



;; Local Modes:
;; Mode: LISP
;; Comment Col: 40
;; END:
