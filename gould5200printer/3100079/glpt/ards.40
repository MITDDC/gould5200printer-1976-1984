;; -*- Lisp -*-

;Ards to TV conversion routines.  Part of Gould spooler package.
; This file interprets ARDS files and uses the FTV routines to
;  convert them to raster form in the TV array.
;Window for gould plotting is  [8. 1015., 5. 790.]

(declare (special current-height current-width current-baseline current-rot
		  current-font xorg yorg last-x last-y in-file tv-char-width2
		  tv-char-height2 eoffn tv-size-x tv-size-y tv-clear ards-thick
		  ards-scale ards-xorg ards-yorg ards-rot ards-commands ards-defaults
		  tek-commands tek-hix tek-hiy tek-loy ards-botmar ards-lftmar
		  def-ards-rot)
	 (fixnum current-height current-width current-baseline current-rot xorg yorg
		 last-x last-y tv-char-width2 tv-char-height2 tv-size-x tv-size-y
		 x y x1 y1 x2 y2 i j start ards-thick ards-xorg ards-yorg ards-rot
		 hix hiy loy tek-hix tek-hiy tek-loy ards-botmar ards-lftmar
		 def-ards-rot)
	 (flonum ards-scale)
	 (fixnum (ards-x fixnum fixnum) (ards-y fixnum fixnum)
		 (ards-to-tv-char fixnum) (ards-to-tv-setpoint) (ards-to-tv-long)
		 (ards-to-tv-short) (tek-to-tv-vector) (qtyi notype)
		 (ftyo1 fixnum notype fixnum fixnum fixnum fixnum fixnum))
	 (notype (ards-line fixnum fixnum fixnum fixnum)
		 (tv-linen fixnum fixnum fixnum fixnum fixnum)
		 (font fixnum notype fixnum) (switch-font fixnum) (tv-formfeed)
		 (tv-clear))
	 (newio t) (setq nfunvars t))

(or (boundp 'ards-commands) (setq ards-commands nil))
(or (boundp 'tek-commands) (setq tek-commands nil))

(comment Co-ordinate transformation)

;Transform ards x and y coordinates into tv ones s.t. [0,0] ==> [ards-xorg,ards-yorg]
;ards-rot specifies rotation, 0 means
; ards x axis ==> tv x axis, ards y axis ==> tv -y axis
;rotation is measured anti-clockwise in units of 90 degrees

(defun ards-x (x y)
       (+ ards-xorg
	  (cond ((oddp ards-rot) (* (- ards-rot 2.) (fix (*$ (float y) ards-scale))))
		(t (* (- 1. ards-rot) (fix (*$ (float x) ards-scale)))))))

(defun ards-y (x y)
       (+ ards-yorg
	  (cond ((oddp ards-rot) (* (- ards-rot 2.) (fix (*$ (float x) ards-scale))))
		(t (* (1- ards-rot) (fix (*$ (float y) ards-scale)))))))

(defun ards-line (x y x1 y1)
       (tv-linen (ards-x x y) (ards-y x y) (ards-x x1 y1) (ards-y x1 y1) ards-thick)) 

(defun qtyi (infil) (cond (eoffn -1.) (t (tyi infil))))

(or (get 'tv-clear 'subr) (get 'tv-clear 'expr)
    (defprop tv-clear (ftv fasl dsk glpt) autoload))

(setq ards-defaults '((ards-scale . 1.75)
		      (ards-thick . 2.)
		      (ards-botmar . 150.)
		      (ards-lftmar . 150.))
      def-ards-rot 0.)

(defun ards-print (file) (graphics-print file t))

(defun tek-print (file) (graphics-print file nil))

(defun graphics-print (file ards-flag)
       (tv-clear)
       (ards-commands ards-flag)
       (cond ((= ards-rot 0.)
	      (setq ards-xorg ards-lftmar ards-yorg (- tv-size-y ards-botmar)))
	     ((= ards-rot 1.)
	      (setq ards-xorg (- (lsh tv-size-x 5.) ards-botmar)
		    ards-yorg (- tv-size-y ards-lftmar)))
	     ((= ards-rot 2.)
	      (setq ards-xorg (- (lsh tv-size-x 5.) ards-lftmar) ards-yorg ards-botmar))
	     (t (setq ards-xorg ards-botmar ards-yorg ards-lftmar)))
       (font 31. '((dsk fonts) 25fr kst) ards-rot)
       (switch-font 31.)
       (setq last-x 0. last-y 0. tek-hix 0. tek-hiy 0. tek-loy 0.
	     tv-char-width2 (1+ (fix (//$ (float current-width) ards-scale)))
	     tv-char-height2 (1+ (fix (//$ (float current-height) ards-scale)))
	     eoffn nil in-file (open file '(in dsk image)))
       (do ((i (qtyi in-file)))
	   ((< i 0.) (cond ((null tv-clear) (tv-formfeed))) (close in-file))
	   (cond ((= i 12.) (tv-formfeed) (tv-clear) (setq i (qtyi in-file)))
		 ((= i 29.) (setq i (cond (ards-flag (ards-to-tv-setpoint))
					  (t (tek-to-tv-vector)))))
		 ((and ards-flag (= i 30.)) (setq i (ards-to-tv-long)))
		 ((and ards-flag (= i 31.)) (setq i (ards-to-tv-short)))
		 (t (setq i (ards-to-tv-char i ards-flag))))))

(defun ards-commands (ards-flag)
       (mapcar (function (lambda (l) (set (car l) (cdr l)))) ards-defaults)
       (setq ards-rot def-ards-rot)
       (do ((l (cond (ards-flag ards-commands) (t tek-commands)) (cdr l))
	    (command) (val) (l1))
	   ((null l))
	   (setq l1 (car l) command (car l1) val (cadr l1))
	   (cond ((memq command '(thick botmar lftmar rot))
		  (and (fixp val)
		       (set (cdr (assoc command '((thick . ards-thick)
						  (botmar . ards-botmar)
						  (lftmar . ards-lftmar)
						  (rot . ards-rot))))
				       val)))
		 ((eq command 'scale)
		  (cond ((numberp val) (setq ards-scale (float val)))
			(t (setq val (car (errset (readlist (exploden val)))))
			   (and (floatp val) (setq ards-scale val))))))))

(defun ards-to-tv-char (i ards-flag)
       (do ((i i (qtyi in-file)))
	   ((or (< i 0.) (= i 12.) (= i 29.) (and ards-flag (or (= i 30.) (= i 31.))))
	    i)
	   (cond ((= i 8.) (setq last-x (- last-x tv-char-width2)))
		 ((= i 9.)
		  (setq last-x (* 8. tv-char-width2
				  (1+ (// last-x tv-char-width2 8.)))))
		 ((= i 10.) (setq last-y (- last-y tv-char-height2)))
		 ((= i 11.) (setq last-y (+ last-y tv-char-height2)))
		 ((= i 13.) (setq last-x 0.))
		 ((= i 32.) (setq last-x (+ last-x tv-char-width2)))
		 ((or (= i 127.) (= i 28.)))   ; ignore rubout and ^\
		 (T ; allow other controls to be printed as greek chars
		  (ftyo1 i current-font (ards-x last-x last-y) (ards-y last-x last-y)
			 current-height current-baseline current-rot)
		  (setq last-x (+ last-x tv-char-width2))))))

(defun ards-to-tv-setpoint nil
       (do ((i (qtyi in-file) (qtyi in-file))
	    (x1) (x2) (y1) (y2) (j 0. (\ (1+ j) 4.)))
	   ((< i 64.) i)
	   (cond ((= j 0.) (setq x1 i)) ((= j 1.) (setq x2 i)) ((= j 2.) (setq y1 i))
		 ((= j 3.) (setq y2 i)
		  (setq y2 (+ (lsh (boole 1. 31. y2) 5.) (boole 1. 31. (lsh y1 -1.))))
		  (cond ((= (boole 1. 1. y1) 1.) (setq y2 (- y2))))
		  (setq x2 (+ (lsh (boole 1. 31. x2) 5.) (boole 1. 31. (lsh x1 -1.))))
		  (cond ((= (boole 1. 1. x1) 1.) (setq x2 (- x2))))
		  (setq last-x (+ 512. x2) last-y (+ 512. y2))))))

(defun ards-to-tv-long nil
       ; dotted vectors not implemented
       (do ((i (qtyi in-file) (qtyi in-file))
	    (x1) (x2) (y1) (y2) (j 0. (\ (1+ j) 4.)))
	   ((< i 64.) i)
	   (cond ((= j 0.) (setq x1 i)) ((= j 1.) (setq x2 i)) ((= j 2.) (setq y1 i))
		 ((= j 3.) (setq y2 i)
		  (setq y2 (+ (lsh (boole 1. 31. y2) 5.) (boole 1. 31. (lsh y1 -1.))))
		  (cond ((= (boole 1. 1. y1) 1.) (setq y2 (- y2))))
		  (setq i (boole 1. 1. (lsh x2 -5.)))
		  (setq x2 (+ (lsh (boole 1. 31. x2) 5.) (boole 1. 31. (lsh x1 -1.))))
		  (cond ((= (boole 1. 1. x1) 1.) (setq x2 (- x2))))
		  (cond ((= i 0.)
			 (ards-line last-x last-y (+ last-x x2) (+ last-y y2))))
		  (setq last-x (+ last-x x2) last-y (+ last-y y2))))))

(defun ards-to-tv-short nil
       (do ((i (qtyi in-file) (qtyi in-file)) (x1) (y1) (j 0. (\ (1+ j) 2.)))
	   ((< i 64.) i)
	   (cond ((= j 0.) (setq x1 i))
		 ((= j 1.) (setq y1 i)
		  (setq i (boole 1. 1. y1) y1 (boole 1. 31. (lsh y1 -1.)))
		  (cond ((= i 1.) (setq y1 (- y1))))
		  (setq i (boole 1. 1. x1) x1 (boole 1. 31. (lsh x1 -1.)))
		  (cond ((= i 1.) (setq x1 (- x1))))
		  (ards-line last-x last-y (+ last-x x1) (+ last-y y1))
		  (setq last-x (+ last-x x1) last-y (+ last-y y1))))))

(defun tek-to-tv-vector nil
       (do ((i (qtyi in-file) (qtyi in-file)) (esc-flag) (dark-flag t) (loy-flag)
	    (hiy tek-hiy) (hix tek-hix) (loy tek-loy) (x 0.) (y 0.))
	   ((or (= i 31.) (= i 13.) (< i 0.) (and esc-flag (= i 12.)))
	    (setq tek-hix hix tek-hiy hiy tek-loy loy)
	    i)
	   (setq esc-flag (= i 27.))
	   (cond ((= i 29.) (setq dark-flag t))
		 ((< i 32.))
		 ((< i 64.) (cond (loy-flag (setq hix i)) (t (setq hiy i))))
		 ((< i 96.)
		  (setq x (boole 7. (lsh (boole 1. 31. hix) 5.) (boole 1. 31. i))
			y (boole 7. (lsh (boole 1. 31. hiy) 5.) (boole 1. 31. loy)))
		  (cond (dark-flag (setq dark-flag nil))
			(t (ards-line last-x last-y x y)))
		  (setq last-x x last-y y loy-flag nil))
		 (t (setq loy i loy-flag t)))))