PROCEDURE FOR RELOADING THE PDP-11

1)	RESTRAIN WHOEVER IS USING THE TEKTRONIX FROM TYPING UNTIL YOU ARE FINISHED

2)	ON THE IMLAC (OR ANY OTHER NON-MULTIPLEXED TERMINAL) TYPE  :L GLPT;

3)	AFTER IT FINISHES LOADING (A LONG NUMBER BEGINNING WITH 13 IS TYPED OUT)
	TYPE <CNTL>-^ <CNTL>-\   WHICH SHOULD RESULT IN A REQUEST FOR A FILE NAME

4)	GO OVER TO THE 11 AND SET 137500 ON THE SWITCHES, MAKE SURE THE <ENABLE/HALT>
	SWITCH IS IN THE ENABLE POSITION, THEN PRESS <LOAD ADRS> AND <START>.

5)	IF THE LIGHTS DON'T START FLASHING, THE ABSOLUTE LOADER IS CLOBBERED.
	TRY SETTING THE SWITCHES TO 137744 AND PRESS <LOAD ADRS> AND <START>.

6)	IF THE LIGHTS STILL DON'T START FLASHING, THE BOOT LOADER IS CLOBBERED.
	TO RELOAD THE BOOT LOADER, SET THE SWITCHES TO 137744, PRESS <LOAD ADRS>
	AND <EXAM>.  THEN SET THE SWITCHES TO THE FIRST NUMBER OF THE DATA LIST BELOW
	AND LIFT UP ON THE <DEP> SWITCH. RESET THE SWITCHES TO THE NEXT NUMBER AND
	LIFT UP ON THE <DEP> SEITHC AGAIN.  REPEAT UNTIL THE END OF THE LIST IS REACHED.
	IF YOU NOT CONFIDENT THAT YOU HAVE DEPOSITED THE CORRECT NUMBERS, PRESS
	<LOAD ADRS> AND EXAM, AND CONTINUE TO PRESS <EXAM>, CHECKING THE VALUES EACH
	TIME (DO NOT GO BEYOND THE LAST LOCATION, ELSE THE 11 WILL "FREEZE" AND YOU
	HAVE TO TURN IT OFF AND ON AGAIN TO "UN-FREEZE" IT!!)

		      Boot Loader
		Address		 Data
		137744		016701
		137746		000026
		137750		012702
		137752		000352
		137754		005211
		137756		105711
		137760		100376
		137762		116162
		137764		000002
		137766		137400
		137770		005267
		137772		177756
		137774		000765
		137776		175610

7)	ASSUMING THAT THE BOOT LOADER IS NOW WORKING AND RUNNING, TYPE CARRIAGE
	RETURN TO THE INTERROGATION FOR FILE NAME ON THE IMLAC.  THIS WILL LOAD
	THE ABSOLUTE LOADER

8)	ASSUMING THAT THE ABSOLUTE LOADER IS NOW WORKING AND RUNNING, TYPE <CNTL>-\
	GLPT;GOULD BIN <CR> AND WAIT UNTIL IT SAYS "LOADING DONE".  TYPE <CNTL>-Z
	AND :KILL <CR>

9)	NOW SET THE SWITCHES TO 2000 AND PRESS <LOAD ADRS> AND <START>.  THE
	RIGHTMOST LIGHT SHOULD BE STEADILY LIT.  IF LIGHTS ARE STILL FLASHING,
	THERE IS SOME CRUFT LEFT OVER FOR SOME TERMINAL OR THE GOULD. TOGGLE
	<HALT> <LOAD ADRS> <START> IN SUCCESSION UNTIL (DIM) FLASHING STOPS.

10)	IF THE GOULD DOES NOT PRINT, MAKE SURE THAT THE <POWER ON> AND <REMOTE>
	SWITCHES ARE DEPRESSED AND GLOWING AND THAT THE <INTLK> AND <PAPER LOW>
	INDICATORS ARE NOT FLASHING.  IF THE GOULD STILL REFUSES TO PRINT,
	AND THERE IS NO APPARENT PROBLEM WITH THE SPOOLER OR UNSPOOLR,
	PRESS <HALT>, SET THE SWITCHES TO 166000, AND PRESS <LOAD ADRS>
	<EXAM>.  THE 2000 BIT SHOULD BE LIT (BIT 10).  IF IT IS NOT, GO OVER TO
	THE GOULD AND PUNCH THESE BUTTONS IN SUCESSION:  <REMOTE> <POWER ON>
	<POWER ON> <REMOTE>.  NOW CHECK FOR THE 2000 BIT AGAIN (WHICH INDICATES
	DMA IDLE).  IF IT IS SET, KILL THE UNSPOOLER, RESTART THE PDP-11 AS PER
	9), AND START UP THE UNSPOOLR AS PER 11)

11)	TO START THE UNSPOOLR, TYPE GORBIT <CNTL>-K, WHICH THEN RESPONDS WITH A
	17<ALT><ALT><CNTL>-K, AND IS RUNNING AND DISOWNED.

12)	TO QUEUE FILES, DO A :GTPL <FILE NAME> <FILE SPECS>
DISCLAIMER

UNTIL THE DEFAULTS ON ITS ARE SET TO THEIR PROPER VALUES, EVERY TIME
THE SYSTEM COMES DOWN THEN BACK UP, THE FOLLOWING PARAMETERS MUST BE
SET:

:LSPEED 17 2

:TCTYP TTY 24 -%TPORS +%TPCBS

:TCTYP TTY 17 PRINTING -%TPORS -%TPCBS

:TCTYP TTY 26 PRINTING -%TPORS +%TPCBS


WHAT SORT OF STUFF THE PDP11-GOULD PROGRAM EXPECTS:

CHARACTERS PROCESSED AT INTERRUPT LEVEL

%CCSOD=205	; ESCAPE FOR BEGINNING OF DATA
%CCEOD=206	; ESCAPE FOR END OF DATA
%CCQOT=215	; QUOTE CHARACTER FOR 8 BIT DATA CODES
%CCACK=301	; REQUEST FOR STATUS ACKNOWLEDGEMENT

RESPONSE TO 301 IS A FIVE CHARACTER STRING, WITH THE FOLLOWING FORMAT:

177,<CURRENT_PAGE>,<STATUS_BYTE>,0,0  (THE LATTER TWO BYTES ARE UNUSED)

CURRENT PAGE IS IN RANGE OF 0-77
CURRENT PAGE ID IS TRANSMITTED TO THE GOULD PROGRAM IN THE PROCESS OF
BEGINNING EACH PAGE OR ENDING THE FILE (IN MACRO COMMANDS)

INTERPRETATION OF STATUS BYTE

FAULT CONDITIONS:

%GSNRD=1	; PRINTER NOT READY (INTERLOCK TRIPPED)
%GSVAC=20	; VACUUM FAULT
%GSPAP=40	; PAPER LOW
%GSTIM=100	; HIGH SPEED GRAPHIC TIMEOUT (AND POSSIBLY OTHERS)


STATE CONDITIONS:

%GSDON=4	; DMA TRANSFER COMPLETE
%GSBSY=10	; BUSY (PAPER MOVEMENT, SYSTEM BEING RESET)


GOULD COMMAND CODES

100000		; TOP OF FORM (256 RASTERS ON ROLL PAPER)
100001		; GRAPHIC MODE COMMAND
100002		; CUT COMMAND
100003		; ENABLE PRINTER
100004		; DISABLE PRINTER
100005		; LAST LINE FLAG
100006		; INTERRUPT ENABLE
100007		; INTERRUPT DISABLE
100200		; HOME (128 RASTERS ON ROLL PAPER)
100201		; ADVANCE ONE LINE (TO BE AVOIDED)


PSEUDO COMMAND CODES

100300		; START OF REPEAT (NEXT WORD INTERPRETED
		; AS A REPEAT COUNT)
100301		; END OF REPEAT


MACRO COMMAND CODES (THE LOW BYTE CONTAINS PAGE ID)

140000		; SELECT ALPHA MODE, AND CUT
150000		; SELECT LOW SPEED GRAPHICS MODE, AND CUT
160000		; SELECT HIGH SPEED GRAPHICS MODE, AND CUT
170000		; END OF FILE, CUT, PUT OUT TAILSHEET, AND CUT


DMA BUFFER COMMANDS:

	-----------------------------------------------------------------
	|   |   |   |   |   |   |   |   $   |   |   |   |   |   |   |   |
	|   |   |   |   |   |   |   |   $   |   |   |   |   |   |   |   |
	|15 |14 |13 |12 |11 |10 | 9 | 8 $ 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|   |   |   |   |   |   |   |   $   |   |   |   |   |   |   |   |
	|   |   |   |   |   |   |   |   $   |   |   |   |   |   |   |   |
	-----------------------------------------------------------------
	|		BYTE 1		|	     BYTE 0		|
	-----------------------------------------------------------------



				      ALPHA
	-----------------------------------------------------------------
	|   |                           $   |                           |
	|   |                           $   |                           |
1)	| 0 |                           $ 0 |    WORD COUNT OF DATA     |
	|   |                           $   |                           |
	|   |                           $   |                           |
	-----------------------------------------------------------------
				   (ASCII DATA)


				 IMAGE GRAPHICS
	-----------------------------------------------------------------
	|   |                           $   |                           |
	|   |                           $   |                           |
2)	| 0 |WORD COUNT OF WHITE MARGIN $ 0 |    WORD COUNT OF DATA     |
	|   |                           $   |                           |
	|   |                           $   |                           |
	-----------------------------------------------------------------

				      (DATA)
	-----------------------------------------------------------------
	|                                                               |
	|                                                               |
	|                           IMAGE WORD                          |
	|                                                               |
	|                                                               |
	-----------------------------------------------------------------




			    VARIABLE STRIPED GRAPHICS
	-----------------------------------------------------------------
	|   |                       |   $   |                           |
	|   |                       |   $   |                           |
3)	| 0 |                       | 1 $ 1 |    WORD COUNT OF DATA     |
	|   |                       |   $   |                           |
	|   |                       |   $   |                           |
	-----------------------------------------------------------------


	-----------------------------------------------------------------
	|   |                           $ C |                           |
	|   |                           $ O |                           |
	| 1 |WORD COUNT OF BUFFER LESS  $ L |WORD CNT OF (COLOR) MARGIN |
	|   |          MARGIN           $ O |                           |
	|   |                           $ R |                           |
	-----------------------------------------------------------------

				     (DATA)
	-----------------------------------------------------------------
	|                               $ C |                           |
	|                               $ O |                           |
	|          IMAGE BYTE           $ L |BYTE CNT OF (COLOR) STRIPE |
	|                               $ O |                           |
	|                               $ R |                           |
	-----------------------------------------------------------------


				    GLOSSARY

FUNCTION CODE: EIGHT BIT COMMAND TO GOULD PRINTER STATUS REGISTER

WORD COUNT OF DATA: 7 BIT COUNT OF NUMBER OF WORDS CONSTITUTING DATA TO BE
		    INTERPRETED WHICH LIE AFTER MODE WORD

WORD COUNT OF WHITE MARGIN: 7 BIT COUNT IN WORDS OF LEADING WHITE MARGIN
	      BLACK				      BLACK
	     (COLOR)			     <BLACK IF 1, WHITE IF 0>

WORD COUNT OF BUFFER LESS MARGIN: 7 BIT COUNT IN WORDS OF SIZE OF DECODED
			    BUFFER LESS MARGIN

BYTE CNT OF (COLOR) STRIPE: 7 BIT COUNT OF <BLACK IF 1, WHITE IF 0> BYTES


INTERNAL GOULD FORMATS

NORMAL GOULD COMMANDS

00000000XXXXXXXX		; IMMEDIATE COMMAND

00000001XXXXXXXX		; DELAYED COMMAND

0000000001000000		; SIGNAL FOR PAGE LOSSAGE CONVERSION

INTERNAL MACRO COMMANDS

1000000000000000		; JMP COMMAND
XXXXXXXXXXXXXXXX		; ADDRESS

1000000000000001		; POP JMP RETURN


1100000000000000		; REPEAT COMMAND
0XXXXXXXXXXXXXXX		; REPEAT COUNT

1100000000000001		; END OF REPEAT LOOP


101000000XXXXXXX		; CURRENT PAGE COMMAND


11111111XXXXXXXX		; DMA COMMAND (-COUNT)
XXXXXXXXXXXXXXXX		; DMA ADDRESS
XXXXXXXXXXXXXXXX		; COUNT WORDS OF DATA


QUEUE PHILOSOPHY



DATA FROM PDP-10 -> PDP-11 IS TERMED RECEIVED DATA
DATA FROM PDP-11 -> PDP-10 IS TERMED TRANSMITTED DATA

DATA ENTERING PDP-11 IS TERMED INPUT DATA
DATA LEAVING PDP-11 IS TERMED OUTPUT DATA

NOTE:  THE ABOVE NAMING CONVENTION IS VIOLATED WITH RESPECT TO THE
       NAMES OF TTY INTERRUPT HANDLERS, WHICH ARE DERIVED FROM THE
       THE NAMES OF THE BUFFERS ON THE DL-11'S OR ANALOGS WHICH
       THEY SERVICE.  THE DEVICE DL-11 INTERRUPT HANDLERS HEW
       PROPERLY TO ABOVE NAMING CONVENTION.


PATH OF RECEIVED DATA

1) BYTE IS TRANSMITTED BY PDP-10
2) BYTE IS RECEIVED BY DL-11 DEVICE INTERFACE ON PDP-11
3) A DEVICE RECEIVE INTERRUPT ROUTINE (INRD0) PICKS UP THE DATA
   AND DEPOSITS IT INTO THE APPROPRIATE RECEIVE INPUT QUEUE (<RI>)
4) A MAIN PROGRAM SUBROUTINE (MRTYSB) PICKS THE DATA OUT
   OF <RI> AND DEPOSITS IT, AFTER PROCESSING, INTO THE APPROPRIATE
   RECEIVE OUTPUT QUEUE (<RO>) AND SETS THE INTERRUPT ENABLE ON
   THE TTY INTERFACE (E.G. ANOTHER DL-11)
5) A TTY TRANSMIT INTERRUPT SUBROUTINE (INTTSB) PICKS UP THE DATA
   FROM <RO> AND DEPOSITS IT INTO THE TRANSMIT BUFFER OF THE
   TTY INTERFACE
6) THE DATA IS THEN TRANSMITTED TO THE APPROPRIATE TTY


PATH OF TRANSMITTED DATA

1) BYTE IS TRANSMITTED BY TTY
2) BYTE IS RECEIVED BY TTY INTERFACE ON PDP-11 (E.G. A DL-11)
3) A TTY RECEIVE INTERRUPT SUBROUTINE (INRTSB) PLACES THE DATA
   INTO THE APPROPRIATE TRANSMIT INPUT QUEUE (<TI>)
4) A MAIN PROGRAM SUBROUTINE (TTYSB) PICKS THE DATA OUT OF <TI>
   AND DEPOSITS IT, AFTER PROCESSING, INTO THE APPORPRIATE
   TRANSMIT OUTPUT QUEUE (<TO>) AND SETS THE INTERRUPT ENABLE ON
   THE DEVICE INTERFACE ON THE PDP-11 (A DL-11)
5) A DEVICE TRANSMIT INTERRUPT ROUTINE (INTD0) PICKS UP THE DATA
   FROM <TO> AND DEPOSITS IT INTO THE TRANSMIT BUFFER OF THE
   DEVICE INTERFACE
6) THE DATA IS THEN TRANSMITTED TO THE PDP-10


HANDLING RI QUEUE OVERFLOWS FROM THE PDP-10

THIS IS PREVENTED BY USE OF THE INTELLIGENT TERMINAL PROTOCALL,
WHICH REQUIRES THAT THE TTY CHANNEL TRANSMIT A REQUEST FOR DATA
BACK TO THE 10 ON ITS TRANSMIT CHANNEL (VIA THE TO QUEUE) BY
MEANS OF A ^\ ESCAPE SEQUENCE, WHICH UPDATES AN ALLOCATION ON
THE PDP-10.  WHEN THE TTY BUFFER IS HALF EMPTY, A SEQUENCE OF
^\^A <7 BIT COUNT> IS SENT BACK TO THE PDP-10.


HANDLING TI QUEUE OVERFLOWS FROM A TTY

AFTER THE TI QUEUE HAS FILLED, ALL SUCESSIVE CHARACTERS INPUT
WILL CAUSE A ^G TO BE ENTERED IN ITS RO QUEUE. THERE IS ALWAYS
ROOM FOR AT LEAST ONE ^G IN THE RO QUEUE, SINCE THE MAXIMUM
RO QUEUE ALLOCATION IS ALWAYS TWO CHARACTERS SHY OF BEING
FILLED, ONE CHARACTER FOR THE ^G, AND ONE FOR POSSIBLE QUEUE
SYNCHRONIZATION SLIPPAGE.  IF MORE ^G'S ARE CALLED FOR THAN
REMAINING RO BUFFER SPACE, THEY ARE IGNORED.



QUEUE PROTOCALL

1)  UPON ENTERING A ROUTINE OUTPUTTING TO A QUEUE, BLOCKING FLAGS
    ARE CHECKED TO INSURE THAT THEY ARE ALL 0.  ANY BLOCKING FLAGS
    ARE INDICATIVE OF EITHER THE QUEUE IN QUESTION IS FULL, OR
    THAT SOME OTHER ROUTINE IS TRYING TO OUTPUT TO THE SAME QUEUE
    WHEN IT IS CRITICAL THAT THE SEQUENCE OF CHARACTERS IT IS
    OUTPUTING NOT BE DISTURBED.
2)  THE APPROPRIATE TABLE POINTER IS LOADED, INDEXING BY R3 WHICH
    IS THE TTY CHANNEL NUMBER.
3)  THE FINAL POINTER IS LOADED BY INDEXING WITH RESPECT TO THE
    PREVIOUS POINTER WITH A .PTR OFFSET.
    ASSUMPTION IS THAT THERE IF ONE HAS GOTTEN TO THIS POINT, THERE
    IS AT LEAST ONE FREE LOCATION LEFT IN THE QUEUE.
4)  THE DATA IS THEN PUT INTO THE QUEUE VIA A MOV AUTOINCREMENT.
5)  A COMPARE IS MADE TO SEE IF THE BOTTOM OF THE QUEUE HAS BEEN
    REACHED, AND IF IT HAS, THE POINTER IS SET TO THE BEGINNING OF
    THE QUEUE.
6)  A COMPARE IS MADE TO SEE IF THE POINTER HAS LAPPED THE POINTER
    WHICH IS POINTING TO THE NEXT LOCATION WHICH WILL BE PICKED OFF
    THE QUEUE, AND IF IT HAS, THEN THE QUEUE IS BLOCKED, THE .PTR
    POINTER IS SAVED, AND AN EXIT IS EFFECTED.  THE QUEUE WILL
    BECOME UNBLOCKED ONLY WHEN THE ROUTINE WHICH UTILIZES THE PICKOFF
    POINTER (OFFSET OF .LIM) SUCCEEDS IN ADVANCING ONE POSITION IN
    THE QUEUE.

1)  UPON ENTERING A ROUTINE INPUTING FROM A QUEUE, BLOCKING FLAGS
    ARE CHECKED TO INSURE THAT THEY ARE ALL 0.  ANY BLOCKING FLAGS
    ARE INDICATIVE OF EITHER THE QUEUE IN QUESTION IS BLOCKED, OR
    IF THE ROUTINE ALSO OUTPUTS TO A QUEUE, SOME OTHER ROUTINE IS
    TRYING TO OUTPUT TO THAT QUEUE WITHOUT DISTURBANCE.
2)  THE APPOPRIATE TABLE POINTER IS LOADED, INDEXED BY R3 WHICH IS
    THE TTY CHANNEL NUMBER.
3)  THE FINAL POINTER IS LOADED BY INDEXING WITH RESPECT TO THE
    PREVIOUS POINTER WITH A .LIM OFFSET.
    ASSUMPTION IS MADE THAT IF ONE HAS GOTTEN TO THIS POINT, THERE
    IS SOME DATA AVAILABLE IN THE QUEUE.
4)  THE DATA IS THEN PICKED OFF THE QUEUE VIA A MOV AUTOINCREMENT.
5)  A COMPARE IS MADE TO SEE IF THE BOTTOM OF THE QUEUE HAS BEEN
    REACHED, AND IF IT HAS, THE POINTER IS SET TO THE BEGINNING OF
    THE QUEUE.
6)  A COMPARE IS MADE TO SEE IF THE POINTER HAS CAUGHT UP WITH THE
    POINTER WHICH IS POINTING TO THE NEXT LOCATION WHICH WILL BE
    DEPOSITED IN THE QUEUE, AND IF IT HAS, THE FLAG TO THE INQUIRY
    LOOP IS PATCHED.

NOTE:  THIS STEP IS DONE WITH INTERRUPTS
    MASKED, SO THAT VALIDITY OF POINTERS IS NOT COMPROMISED BY
    INTERRUPT ROUTINES, WHICH WOULD SIGNAL DATA RECEPTION THROUGH
    THE FLAG TO THE INQUIRY LOOP.  THIS FLAG WOULD HAVE BEEN SET
    BY THE INTERRUPT ROUTINE, THEN SUBSEQUENTLY CLEARED BY THE MAIN
    PROGRAM ROUTINE, COMPROMISING THE VALIDITY OF THE INQUIRY LOOP
    SIGNALING MECHANISM.

NOTE:  AT THIS TIME, NO REASON IS EXTANT FOR BLOCKING AN INPUT
    QUEUE.  OUTPUT QUEUES AND MAIN LEVEL ROUTINES CAN BE
    PURPOSEFULLY BE BLOCKED.


INQUIRY LOOP STRUCTURE

THE INQUIRY LOOP IS A SET OF LINKED BRANCH INSTUCTIONS, IN BETWEEN WHICH
ARE MAIN PROGRAM ROUTINES WHICH MANIPULATE THE VARIOUS QUEUES. AT THE
END OF THE LOOP IS A WAIT INSTRUCTION, FOLLOWING BY A JUMP TO THE
BEGINNING OF THE QUEUE. WHEN AN INTERRUPT ROUTINE HAS TRANSFERRED DATA
IN OR OUT OF A QUEUE, IT ZEROS THE LOW BYTE OF THE BRANCH INSTRUCTION
IMMEDIATLY PRECEEDING THE CORRESPONDING MAIN PROGRAM HANDLER, TURNING IT
A NO-OP AND ALSO MOVES NO-OP INTO THE WAIT INSTRUCTION. THIS RESULTS IN
THE BRANCH BEING TURNED INTO AN EFFECTIVE NO-OP INSTRUCTION. AFTER AN
INTERRUPT HAS OCCURRED, THE INQUIRY LOOP ADVANCES OUT OF THE WAIT,
JMPS TO THE TOP OF THE LOOP, AND BEGINS BRANCHING UNTIL IT FINDS A
ROUTINE WITH A CLOBBERED BRANCH PRECEEDING IT.  AFTER SERVICING A
SINGLE CHARACTER, THE MAIN PROGRAM ROUTINE RESTORES THE WAIT
INSTRUCTION, AND JMPS TO THE TOP OF THE LOOP.  IF THE QUEUE WHICH FED
THE MAIN PROGRAM ROUTINE IS EMPTY, THE BRANCH INSTRUCTION IS REPAIRED.
BY RETURNING TO THE TOP OF THE QUEUE INSTEAD OF SIMPLY CONTINUING AFTER
SERVICING THE PREVIOUS ROUTINE, A PRIORITY IS ESTABLISHED, THOSE
ROUTINES AT THE TOP OF THE LOOP RECEIVE PREFERENTIAL TREATMENT.  ONLY
IF A PASS IS MADE THROUGH THE LOOP WHICH NO FLAGS OUTSTANDING WILL
THE MAIN PROGRAM REST AT THE WAIT INSTRUCTION AT THE BOTTOM OF THE LOOP.
IF A ROUTINE HAS PENDING CHARACTERS, OR HAS BEEN BLOCKED, OR ITS OUTPUT
BUFFER HAS BEEN BLOCKED, THEN IT WILL LEAVE ITS BRANCH AS A NO-OP, SO
THAT THE ROUTINE IS ALWAYS IN LINE FOR SERVICE UNTIL ITS INPUT QUEUE
IS EMPTIED.  HOWEVER, IF A ROUTINE IS BLOCKED FOR SOME REASON, INSTEAD
OF EXITING BY JUMPING TO THE TOP OF THE LOOP, IT SIMPLY CONTINUES.  IF
SO MUCH AS A SINGLE CHARACTER HAS BEEN PROCESSED, HOWEVER, IT REPAIRS
THE NO-OP'ED WAIT INSTRUCTION, UNDER THE ASSUMPTION THAT IT MIGHT BE
THE ONLY ROUTINE THAT CLOBBERED IT, AND IT IS ITS RESPONSIBILITY.
THE PURPOSE OF HACKING THE WAIT INSTEAD OF SIMPLY LOOPING IS TO ALLOW
THE BUS TO BE FREE WHENEVER THE SYSTEM IS QUIESCENT, ALLOWING DMA
TRANSFERS TO STEAL ALL THE CYCLES UNTIL SUCH TIME THAT AN INTERRUPT
TRANSFERS SOME DATA INTO OR OUT OF SOME QUEUE.  INTERRUPTS WHICH ARE
NOT PERTENANT TO QUEUE PROCESSING, SUCH AS THE LINE CLOCK, SIMPLY CAUSE
A PASS THROUGH THE LOOP AND BACK INTO THE WAIT INSTRUCTION AGAIN.


GOULD OUTPUT QUEUE

THE GOULD OUTPUT QUEUE, WHICH IS FED BY ITS TTY'S <RI> QUEUE, HAS SOME
SLIGHT DIFFERENCES FROM THE NORMAL TTY OUTPUT QUEUE.  GOULD COMMANDS,
ESPECIALLY THOSE INVOLVED WITH LENGTHY (410 BYTE) DMA LISTS, HAVE A
FINITE "WIDTH".  SINCE THE DMA LISTS CANNOT BE WRAPPED AROUND THE END
OF THE QUEUE, BUT MUST BE COMPOSED OF CONTIGUOUS SEQUENTIAL ELEMENTS,
TWO .PTR POINTERS AND TWO .LIM POINTERS ARE KEPT, ONE OF EACH PAIR
A "TEMPORARY POINTER", AND THE OTHER A "REFERENCE POINTER".  IN THE
CASE OF THE GOULD, THEY ARE TERMED GTPTR AND GTLIM (TEMPS), AND
GLPTR AND GLLIM (REFERS).  THE TEMPORARY POINTERS ARE LOADED INTO
REGISTERS, AND INDICATE WHERE A PROCESS IS ACTUALLY GRABBING OR DUMPING
STUFF.  THE REFERENCE POINTERS ARE LOADED FROM THE TEMPORARY POINTERS,
ONLY AFTER A COMMAND HAS COMPLETED EXECUTION (.LIM) OR HAVING BEEN
QUEUED (.PTR).  THIS INSURES THAT WHEN A COMMAND IS INITIATED, ALL
COMPONENTS WILL BE PRESENT.  THIS PHILOSOPHY RESULTS IN A SIDE AFFECT:
IF A DMA LIST IS LOADED INTO THE QUEUE NEAR THE BOTTOM, ITS STRUCTURE
FORCES THE QUEUE TO BE EXTENDED.  THERE ARE TWO POSSIBLE SOLUTIONS, ONE
BEING TO LOOK AHEAD AND SEE IF THERE IS ENOUGH SPACE, THE SECOND IS TO
HAVE A FLOATING END OF QUEUE LIMIT, WHICH VARIES BETWEEN BOUNDS
ESTABLISHED FOR THE MAXIMUM POSSIBLE SINGLE COMMAND.  THE FIRST RQUIRES
THAT THE COMMAND BE SEMI-DECODED TO ESTABLISH ITS LENGTH, AND THEN
COMPARISON AGAINST THE QUEUE LIMIT.  THEN IF IT CANNOT FIT, THE
ROUTINE MUST BACK OUT OF THE COMMAND AND RESTART IT AT THE TOP OF
THE QUEUE, AND SOMEHOW INFORM WHOEVER EXECUTES THE COMMANDS, TO NOT
EXECUTE PAST THE LAST COMPLETE COMMAND, POSSIBLY BY MARKING IT WITH
A SPECIAL COMMAND CODE.  THE LATTER MECHANISM, WHICH WAS IMPLIMENTED,
ONLY CHECKS FOR END OF QUEUE AFTER A COMMAND HAS BEEN INPUT, OR
EXECUTED, WITH A GREATER THAN OR EQUALS, INSTEAD OF AN EQUALS
BRANCH AFTER A COMPARE.  THIS SUFFERS FROM THE FACT, THAT, ON THE
AVERAGE, A PORTION OF THE QUEUE IS CONSISTENTLY NOT USED, EVEN WHEN
A NUMBER OF SMALL LENGTH COMMANDS CAN BE INSERTED INTO THE FLOATING
AREA AT THE END OF THE QUEUE WITH NO HARM, BUT INSTEAD FAULT OUT
AFTER THE FIRST SMALL COMMAND HAS PASSED THE "SOFT" QUEUE LIMIT.
HOWEVER, IF THE QUEUE IS LARGE ENOUGH, THIS WASTEFULNESS CAN BE
IGNORED.


FURTHER ASPECTS OF THE GOULD PROGRAM

THE QUEUE WHICH THE GOULD INTERRUPT HANDLER TAKES AS INPUT HAS SEVERAL
FLOW OF CONTROL COMMANDS, OR GOULD QUEUE COMMANDS.  THE FIRST OF THESE
ALLOW THE .LIM POINTER TO MAKE ONE PUSH OF CURRENT POSITION AND TO
PROCEED TAKING COMMANDS FROM A LIST ELSEWHERE IN CORE.  THIS ABILITY
IS ONLY NESTED TO ONE LEVEL.  THE SECOND QUEUE COMMAND ALLOWS A
DELIMITED SET OF COMMANDS TO BE EXECUTED REPEATEDLY FOR A GIVEN NUMBER
OF TIMES.  AGAIN, THIS ABILITY IS ONLY NESTED TO ONE LEVEL.  THE MACRO
COMPLETELY INDEPENDANT OF EACH OTHER, AS LONG AS A JUMP RETURN DOES NOT
LEAVE A REPEAT COMMAND HANGING.  THERE ARE SPECIAL COMMAND CODES TO
ALLOW A PROGRAM TRANSMITTING TO THE GOULD TO DESIGNATE THE INSERTION
OF A REPEAT IN THE BODY OF A SET OF COMMANDS.  HOWEVER, THERS IS NO
SUCH ABILITY WITH THE JUMP COMMAND, WHICH IS PRIMARILY USED FOR
EXECUTION OF GOULD MACRO COMMANDS AND SMEAR PROTECT PAGE FEEDS.



ASPECTS OF CHARACTER PROCESSING

IN SEVERAL INSTANCES, THE RECEPTION OF ONE DATUM IN AN INPUT QUEUE CAN
RESULT IN A SLEW OF DATA BEING DEPOSITED IN THE OUTPUT QUEUE.  IF THE
OUTPUT QUEUE BECOMES FULL BEFORE SUCH STREAMS RESULTING FROM A DATUM
HAVE BEEN WHOLLY DEPOSITED, EXIT AND SUBSEQUENT REENTRY TO THE ROUTINE
PRESENT PROBLEMS, ROUTINE IS CAUGHT IN THE "MIDDLE" OF PROCESSING DATA
FROM THE INPUT QUEUE, AND CAN NEITHER ADVANCE, NOR JUST RETRY TO PROCESS
THE DATA, THE FORMER BECAUSE IT HAS NOT FINISHED WITH THE DATA, THE LATER
BECAUSE IT MIGHT HAVE MADE SOME PROGRESS ALREADY, AND WOULD BE
DUPLICATING SOME EFFORT (AND CHARACTERS).  AGAIN TWO SOLUTIONS, ONE IS
TO LEAVE A POINTER AT A PROPITIOUS POINT IN THE ROUTINE WHERE A JUMP
INDIRECT IS MADE.  IT MOST CASES IT WILL FALL THROUGH, BUT IN THE
BINDING CASE OF ABOVE IT WILL VAULT DIRECTLY TO WHERE THE FACTORS
WHICH CAUSED IT TO FAULT OUT BEFORE ARE TESTED.  THIS METHOD MAKES
THE CODE SOMEWHAT UNESTHETICALLY "GOTO-ISH".  THE SECOND METHOD IS TO
ERASE WHAT HAS BEEN DONE SO FAR BY CAREFUL MANIPULATION OF POINTERS
AND TO RETRY FROM THE START.  THIS IS EFFICIENT IF THE STRINGS BEING
OUTPUT ARE SMALL IN LENGTH, AND THE QUEUE IS NOT EXPECTED TO BE BOUND
VERY OFTEN.  HOWEVER, IF THE STRING IS LONG, AND THE QUEUE IS BEING
FILLED BY COMPETITIVE ROUTINES, THE STRING MIGHT BE DEALYED FOR A
SIGNIFICANT LENGTH OF TIME (ESPECIALLY IF IT EXCEEDS THE LENGTH OF THE
OUTPUT QUEUE!).  THE FORMER METHOD HAS BEEN SELECTED, DUE TO ITS
GREATER GENERALITY AND DEPENDABILITY IN TIMES OF CRUNCH.  IT ALSO HAS
THE ADVANTAGE OF ALLOWING SPECIAL HACK ROUTINES TO BE CALLED EASILY
DURING ANOMOLOUS CONDITIONS SPANNING SUCCESSIVE EXECUTIONS OF THE
ROUTINE.

DEVICE RECEIVE INTERRUPT HANDLER

MESSAGES COMING TO THIS HANDLER ARE VECTOR TO APPROPRIATE <RI> QUEUES.
THE FORMAT OF THE MESSAGE IS AS FOLLOWS:

200+<TTY_CHANNEL_NUMBER>,<COUNT>,<COUNT NUMBER OF BYTES>

TTY CHANNEL NUMBER IS CURRENTLY IN THE RANGE OF 0-3, BUT IN THE FUTURE
WILL BE EXPANDED TO 0-5 TO ACCOMADATE THE ANN ARBOR TERMINALS



DEVICE TRANSMIT INTERRUPT HANDLER

MESSAGES ARE INSERTED TO A COMMON <TO> QUEUE WHICH IS INPUT TO THIS
HANDLER.  MESSAGES ARE OF THE FORMAT:

200+<TTY_CHANNEL_NUMBER>,<DATA ... DATA>

THE 200 BIT SIGNIFIES TTY CHANNEL SELECTION, AND THEREFORE 200 CODES
CANNOT BE TRANSMITTED AS DATA DIRECTLY, BUT MUST USE THE INTELLIGENT
TERMINAL PROTOCALL.  ALTHOUGH THE DATA STREAM CAN BE ANY LENGTH, THE
CONVENTION OF ONLY INPUTING SINGLE WORD MESSAGES INTO THE QUEUE,
CONSISTING OF <LINE_SELECT> AND <DATA_BYTE>, HAS BEEN ADOPTED, SO
THAT DATA STREAMS FROM VARIOUS ROUTINES (OR TTY CHANNELS) CAN BE
CONVENIENTLY INTERLEAVED.


KEYBOARD MULTIPLEXOR INTERRUPT HANDLER

A FULL WORD OF DATA IS PICKED OUT OF THE MULTIPLEXOR DATA BUFFER.
THE TOP 4 BITS ACT AS A KEYBOARD ID, AND THE REMAINING 12 ARE DATA
FROM THE KEYBOARD.  THE TOP FIVE BITS OF THESE 12 BIT CODES REPRESENT,
FROM 4000 TO 200: TOP, SHIFTLOCK, SHIFT, META, AND CONTROL.  IF ANY OF
THESE FIVE BITS ARE PRESENT, A 3 CHARACTER ^\ ESCAPE SEQUENCE FOR
THEIR REPRESENTATION UNDER THE INTELLIGENT TERMINAL PROTOCALL MUST
BE CONSTRUCTED.  A TABLE OF ENTRIES VECTORS A PARTICULAR KEYBOARDS
DATA TO GO TO THE <TI> QUEUE OF A PARTICULAR TTY CHANNEL



CHARACTER PROCESSING

ON RECEIVE, CHARACTERS ARE OUTPUT AS THEY OCCUR ON RECEPTION, AS BYTES,
WITH THE EXCEPTION OF CODE 214, OUTPUT RESET.  THIS IS A COMMAND WHICH
INSTRUCTS THE PDP-11 TO EMPTY ITS <TI> QUEUE ON THAT CHANNEL, AND,
IF THE TERMINAL IN THAT CHANNEL ITSELF HANDLES THE INTELLIGENT
TERMINAL PROTOCALL, THE CODE IS PASSED TO IT AS WELL.  OTHERWISE,
IT IS NOT TRANSMITTED, THE CHANNEL IS REINITIALIZED, AND A ^\ ^P
ESCAPE SEQUENCE IS CONSTRUCTED AND OUTPUT ON THAT CHANNEL.
IF THE TTY IS INTELLIGENT, NO SUCH SEQUENCE IS CONSTRUCTED BY THE
PDP-11, RATHER IT REINTIALIZES THE CHANNEL AND THROWS AWAY INPUT
EXCEPT FOR ALLOCATION ESCAPE SEQUENCES, UNTIL A ^\ ^P ESCAPE
SEQUENCE, WHICH IS PASSED ON. AT THIS POINT NORMAL OPERATION RESUMES.

NOTE:  CHANNEL INITIALIZATION INCLUDES ZEROING THE ALLOCATION, THEN
       INCREMENTING IT.

ON TRANSMIT, CHARACTERS ARE PROCESSED FROM FULL WORD COMPONENTS, AND
SPECIAL ACTION IS TAKEN FOR 12 BIT CODES AS DETAILED IN THE
DESCRIPTION OF THE KEYBOARD MULTIPLEXOR.
IF THE TERMINAL IS INTELLIGENT, ^\ ^A ALLOCATION SEQUENCES
ARE HANDLED LOCALLY, AND THE ALLOCATION IS COUNTED DOWN ON THE
RECEIVE SIDE, AND ADDED TO ON THE TRANSMIT SIDE FROM THE ESCAPE
SEQUENCES.  ALL OTHER ^\ ESCAPES ARE PASSED THROUGH UNCHANGED
TO THE PDP-10.
IF THE TERMINAL IS NOT INTELLIGENT, TYPED ^\'S ARE DOUBLED IN ACCORDANCE
WITH THE INTELLIGENT TERMINAL PROTOCALL, WHICH IS SET FOR ALL TERMINAL
CHANNELS COMING THROUGH THE PDP-11.
IF THE TOP BIT IN A <TI> COMPONENT WORD HAS BEEN SET, THEN INPUT HAS
DEFINITELY COME FROM THE KEYBOARD MULTIPLEXOR.  THIS BIT, WHICH IS SET
AT INTERRUPT LEVEL, IS NECESSARY TO DISTINGUISH FROM A ^\ COMING FROM
AN INTELLIGENT TERMINAL AND A POSSIBLE KEYBOARD FROM THE MULTIPLEXOR
WHICH MIGHT BE SERVICING IT.  IN THE FORMER CASE, THE ^\ WOULD NEED TO
BE DOUBLED, IN THE LATTER, IT WOULD NOT.

TCTYP PHILOS


THREE BITS STATUS PER CHANNEL

0)   INTELLIGENT -> ALLOCATION, INTERNAL OUTPUT RESET HACKERY

RECEIVE NEVER GETS EIGHT BIT CODES, RATHER RUBOUT QUOTING, HANDLED AT MP LEVEL

1)   ERASEABLE  -> WHETHER OR NOT TO NOP ERASING VIRTUAL EIGHT BIT CODES

OUTPUT RESET CLEARS <RO> BUFFER ON CHANNEL

:TCTYP  SOFTWARE %TPCBS %TPORS

EIGHT BIT CODES WILL CAUSE CURSOR POSITIONING AND/OR ERASING

HORIZONTAL POSITION NOT IMPORTANT, SINCE OUTPUT RESET SENDS NL AFTERWARDS

2)   POSITIONING -> WHETHER OR NOT TO NOP POSITIONING VIRTUAL EIGHT BIT CODES

IMLAC == 7
TEKTRONIX == 2
GOULD == 0
DIGIVUE == 6
ANN ARBOR == 6
ANN ARBOR == 6

R0 CONTAINS EIGHT BIT CODE

MOV RTRAN(R3),R1
BIC #177760,R0
ADD R0,R1
JSR PC,@(R1)
      (IN REGISTER)

