;;;	Graphics spooler for a matrix printer (Gould 5200)

(Comment Declarations - Macros - Initialization - Main loop)

(declare (special to-be-processed q-file page-index mail-file sender at page-word
		  ascii ards xgp tek software-lpt image gts-list locked-pages
		  gould-connection tv clock-times-waited)
	 (fixnum i n ch)
	 (notype (pluralizer? fixnum))
	 (array* (fixnum (charwidth 200)))
	 (*lexpr user-error)
	 (*expr set-uname))

(INCLUDE |jlk;lspmac >|)

(declare (eval (read)))
(setsyntax '/& 'macro '(lambda () (+ 1_17 (read)))) ; printer commands

(defun file-length macro (form)
       `(caddar (directory (list (truename ,(cadr form))) '(words))))

(sstatus feature gould-spooler)
(sstatus feature noldmsg)

(setq gc-overflow '(lambda (x) nil))

;;; Initialize variables

(SETQ TO-BE-PROCESSED NIL ITEM NIL gould-connection nil
      IN-FILE NIL MAIL-FILE NIL SCAN-FILE NIL Q-FILE NIL clock-times-waited 0
      DEFAULT-FLAGS '((??) (ARDS-COMMANDS) (LPT-COMMANDS) (BACKGROUND . 0)
		      (COPIES . 1) (CUT-PAPER . T) (DELETE)
		      (FILE-TYPE . XGP) (IMAGE-COMMANDS)
		      (INDIRECT) (OUTPUT-TYPE . GOULD)
		      (PAPER-HEIGHT . 850.) (PAPER-WIDTH . 1100.)
		      (PRIORITY . 0) (RUN-ENCODE . T) (SENDER . BUG-GTPL)
		      (ROTATE . 0) (SKIP . 0) (SOFTWARE-TTY-COMMANDS)
		      (SPOOL . T) (STATUS) (TAIL-SHEET) (TEK-COMMANDS) (WRAP-AROUND)
		      (VERIFY) (XGP-COMMANDS . ((LIST))))
      GTS-LIST '(((DSK -PICS-) GIRL PIC)
		 ((DSK -PICS-) WUMPUS PIC)
		 ((DSK -PICS-) DRAGON PIC)
		 ((DSK -PICS-) WHEEL PIC)))

(prog2 (NCONC GTS-LIST GTS-LIST) ()) ; Avoid printing circular list.

;;;	Spooler functions

; The func property of the output type is the output function.
(MAPC '(LAMBDA (A) (PUTPROP (CAR A) (CADR A) 'FUNC))
      '((LPT	LPT-PRINT)
	(ARDS	ARDS-PRINT)
	(DPLT	DPLT-PRINT)
	(XGP	XGP-PRINT)
	(TEK	TEK-PRINT)
	(IMAGE	IMAGE-PRINT)
;	(SOFTWARE-TTY 	TTY-PRINT)
	))

;;;	Special printer codes

(DECLARE (EVAL (READ)))
(SETQ  WAIT-TIME 10. MAIL-TIME 5.
      %cscls 0 %csrfs 3 %csopn 4 %cslos 5 %csinc 6 gould-host 500 gould-timeout 60.
      gould-repair-time 30.)

;	Autoload properties for external files

(MAPC '(LAMBDA (X)
	(COND ((NOT (GETL (CAR X) '(SUBR EXPR)))
	       (PUTPROP (CAR X) (CONS '(DSK GLPT) (CDR X)) 'AUTOLOAD))))

      '((ARDS-PRINT . (ARDS FASL))
	(DPLT-PRINT . (DPLT FASL))
	(LPT-PRINT  . (NLPT FASL))
	(TEK-PRINT  . (ARDS FASL))
	(XGP-PRINT  . (XGP FASL))))

(Comment Spooler Initialization Dumping and Toplevel)
; USE THIS FUNCTION TO DUMP OUT A NEW GLPT;TS SPOOLR

(DEFUN INIT-DUMP NIL
       (SETQ ^W T MSGFILES NIL)
       (IF (null (get 'directory 'Lsubr)) (FASLOAD (DSK COMMON) ALLFIL FASL))
       (FASLOAD (DSK COMMON) SORT FASL)
       (SSTATUS TOPLEVEL '(SPOOLER))
       (SSTATUS FLUSH T)
       (SUSPEND '|:KILL | '((DSK GLPT) TS SPOOLR))
       (COND ((EQ 'GSPOOL (STATUS JNAME)) (JCL-SPOOL)))
       (COND ((disowned?) (SET-UNAME))
	     (t (VALRET '|17|) (SLEEP 1) (SET-UNAME))))

; THE TOPLEVEL SPOOLER.  ALTERNATE CHECKING FOR MAIL WITH SPOOLING FILES.
; IF NOTHING HAS HAPPENED IN MAX-SLEEP-PERIODS OF SLEEPING, THEN DIE OF BOREDOM.

(DEFUN SPOOLER NIL
       (DO ((IBASE 10.) (BASE 10.) (*NOPOINT T)) (NIL)
	   (COND ((PROBEF '|DSK:.GLPT.;-GLPT- QUEUE|)
		  (SETQ Q-FILE (OPEN '|DSK:.GLPT.;-GLPT- QUEUE| '(DSK IN BLOCK ASCII))
			TO-BE-PROCESSED (READ Q-FILE))
		  (CLOSE Q-FILE)))
	    (do nil ((not (probef '|dsk:.glpt.;.glpt. >|)))
		(deletef '|dsk:.glpt.;.glpt. >|))
	   (ALARMCLOCK 'TIME 1)
	   (setq locked-pages nil gould-connection nil)
	   (CATCH
	    (DO NIL (NIL)
		(setq clock-times-waited 0)
		(wait-for-non-null 'to-be-processed)
		(if (not locked-pages) (progn (setq locked-pages t) (lock-pages)))
		(if (null gould-connection) (gould-connect))
		(process-file)
		(record-q)
		(if (null to-be-processed)
		    (progn (if locked-pages (unlock-pages))
			   (gould-disconnect))))
	    TOP)
	   (RECORD-Q)))

(Comment Spooler JCL and Mail Processors)

(defun jcl-spool ()
       (cond ((null (status jcl)) ; make this unnecessary someday?
	      (valret '|: Must use JCL with GSPOOL/î:kill/î|)))
       (valret '|:proced /î|)
       (setq mail-file (open '|dsk:.glpt.;.gspl. output| '(dsk ascii out))
	     sender (status userid))
       (princ (maknam (status jcl)) mail-file)
       (close mail-file)
       (setq mail-file (open '|dsk:.glpt.;.gspl. output| '(dsk ascii in)))
       (process-requests mail-file)
       (close mail-file)
       (deletef mail-file)
       (lock-pages)
       (gould-connect)
       (do nil ((null to-be-processed)) (process-file))
       (unlock-pages)
       (gould-disconnect)
       (valret '|:kill |))

; process a mail file.  this may also be invoked by the cli interrupt handler.
; queue up files to be processed by the spooler.

; probef the file to see if it exists
; the structure of queued items is
; (<file-name-list>  <output spec> <file-type> <priority> <flag association list> )

(defun process-mail ()
       (do ((ch (tyi mail-file) (tyi mail-file)) (l nil (cons ch l)))
	   ((= 100 ch)
	    (setq sender (implode (nreverse l))
		  at (implode (list (tyi mail-file) (tyi mail-file))))))
       (tyipeek 15 mail-file) (tyipeek 137 mail-file) (tyi mail-file)
       (process-requests mail-file)
       (record-q)
       (close mail-file)
       (errset (deletef mail-file) nil)
       (car to-be-processed))

(Comment Spooler Request reader and parser)
; Spooling requests are of the following form:
; <outfile>_<infile> <flags>, <outfile>_<infile> <flags>,...
; <flags> are of the form /A/-S/X[25FR]or (A -S X[25FR]).  Global
; flags apply to all subsequent specs (left to right) until they are
; respecified.  Local flags only apply to the file specs immediately
; preceeding them.  <outfile>_  is optional, as are flags.  If only,
; a flags spec is given, no file is queued, but the flags are set.
; This feature can be used to specify global flags, as in
; /A/O[X], file1,file2,...
; The output from Read-file-specs is a list of the form:
; ( ( <input namelist> <output namelist> .  <flag a-list> ) ...)

; read-requests conses up a list of tokens (lexical analysis done by the
; LISP reader).  Parse-requests structures the tokens into
; namelists for input and output file specs, and an assoc list of the command
; flags.  Merge-defaults takes the list of parsed requests and does
; input file default merging and flag merging.  Queue-requests puts
; each request item on the queue after checking that the file exists, etc.

(declare (special default-flags unspool file-spec-tab))

(defun process-requests (file)
   (catch (queue-requests (merge-defaults (parse-requests (read-requests file))))
	  Mailer))

; lexical scan of file specs using LISP's reader
(defun read-requests (file)
   (do ((l nil (cons (read file 'e-o-f-r) l))
	(readtable file-spec-tab)
	(ibase 10.))
       ((and l (or (eq 'e-o-f-r (car l)) (eq (ascii 15) (car l))))
	(nreverse (cdr l)))))

; set up syntax read table for lexical scanning
(setq file-spec-tab (array nil readtable))

((lambda(readtable) 
	(setsyntax 15 601540 15)
	(setsyntax '/; 600500 '/;)
	(setsyntax '/: 600500 '/:)
	(setsyntax '/, 600500 '/,)
	(setsyntax '/ 402500 nil)
	(setsyntax '/. 1 '/.)
	(setsyntax '/" 600500 '/")
	(setsyntax '/| 600500 '/|)
	(setsyntax '/[ 600500 '/[)
	(setsyntax '/] 600500 '/])
	(setsyntax '/( 600500 '/()
	(setsyntax '/) 600500 '/))
	(setsyntax '/' 600500 '/')
	(setsyntax '// 600500 '//)
	(setsyntax '/_ 600500 '/_)
	(setsyntax '/ 600500 '/)
	(setsyntax '/ 600500 '/)
	(sstatus ttyread nil))
	file-spec-tab)

(defun parse-requests (token-list)
   (do ((l (nconc token-list '(/,)) (cdr l))
	(specs) (flags) (output) (all-specs))
       ((null l)
	(nreverse all-specs))
       (cond ((eq '/, (car l))				; finished spec
	      (setq all-specs
		    (cons `(,(parse-file-specs specs)
			    ,(cond (output (parse-file-specs output)))
			    . ,(parse-command-flags flags))
			  all-specs)
		    output nil specs nil flags nil))
	     ((eq '/_ (car l))				; output spec
	      (setq output (cond (specs) (t '(* *)))
		    specs nil)
	      (cond ((null output)
		     (setq output '(*)))))
	     ((memq (car l) '(// /())			; flags
	      (do ((ll (cdr l) (cdr ll)))
		  ((or (null ll) (eq '/, (car ll)))
		   (setq l (cons nil ll)))
		  (cond ((memq (car ll) '(// /( /) )))
			(t (setq flags (cons (car ll) flags))))))
	     (t (setq specs (cons (car l) specs))))))	; OTHERWISE, SPEC

(defun parse-file-specs (token-list)
       (cond (token-list ; specs are reversed at this point
	      (do ((l token-list (cdr l))
		   (dev) (dir) (fnlist))
		  ((null l)
		   (cond ((null (or dev dir fnlist)) nil)
			 (t (setq dev (cond (dev (list dev (or dir sender)))
					    (dir (list dir))))
			    (cond (dev (cons dev fnlist))
				  (t fnlist)))))
		  (cond  ((eq '/: (car l))
			  (setq dev (car (setq l (cdr l)))))
			 ((eq '/; (car l))
			  (setq dir (car (setq l (cdr l)))))
			 (t (setq fnlist (cons (car l) fnlist))))))))

; flag formats:  <number or + or ->!<letter>![ <option1> | <option2> |...]
; returns a list of dotted pairs: flag . args
; flags can only have a single number or +/- preceeding them.

(defun parse-command-flags (token-list)
       (do ((l token-list (cdr l))
	    (rlist) (options) (flag))
	   ((null l) rlist)
	   (setq l (token-check l))
	   (cond ((numberp (car l))
		  (setq rlist (cons (cons (car l) options)
				    rlist)
			options nil))
		 ((eq '/[ (car l))
		  (user-error '|Option Error:  "[" encountered before flag.|))
		 ((eq '/] (car l))
		  (do ((ll (cdr l) (cdr ll))
		       (option-item))
		      ((or (null ll) (eq '/[ (car ll)))
		       (cond (option-item
			      (setq options (cons option-item options))))
		       (setq l ll))
		      (cond ((eq '/| (car ll))
			     (setq options (cons option-item options)
				   option-item nil))
			    (t (setq option-item (cons (car ll) option-item))))))
		 (t (setq flag (car l))
		    (cond ((cdr l)
			   (setq l (token-check l))
			   (cond ((numberp (cadr l))
				  (setq l (cdr l)
					options (cons (car l) options)))
				 ((memq (cadr l) '(+ -))
				  (setq l (cdr l)
					options (cons (cdr (assq (car l)
								 '((- . nil)
								   (+ . t))))
						      options))))))
		    
		    (setq rlist (cons (cons flag options) rlist)
			  options nil flag nil)))))

(defun token-check (l)
   (cond ((not (= 1 (flatc (car l))))
	  (nconc
	   (nreverse
	    (mapcar '(lambda(x) (readlist (list x)))
		    (explodec (car l))))
	   (cdr l)))
	 (t l)))

(defun merge-defaults (requests-list)
   (do ((rlist requests-list (cdr rlist))
	(flags default-flags)
	(def-devdir (list 'dsk sender) (list 'dsk sender))
	(def-fn1 'GOULD)
	(file) (input) (output) (unspool nil nil) (qlist))
       ((null rlist) (nreverse qlist))
       (setq flags (merge-flags (cons (cons 'sender sender)
				      (decode-flags (cddar rlist)))
				flags)
	     input (caar rlist)
	     output (cadar rlist))		; output default later
       (cond (input				; only for non-nil input file specs
	      (cond ((or (memq '* (cdr input))
			 (and (not (atom (car input)))
			      (cond ((and (cdar input)
					  (eq '****** (cadar input)))
				     (setq def-devdir '(*))
				     (rplaca (cdar input) '*))
				    ((eq '****** (caar input))
				     (setq def-devdir '(*))
				     (rplaca (car input) '*)))))
		     (do ((l (mapcar 'car (nreverse
					   (directory (list (mergef input
								    (list def-devdir
								    def-fn1)))
						     nil)))
			     (cdr l))
			  (flags* (merge-flags '((spool)) flags)))
			 ((null l) (rplaca (cdddar qlist) flags))
			 (setq file (car l)
			       qlist (cons (list file
						 output
						 (merge-type file flags*)
						 flags*)
					   qlist))))
		    (t (setq file
			     (errset (mergef input (list def-devdir def-fn1 '>))
				     nil))
		       (cond (file (setq file (car file)))
			     (t (user-error input '|Bad file spec|)
				(throw nil mailer)))
		       (setq qlist (cons (list file
					       output
					       (merge-type file flags)
					       flags)
					 qlist))))
	      (setq def-devdir (car file) def-fn1 (cadr file))))))


(defun merge-flags (fl def-fl)
       (setq fl (sort fl (function (lambda(x y) (alphalessp (car x) (car y))))))
       (do ((l fl (cdr l)) (dl def-fl (cdr dl)) (nfl))
	   ((null l) (append (reverse nfl) dl))
	   (setq nfl
		 (append
		  (cond ((eq (caar l) (caar dl)) (ncons (car l)))
			(t (do ((dl1 dl (cdr dl1)) (nfl1))
			       ((or (null dl1) (eq (caar l) (caar dl1)))
				(setq dl dl1) (cons (car l) nfl1))
			       (setq nfl1 (cons (car dl1) nfl1)))))
		  nfl))))

(defun merge-type (input flags) (or (cdr (assq 'file-type flags)) 'lpt input))

(DEFUN DECODE-FLAGS (FLAG-LIST)
       (DO ((L FLAG-LIST (CDR L)) (FL) (ITEM) (ARGS) (FLAG))
	   ((NULL L) FL)
	   (SETQ FLAG (CAAR L) ARGS (CDAR L)
		 ITEM
		 (COND ((NUMBERP FLAG) (CONS 'SKIP FLAG))
		       ((EQ 'P FLAG) (CONS 'PRIORITY (COND (ARGS (CAR ARGS))(T 0))))
		       ((EQ 'R FLAG) (CONS 'ROTATE (COND (ARGS (CAR ARGS))(T))))
		       ((EQ 'V FLAG) (CONS 'VERIFY (COND (ARGS (CAR ARGS))(T))))
		       ((EQ 'S FLAG) (CONS 'SPOOL (COND (ARGS (CAR ARGS)))))
		       ((EQ 'B FLAG) (CONS 'BACKGROUND (COND (ARGS (CAR ARGS))(T 1))))
		       ((EQ 'K FLAG) (CONS 'DELETE (COND (ARGS (CAR ARGS))(T))))
		       ((EQ 'O FLAG)
			(CONS 'OUTPUT-TYPE
			      (COND ((OR (NULL ARGS) (ATOM (CAR ARGS))) 'GOULD)
				    (T (OR (CDR (ASSQ (CAAR ARGS)
						      '((X . XGP)
							(G . GOULD)
							(B . IMAGE)
							(BIN . IMAGE)
							(I . IMAGE))))
					   (CAAR ARGS))))))
		       ((EQ 'L FLAG)
			(SETQ FL (CONS '(FILE-TYPE . XGP) FL))
			(CONS 'XGP-COMMANDS (CONS '(LIST) ARGS)))
		       ((EQ 'U FLAG) '(UNSPOOL . T))
		       ((EQ '/~ FLAG) (CONS 'CUT-PAPER (COND (ARGS (CAR ARGS)))))
		       ((EQ '* FLAG) (spool-reset))
		       ((EQ 'C FLAG) (CONS 'COPIES (COND (ARGS (CAR ARGS))(T 1))))
		       ((EQ '/$ FLAG) (CONS 'TAIL-SHEET T))
		       ((EQ '/& FLAG) (CONS 'RUN-ENCODE NIL))
		       ((EQ '/! FLAG) (CONS 'WRAP-AROUND
					    (COND (ARGS (CAR ARGS))(T NIL))))
		       ((EQ '/@ FLAG) (CONS 'INDIRECT T))
		       ((EQ 'X FLAG)
			(SETQ FL (CONS '(FILE-TYPE . XGP) FL))
			(CONS 'XGP-COMMANDS ARGS)) 
		       ((EQ 'A FLAG)
			(SETQ FL (CONS '(FILE-TYPE . ARDS) FL))
			(CONS 'ARDS-COMMANDS ARGS)) 
		       ((EQ 'D FLAG)
			(SETQ FL (CONS '(FILE-TYPE . DPLT) FL))
			(CONS 'DPLT-COMMANDS ARGS)) 
		       ((EQ 'T FLAG)
			(SETQ FL (CONS '(FILE-TYPE . TEK) FL))
			(CONS 'TEK-COMMANDS ARGS))
		       ((EQ 'Y FLAG)
			(SETQ FL (CONS '(FILE-TYPE . SOFTWARE-TTY) FL))
			(CONS 'SOFTWARE-TTY-COMMANDS ARGS)) 
		       ((EQ 'H FLAG)
			(SETQ FL (CONS '(FILE-TYPE . LPT) FL))
			(CONS 'LPT-COMMANDS ARGS))
		       ((EQ 'I FLAG)
			(SETQ FL (CONS '(DELETE . T) (CONS '(FILE-TYPE . IMAGE) FL)))
			(CONS 'IMAGE-COMMANDS ARGS)) 
		       (T (CONS '?? FLAG))))
	   (COND (ITEM (SETQ FL (CONS ITEM FL))))))

(Comment Queueing - unqueueing and queue processing functions)

(DECLARE (SPECIAL ITEM))

(defun queue-requests (requests-list)
       (do ((l requests-list (cdr l)))
	   ((null l))
	   (cond ((cdr (assq 'unspool (car (cdddar l))))
		  (unqueue-file (caar l)))
		 (t (queue-file (caar l) (cadar l) (caddar l) (car (cdddar l)))))))

(DEFUN UNQUEUE-FILE (FILE-SPEC)
       (COND ((DO ((L TO-BE-PROCESSED (CDR L))) ((NULL L) T)
		  (COND ((EQUAL FILE-SPEC (CAAR L))
			 (COND ((CDR L) (RPLACA L (CADR L)) (RPLACD L (CDDR L)))
			       (T (RPLACA L NIL) (RPLACD L NIL)))
			 (RETURN NIL))))
	      (COND ((EQUAL FILE-SPEC (CAR ITEM))
		     (CLOSE MAIL-FILE)
		     (ERRSET (DELETEF MAIL-FILE) NIL)
		     (NOINTERRUPT NIL)
		     (THROW NIL TOP)))))
       (RECORD-Q))

(DEFUN QUEUE-FILE (FILE OUTPUT type FLAGS)
       (COND ((NULL (PROBEF FILE)) 
	      (user-error (namestring file) '|--File wasn't there.|))
	     ((AND OUTPUT
		   (NULL (PROBEF (LIST (CAR OUTPUT) '|.FILE.| '|(DIR)|))))
	      (user-error  (namestring file) '|--Specifies a directory that doesn't exist.|))
;	     ((= 0 (file-length (open file '(in)))))
	     (T (SETQ FILE (OPEN FILE)
		      TO-BE-PROCESSED
		      (PRIORITY-ARBITRATE
		               TO-BE-PROCESSED
			       (LIST (TRUENAME FILE)
				     OUTPUT
				     type
				     (OR (CDR (ASSQ 'PRIORITY FLAGS)) 0)
				     FLAGS)))
		(CLOSE FILE))))

(DEFUN PRIORITY-ARBITRATE (LIST ITEM)
       (DO ((L LIST (CDR L)))
	   ((NULL L) (NCONC LIST (NCONS ITEM)))
	   (COND ((> (CADDDR ITEM) (CADDDR (CAR L)))
		  (RPLACD L (CONS (CAR L) (CDR L))) (RPLACA L ITEM) 
		  (RETURN LIST)))))

(DEFUN RECORD-Q NIL
       (COND (TO-BE-PROCESSED
	      (SETQ Q-FILE (OPEN '|PK0:.GLPT.;-GLPT- QUEUE| '(DSK OUT BLOCK ASCII)))
	      (princ '/( q-file)
	      (MAPC '(LAMBDA(X) (prin1 x q-file)(princ '|/
/;----------------------------------------------------------------/
/
| q-file))        TO-BE-PROCESSED)
	      (princ '/) q-file)
	      (TERPRI Q-FILE)
	      (CLOSE Q-FILE))
	     ((PROBEF '|DSK:.GLPT.;-GLPT- QUEUE|)
	      (DELETEF '|DSK:.GLPT.;-GLPT- QUEUE|))))

(DECLARE (SPECIAL BACKGROUND COPIES CUT-PAPER DELETE FILE-TYPE INDIRECT OUTPUT
		  PAPER-HEIGHT PAPER-WIDTH PRIORITY RUN-ENCODE ROTATE SKIP STATUS
		  WRAP-AROUND VERIFY XGP-COMMANDS ARDS-COMMANDS LPT-COMMANDS
		  TEK-COMMANDS SOFTWARE-TTY-COMMANDS IMAGE-COMMANDS OUTPUT-TYPE
		  IN-FILE SCAN-FILE TAIL-SHEET PAGES tv-size-y tv-size-x ITEM
		  OUTPUT-FILE PENDING-LINE-SPACES SPOOL DEF-XGP-ROT DEF-ARDS-ROT
		  UNSPOOL-FILE)
	 (*EXPR ARDS-PRINT))

(DEFUN PROCESS-FILE NIL
       (LET
	((BACKGROUND 0) (COPIES 1) (CUT-PAPER T) (DELETE) (FILE-TYPE 'XGP)
	 (INDIRECT) (OUTPUT-TYPE 'GOULD) (PAPER-HEIGHT 850.) (PAPER-WIDTH 1100.)
	 (PRIORITY 0) (RUN-ENCODE T) (ROTATE 0) (SKIP 0) (STATUS) (WRAP-AROUND T)
	 (VERIFY) (ITEM) (XGP-COMMANDS) (LPT-COMMANDS) (ARDS-COMMANDS)
	 (TEK-COMMANDS) (IMAGE-COMMANDS) (SOFTWARE-TTY-COMMANDS) (SPOOL T)
	 (TAIL-SHEET) (tv-size-y 65.) (tv-size-x 1) (PENDING-LINE-SPACES 0)
	 (DEF-XGP-ROT 3.) (DEF-ARDS-ROT 0.) (UNSPOOL-FILE '|DSK:.GLPT.;GLPT >|)
	 (OUTPUT-FILE '((DSK /.GLPT/.) GLPT >)) (PAGE-INDEX 1) (PAGES 0)
	 (PAGE-WORD 1) (sender 'bug-gtpl))
	(NOINTERRUPT T)
	(DO ((L TO-BE-PROCESSED (CDR L)))	; get an item off the queue
	    ((OR (NULL L) (CAR L))
	     (COND ((NULL L) (THROW NIL TOP)))
	     (SETQ ITEM (CAR L)))
	    (SETQ TO-BE-PROCESSED (CDR TO-BE-PROCESSED)))
	(NOINTERRUPT NIL)
	(DO ((L (CADDDR (CDR ITEM)) (CDR L)))  ; bind flags for this file
	    ((NULL L))
	    (SET (CAAR L) (CDAR L)))
	(set-tv-array-parameters)
	(IF (EQ 'XGP output-type) (open-xgp-scan-file (cadr item)))
	(cond ((null (errset (FUNCALL (GET (CADDR ITEM) 'FUNC) (CAR ITEM)) nil))
	       (COND (TO-BE-PROCESSED (SETQ TO-BE-PROCESSED (CDR TO-BE-PROCESSED))))
	       (cond (in-file
		      (user-error '|Error encountered while processing:  |
				  (namestring in-file)))
		     (t (user-error '|Spooler error.  Get help!|)))
	       (If scan-file (close scan-file))
	       (throw nil top)))
	(COND (TAIL-SHEET (ARDS-PRINT (CAR (SETQ GTS-LIST (CDR GTS-LIST))))))
	(if (and (eq 'xgp output-type) spool) (xgp-queue))
	(COND (DELETE (DELETEF IN-FILE)))
	(COND (TO-BE-PROCESSED		; step along the queue
	       (SETQ TO-BE-PROCESSED
		     (CDR TO-BE-PROCESSED))))))


(defun set-tv-array-parameters ()
   (IF (MEMQ FILE-TYPE '(ARDS XGP TEK)) (SETQ tv-size-x 1700.))
   (IF (eq 'xgp output-type)		; XGP scan output for the XGP
       (setq DEF-XGP-ROT 0.
	     DEF-ARDS-ROT 3.
	     tv-size-y 52.    ;image line length = 54. but 1 1/2 words of hdr
	     tv-size-x 2112.)))

(defun open-xgp-scan-file (file)
       (setq output-file '((dsk /.glpt/.) > scn))
       (cond (file (setq output-file (mergef file output-file))))
       (setq scan-file
	     (errset (open (cons (car output-file) '(/.glpt/. output))
				  '(out fixnum block))
		     nil))
       (if scan-file (setq scan-file (car scan-file))))

(defun xgp-queue ()
   (prog (queue-file)
    (cond ((probef '|ai:.xgpr.;.file. (dir)|)) 	; is AI up?
	  (t (user-error 
'|Warning:  Your XGP output has not been submitted to the XGP queue/
	because AI is down.  The XGP SCN files for your spooler/
	request have been left on DSK:.GLPT.;.  To get your files/
	printed you must copy them to the AI machine and queue them/
	when AI comes back up.  See the XGP node under :INFO GTPL/
	for more details./
|)
	     (return nil)))
    (cond ((null
	    (errset
	     (progn
	      (do ((l (mapcar 'car (nreverse (directory '( ((dsk /.glpt/.) * SCN)))))
		      (cdr l)))
		  ((null l))
		  (copy-file (car l) '((ai /.xgpr/.) > SCN))
		  (deletef (car l)))
	      (setq queue-file
		    (open '|ai:.xgpr.;_queue output| '(out))) 
	      (Mapc '(lambda(x) (princ x queue-file))
		    (list '|;Status | sender '|	MC O | (time-string) '/ 
		          (date-string) '|	?	Scan file for MC spooler/
|			  '|;Notify MIT-MC,| sender 
			  '| Your XGP Scan output has started/
|			  '|;Default ai:.xgpr.;/
|			  '|;Scan ai:.xgpr.;* SCN/
|))
	      (renamef queue-file '(|    Q1| >))
	      (close queue-file))
	     nil))
	 (user-error
'|Error occurred while trying to queue your output for the XGP (probably/
  due to AI going down).  You must queue your output manually when AI/
  is revived.  See the XGP node under :INFO GTPL for more details./
|)))))

(defun time-string ()
       (let ((time (status daytime)) (base 10.) (*nopoint t))
	    (implode (apply 'append
			    (mapcar 'explode (list (car time)  '/:
						   (cadr time) '/:
						   (caddr time)))))))

(defun date-string ()
       (let ((date (status date)) (base 10.) (*nopoint t))
	    (implode (apply 'append
			    (mapcar 'explodec (list (cadr date)  '//
						    (caddr date) '//
						    (car date)))))))
(defun copy-file (from to)
   (setq from (open from '(in fixnum))
	 to   (open to   '(out fixnum)))
   (do ((i (caddar (directory (list (truename from)) '(words)))
	   (- i 500))
	(copy (array nil fixnum 500)))
       ((not (> i 0)))
       (cond ((< i 500) (*rearray copy 'fixnum i)))
       (fillarray copy from)
       (fillarray to copy))
   (close from)
   (close to))

(Comment Gould Connect Routines)
(declare (*expr %chaos-open-channels %chaos-close-channels
		%chaos-request-connection %chaos-eof))

;;; see the file L;LCHNSP > for the %chaos routines
;;; add hair for sending messages to a user when the GOULD is dead.

(defun gould-connect nil 
       (do ((state 0))
	   (NIL)
	   (setq state
		 (*catch 'chaos-pktiot-error  ;catch IOC errors
			 (gould-open)
			 (%chaos-request-connection
			     gould-connection
			     #gould-host
			     'GOULD
			     #gould-timeout)))
	   (cond ((= #%csopn state) (return nil))
		 (t (sleep #gould-repair-time)))))

(defun gould-open nil
    (if gould-connection (%chaos-close-channels gould-connection))
    (setq gould-connection (%chaos-open-channels 2)))	;rarely receive stuff

(defun gould-disconnect nil				;in-elagent close, but...
       (if gould-connection
	   (progn (%chaos-eof gould-connection)
		  (%chaos-close-channels gould-connection)))
       (setq gould-connection nil))

(Comment Image Array Output)

(DECLARE (SPECIAL tv-size-y tv-size-x PENDING-LINE-SPACES)
	 (FIXNUM  tv-size-y tv-size-x PENDING-LINE-SPACES (ILDB* FIXNUM FIXNUM))
	 (array* (fixnum tv 2))
	 (*EXPR ILDB* %send-page-image))

(DECLARE (EVAL (READ))) (SETQ LFT-MAR 0)

(SETQ tv-size-y 65. tv-size-x 1)
(ARRAY TV FIXNUM tv-size-y tv-size-x)
(setq tv (get 'tv 'array))

(DEFUN TV-FORMFEED ()
   (COND ((EQ 'XGP OUTPUT-TYPE) (XGP-SCAN))
;	 ((EQ 'BIT OUTPUT-TYPE) (output-array IMAGE-OUT-FILE 'TV))
	 (T (do NIL
		((*catch 'chaos-pktiot-error  ;IOC errors get caught here
			 (%send-page-image gould-connection tv)))
		(gould-disconnect) (gould-connect)))))

(defun output-array (file array)
       (setq array (get array 'array))
       (do ((x 0 (1+ x))
	    (xlim (caddr (arraydims array))))
	   ((= x xlim))
	   (declare (fixnum x xlim))
	   (do ((y 0 (1+ y))
		(ylim (cadr (arraydims array))))
	       ((= y ylim))
	       (declare (fixnum y ylim))
	       (out file (arraycall fixnum array y x)))))

(defun input-array (array file)
       (setq array (get array 'array))
       (do ((x 0 (1+ x))
	    (xlim (caddr (arraydims array))))
	   ((= x xlim))
	   (declare (fixnum x xlim))
	   (do ((y 0 (1+ y))
		(ylim (cadr (arraydims array))))
	       ((= y ylim))
	       (declare (fixnum y ylim))
	       (store (arraycall fixnum array y x)
		      (in file)))))

(Comment Image formats file processing)

(DECLARE (EVAL (READ))) (SETQ MAX-NO-FONTS 20 )

(DEFUN IMAGE-PRINT (FILE)
       NIL)

(DEFUN INPUT-XGP-LINE (FILE) ; when wriiten, should parse XGP scan format
       (input-array 'tv file))


(DECLARE (SPECIAL tv-size-x tv-size-y)
	 (FIXNUM LINENO WIDTH BYTES COUNT XORMASK WORD COLACC I NUM DUM M WORDACC
		 OWORD SHIFT MASK1 MASK2 Y Y1 tv-size-y tv-size-x BYTEPTR XGP-WIDTH
		 LAST-LINE WA-SIZE (CIRC FIXNUM))
	 (*EXPR CIRC)
	 (ARRAY* (FIXNUM WORKING-ARRAY 1.)))

(DECLARE (EVAL (READ))) (SETQ XGP-SCAN-START 0)
(OR (GET 'CIRC 'SUBR) (DEFPROP CIRC (FTV FASL DSK GLPT) AUTOLOAD))
; CHECK FIX UP ARRAY BEFORE FILLARRAYS (0'TH ELEMENT, LENGTH, COUNT, ETC)
; CHECK BYTE-PTR.  SHOULD USE ILDB FUNCTION SOMEDAY.

(DEFUN XGP-SCAN () 
       (ARRAY WORKING-ARRAY FIXNUM 1.)
       (DO ((LINENO #XGP-SCAN-START (1+ LINENO))
	    (WA-SIZE (+ tv-size-y 3.))  ; one extra for idpb header
	    (WIDTH tv-size-y tv-size-y) (COUNT 6. 6.) (BYTES 0.) (WORD 0.)
	    (IMAGE NIL NIL) (XORMASK (LSH -1. -4.)) (MASK1 (+ 255._28. 255._12.))
	    (MASK2 (+ 255._20. 255._4.)) (WORKING-ARRAY (GET 'WORKING-ARRAY 'ARRAY))
	    (XGP-WIDTH 54.))
	   ((= LINENO tv-size-x)
	    (OUT SCAN-FILE (LSH (+ 2._16. 1._15. (* 192. 11.)) 4.))
	    (OUT SCAN-FILE 0))
	   (*REARRAY 'WORKING-ARRAY 'FIXNUM WA-SIZE)
	   (STORE (WORKING-ARRAY 0) #(+ 20._30. 8._24. 8._18. 2))
	   (STORE (WORKING-ARRAY 2) 0)
	   (SETQ BYTES (* 4. (1+ WIDTH)))
	   (DO ((I (1- WIDTH) (1- I)))
	       ((OR (< I 0.) (NOT (= (TV I LINENO) 0.))) (SETQ WIDTH (1+ I))))
	   (DO ((I 0. (1+ I)) (COLACC 0.) (COLOUR NIL))    ;NIL=WHITE T=BLACK
	       ((= I WIDTH)
		(COND ((= COUNT 6.) (SETQ COUNT 0.))
		      (T (IDPB 0 WORKING-ARRAY) (IDPB 0 WORKING-ARRAY)
			 (IDPB 0 WORKING-ARRAY) (IDPB 1 WORKING-ARRAY)
			 (SETQ COUNT (+ COUNT 4.))
			 (COND ((NOT (= (BOOLE 1. COUNT 3.) 0.))
				(IDPB 0 WORKING-ARRAY) (IDPB 0 WORKING-ARRAY)
				(SETQ COUNT (+ COUNT 2.))))
			 (SETQ COUNT (// COUNT 4.)))))
	       (SETQ WORD (LSH (TV I LINENO) -4.))
	       (COND (COLOUR (SETQ WORD (BOOLE 6. WORD XORMASK))))
	       (DO ((WORDACC 0.) (NUM 0.) (DUM 0.) (EXITP))
		   (NIL)
		   (SETQ NUM (- 32. (HAULONG WORD))
			 WORDACC (+ WORDACC NUM)
			 COLACC (+ COLACC NUM))
		   (COND ((> WORDACC 31.)
			  (SETQ COLACC (- COLACC WORDACC -32.))
			  (COND ((AND COLOUR (= (1+ I) WIDTH)) (SETQ EXITP T))
				(T (RETURN NIL)))))
		   (SETQ DUM (1- (* 2. (// (+ 254. COLACC) 255.))))
		   (COND ((NOT (< (+ COUNT DUM) BYTES)) (SETQ IMAGE T) (RETURN NIL)))
		   (SETQ DUM (// DUM 2.))
		   (DO ((M 0. (1+ M))) ((= M DUM))
		       (IDPB 255. WORKING-ARRAY) (IDPB 0 WORKING-ARRAY)
		       (SETQ COLACC (- COLACC 255.) COUNT (+ COUNT 2.)))
		   (IDPB COLACC WORKING-ARRAY) (SETQ COUNT (1+ COUNT))
		   (AND EXITP (RETURN NIL))
		   (SETQ WORD (BOOLE 6. (LSH WORD NUM) XORMASK) 
			 COLACC 0. COLOUR (NOT COLOUR)))
	       (AND IMAGE (RETURN NIL)))
	   (COND (IMAGE (DO ((I 0. (1+ I)) (WORDACC 2._4. WORD) (WORD)) ((> I WIDTH))
			    (SETQ WORD (COND ((= I WIDTH) 0.)
					     (T (CIRC (TV I LINENO)))))
			    (STORE (WORKING-ARRAY (1+ I))
				   (BOOLE 6. (LSH WORDACC 16.)
					  (LSH (LSH WORD -20.) 4.)))
			    ;(STORE (WORKING-ARRAY (+ I 3)) (CIRC (TV I LINENO)))
)
			(SETQ COUNT (+ WIDTH 1.) WIDTH (+ tv-size-y 2.))
			(DO ((I COUNT (1+ I))) ((= I WIDTH))
			    (STORE (WORKING-ARRAY (1+ I)) 0.))
			(SETQ COUNT XGP-WIDTH))
		 (T (SETQ WIDTH COUNT)
		    (DO ((I 0. (1+ I))) ((= I WIDTH))
			(STORE (WORKING-ARRAY I) (WORKING-ARRAY (1+ I))))))
	   (COND ((NOT (= COUNT 0.))
		  (STORE (WORKING-ARRAY 0.)
			 (+ (LSH COUNT 21.) (LSH LINENO 4.)))
		  (DO ((I 1. (1+ I))) ((= I WIDTH))
		      (SETQ WORD (WORKING-ARRAY I))
		      (STORE (WORKING-ARRAY I)
			     (+ (LSH (BOOLE 1. WORD MASK1) -8.)
				(LSH (BOOLE 1. WORD MASK2) 8.))))
		  (*REARRAY 'WORKING-ARRAY 'FIXNUM WIDTH)
		  (FILLARRAY SCAN-FILE 'WORKING-ARRAY)
		  (COND (IMAGE (DO ((I WIDTH (1+ I))) ((= I XGP-WIDTH))
				   (OUT SCAN-FILE 0.)))))))
       (*REARRAY 'WORKING-ARRAY 'FIXNUM 1.))

(DEFUN SPOOL-RESET ()
       (SETQ TO-BE-PROCESSED NIL) (RECORD-Q)
       (COND ((AND MAIL-FILE (STATUS FILEMODE MAIL-FILE)) (CLOSE MAIL-FILE)))
       (COND ((AND IN-FILE (STATUS FILEMODE IN-FILE)) (CLOSE IN-FILE)))
       (COND ((AND SCAN-FILE (STATUS FILEMODE SCAN-FILE)) (CLOSE SCAN-FILE)))
       (COND ((PROBEF '|DSK:.GLPT.;GLMAIL <|) (DELETEF '|DSK:.GLPT.;GLMAIL <|)))
       (COND ((PROBEF '|DSK:.GLPT.;.GLPT. >|)
	      (DELETEF '|DSK:.GLPT.;.GLPT. >|)))
       (COND ((PROBEF '|DSK:.GLPT.;-GLPT- QUEUE|) (DELETEF '|DSK:.GLPT.;-GLPT- QUEUE|)))
       (DO NIL ((NOT (PROBEF '|DSK:.GLPT.;GLPT >|))) (DELETEF '|DSK:.GLPT.;GLPT >|))
       (if gould-connection (gould-disconnect))
       (*THROW 'TOP nil))

(SETQ CLI-MESSAGE 'CLI-MESSAGE-HANDLER ALARMCLOCK 'ALARM-HANDLER)

(DEFUN CLI-MESSAGE-HANDLER (X)
       (SETQ X X)	; ALWAYS NIL
       (SETQ MAIL-FILE (OPEN '|CLA:| '(CLA BLOCK IN)))
       (TYIPEEK 12 MAIL-FILE)
       (PROCESS-MAIL))

(DEFUN ALARM-HANDLER (TYPE)
       (DO nil
	   ((Null (PROBEF '|DSK:.GLPT.;GLMAIL >|)))
	   (setq clock-times-waited 0)			;reset
	   (setq mail-file (OPEN '|DSK:.GLPT.;GLMAIL <| '(IN DSK ASCII)))
	   (PROCESS-MAIL))
;       (cond ((boundp 'in-file) (report-% in-file))
;	     (t (errset (deletef '((dsk |.glpt.|) %read report)) nil)))
       (SETQ TYPE TYPE)
       (if (null to-be-processed)
	   (setq clock-times-waited (1+ clock-times-waited)))
       (cond ((> clock-times-waited #wait-time)
	      (syscall 0 'LOGOUT 0)))
       (ALARMCLOCK 'TIME #MAIL-TIME))

;; Must test this stuff then will install-smm 10.8
;(defun report-% (file)
;	((lambda (report base)
;		 (print (filepos file) report)
;		 (print (get (car (directory (list (truename file))
;					     '(characters)))
;			     'characters))
;				;; Maybe leave this to gldsts?
;		 (close report))
;	 (open '((dsk |.glpt.|) %read report) '(out))
;	 (+ 5 5)))


(Comment Output to persons)

(declare (fixnum num))

;; To the maintainers: internal bug report
(DEFUN mail-error (X)
       (COND ((EQUAL '|FILE NOT FOUND.  | X))
	     ((NULL ^W) (BREAK Mail-error T))))

;; To the user: visible bug report
;; This function is called as an expr to save space at the expense
;;  of time.  Don't do a *lexpr user-error.

(defun user-error n (report-failure sender (listify n)))

; Operator for reporting a user's errors to him

(defun report-failure (loser msg-list)
       ((lambda (outfiles ^r ^w)
	  (cond (outfiles (mailout '|| msg-list)		;Check CLI first
			  (close (car outfiles)))
		(t (setq outfiles (list (open '|dsk:.mail.;mail >| '(out ascii))))
		   (mailout '|FROM-JOB:| (list (status jname)))	;Otherwise use mailer
		   (mailout '|FROM:| (list '|X"| (status uname)))
		   (mailout '|CLAIMED-FROM:| (list (status userid)))
		   (mailout '|TO:| (list '|S"| loser))
		   (mailout '|TEXT;-1/
|			    msg-list)
		   (close (car outfiles)))))
	(errset (open (list '(cli) sender 'hactrn) '(out ascii)) ())
	t t))

(defun mailout (name values) (princ name) (mapc 'princ values) (terpri))
;; Useful auxiliary functions

(defun pluralizer? (num)	;Used like: (princ num) (princ '| dollar|)
       (cond ((= num 1) '||)	;		(princ (pluralizer? num))
	     (t '|s|)))

(COMMENT LAP CODE FOR ILDB AND IDPB FUNCTIONS)
; TAKE ADVANTAGE OF PDP-10 HARDWARE.

(LAP	IDPB SUBR)
(ARGS	IDPB (NIL . 2))
	(PUSH P (% 0 0 FIX1))	; NCALLABLE
	(MOVE TT 0 A)
	(HRRZ D 1 B)
	(IDPB TT 0 D)		; DEPOSIT THE BYTE
	(POPJ P)
()

; ASSUMES AN ARRAY AS ABOVE.  RETURNS A BYTE
(LAP	ILDB SUBR)
(ARGS	ILDB (NIL . 1))
	(PUSH P (% 0 0 FIX1))	; NCALLABLE
	(HRRZ D 1 A)
	(ILDB TT 0 D)
	(POPJ P)
()

(LAP	ILDB* SUBR)
(ARGS	ILDB* (NIL . 2))
	(PUSH P (% 0 0 FIX1))	; NCALLABLE
	(Hllz d 0 b)
	(ILDB TT D)		; ASSUMES BYTE POINTER INDEXES THRU D
	(POPJ P)
()

(lap	disowned? subr)
	(*SUSET 0 (% 0 0 R 54))	; GET .OPTION USET
	(MOVEI A 'TRUTH)
	(TLNE R 10000)			; SKIP IF NOT UNDER A DDT
	(MOVEI A 'NIL)
	(POPJ P)
()

(LAP	SET-UNAME SUBR)
(ARGS	SET-UNAME (NIL . 0))
	(*SUSET 0 (% 0 0 R 54))	; GET .OPTION USET
	(MOVEI A 'NIL)
	(TLNE R 10000)			; SKIP IF NOT UNDER A DDT
	(POPJ P)
WAIT	(*SUSET 0 (% 0 0 R 65))	; GET SUPERIOR'S INDEX
	(AOJN R WAIT)
	(MOVEI A 'T)
SETLP	(MOVE T (% (SIXBIT UNAME)))	;SET THE XUNAME
	(MOVE TT (% (SIXBIT GLPTR)))
	(*CALL 0 USRVAR)
	(JRST 0 USRERR)			;IF LOST, MUST BE DUE TO ANOTHER SPOOLER
	(MOVE T (% (SIXBIT XUNAME)))	;SET THE UNAME
	(*CALL 0 USRVAR)
	(*LOSE 1000)			;NO REASON TO LOSE HERE...
	(MOVE T (% (SIXBIT SNAME)))	;SET THE SNAME SO PEEK LOOKS NICE
	(MOVE TT (% (SIXBIT SPOOLR)))
	(*CALL 0 USRVAR)
	(*LOSE 1000)
	(*SUSET 0 (% 0 0 (% 200000) 400002))	; %TBNVR TELL IT NOT TO HANG WAITING FOR A TTY
	(POPJ P)

USRVAR	(SETZ)
	(SIXBIT USRVAR)
	(0 0 (% -1))
	(0 0 T)
	(0)
	(SETZ 0 (% MOVE 0 TT))

;;; COME HERE WHEN WE LOST - SHOULD ONLY HAPPEN IF A SPOOLER ALREADY EXISTS

USRERR	(*CALL 0 USROPN)		; TRY TO OPEN USR DEVICE TO SPOOLR
	(*LOSE 1000)			; COULDN'T GET IT, BETTER PUNT
	(*SUSET 0 (% 0 0 TT 54))	; GET OPTION WORD
	(*USET 11 (% 0 0 T 7))		; CHECK STOP BIT
	(TLNE T 10000)
	(JRST 0 DEAD)			; STOPPED, SO HE MUST BE DEAD
	(*LOGOUT)			; MUST BE OK, SO WE ARE NOT NEEDED
	(*BREAK 16 40000)		; LOGOUT OR PUNT
DEAD	(*USET 11 (% 0 0 T 23))		; FLUSH HIM
	(*GUN T 0)
	(*CLOSE 11)
	(JRST 0 SETLP)			;GO TRY AGAIN

USROPN	(SETZ)
	(SIXBIT OPEN)
	(0 0 11 1000)
	(0 0 14 5000)
	(0 0 (% (SIXBIT USR)))
	(0 0 (% (SIXBIT GLPTR)))
	(SETZ 0 (% (SIXBIT SPOOLR)))
()

;; Takes an atom and waits for its value to be non-nil

(lap wait-for-non-null subr)
 (args wait-for-non-null (nil . 1))
	(hlrz 1 0 1)
	(hrrz 1 0 1)
	(skipn 0 0 1)
	(*hang 0)
	(setz 1)
	(popj p)
()

(lap lock-pages subr)
(args lock-pages (nil . 0))
	(movei a 't)
	(call 1 'nointerrupt)
	(hrlzi t -256.)
loop	(*call 0 type)
	 (*value 0)
	(skipn 0 tt)
	 (jrst 0 nopage)
	(skipl 0 tt)
	 (troa tt 12000)
	  (tro tt 102000)
	(*call 0 lock)
	 (*value 0)
nopage	(aobjn t loop)
	(movei a 0)
	(call 1 'nointerrupt)
	(popj p 0)

lock	(setz)
	(sixbit corblk)
	(movei 0 0 tt)
	(movei 0 -1)
	(movei 0 0 t)
	(setzi 0 -1)
type	(setz)
	(sixbit cortyp)
	(movei 0 0 t)
	(setzm 0 tt)
()

(lap unlock-pages subr)
(args unlock-pages (nil . 0))
	(movei a 't)
	(call 1 'nointerrupt)
	(hrlzi t -256.)
loop	(*call 0 type)
	 (*value 0)
	(skipn 0 tt)
	 (jrst 0 nopage)
	(skipl 0 tt)
	 (troa tt 11000)
	  (tro tt 101000)
	(*call 0 unlock)
	 (*value 0)
nopage	(aobjn t loop)
	(movei a 0)
	(call 1 'nointerrupt)
	(popj p 0)

unlock	(setz)
	(sixbit corblk)
	(movei 0 0 tt)
	(movei 0 -1)
	(movei 0 0 t)
	(setzi 0 -1)
type	(setz)
	(sixbit cortyp)
	(movei 0 0 t)
	(setzm 0 tt)
()

(declare (read))
(read)
(progn (terpri)
       (fasload lchnsp fasl dsk lisp)
       (fasload gldpko fasl dsk chsgtv)
       (terpri)
       (princ '|Dump TS SPOOLR (Y or N)? |)
       (cond ((member (IMPLODE (LIST (TYI T))) '(/y Y)) 
	      (Terpri)
	      (PRINC '|Don't Forget to put entry in LISP;LOCK > for LISP Version: |)
	      (PRINC (STATUS LISPV)) (TERPRI)
	      (SSTATUS TOPLEVEL '(init-dump))))
       (terpri))
(princ '|NEWIO with SPGLPT loaded|)
(terpri)


(Comment Spooler documentation)
; 
; Spool messages consist of file specifications and option flags.
; File specs are in the form:
;     <output filespec>_<filespec1><flags>,<filespec2><flags>,...  ,
; where <filespec> is a standard ITS file spec (i.e. a sequence of
; up to 4 words with the device and directory distinguished by : and ;
; prefixes).  Flags are local to the preceeding filespec.  The optional
; form  _(<global flags>)<filespec1>,... is also be allowed.
; <flags> are single letters, possibly followed by arguments.  The 2
; forms for flags are (as in the @ program) (<flag><flag>...) or
; /<flag>/<flag> ...  the chars "/","(",")",",","^q"  can be quoted with ^q.
; Suggested flags:
; Control flags:
; p	- Priority, preceded by a single digit (0-9)
; b	- Black background
; r	- Rotate the page.
; v	- Verify.  Inform the user when his file has been printed (queued?)
; k	- Kill (delete) the file once it has been printed.
; u	- Unspool the file (i.e. remove it from the queue).
; !	- Wraparound on over run lines (default is truncate unless in ;list mode)
; *	- Reset the world
; ?	- Send a status report
; c	- Copies.  Preceeded by an numeric argument.
; w	- Page width
; z	- Page size
; ~	- Don't cut paper. (Default is to cut at page boundaries)
; @	- Indirect.  (i.e. treat file as a command file)
; o	- Output format.  Next char: g (gould scan), x (xgp scan),
;		 b (bit image) - /o[x]
; s	- Spool option.  To suppress this default for gould or xgp output, use -s
; &	- Force image mode encoding (no scan compression).
; $	- Append a graphic tail sheet.
; File type flags (mutually exclusive - defaults to l):
; a	- Ards.  File has chars plus ards graphics.
; x	- Xgp.	File has xgp commands.
; l	- List the file like the ;list command of the xgp spooler
; h	- List the file LPT style (for ASCII files).
; t	- Tektronix.  File has tektronix graphics commands (from a netout file, etc.)
; y	- Tty graphics (software tty conventions, yet to be established).
; i	- File is image format.  Followed by b (bit image), x (xgp scan format), 
;         or g (gould scan format). e.g. /i[x].  note /i is the same as /i[b]
; d	- File is dplt format
; A digit preceeding any of the file type flags is a page number at which
; to start printing. + and - are used as prefixes to turn flags on or off (e.g. -!)

; When an output file spec. is given, spooling is defaulted to being suppressed.

;
;                        Maintainers' documentation.
;
;  To create a new spooler, compile this file and load it into a (new i/o)
;  Lisp.  Then say (init-dump) and it will take care of initializing and
;  dumping itself.
;
;                         Operation of the program.
;
;  Normally, it runs disowned.  It reads mail from GLMAIL < .GLPT.; , interprets
;  it, and enters the interpretation into -GLPT- QUEUE .GLPT.; as printed
;  list structure.  Then one by one it takes the entries off the queue
;  and processes the files.  Output goes to GLPT > files, which are then
;  sent to the Gould by the unspooler.
;
;                                  Errors.
;
;  Errors are reported to the user with the function user-error (qv).
;
;                                  Crocks.
;
;  Currently, the way the program senses the presence of mail files is
;  to periodically (with alarmclock) check.  A better way would be to
;  have some system of direct communication with the GTPL program, for
;  instance a CLI interrupt or a shared page.  The advantages would be:
;  no load on the system when nothing was happening; faster response;
;  no change of working set to process the interrupt while processing a file
;  (deferring interrupts in the present scheme would accomplish this
;  last, but would slow down error messages).
;  There is currently no status display.

;; Local Modes:
;; Mode: LISP
;; Comment Col: 40
;; END:
