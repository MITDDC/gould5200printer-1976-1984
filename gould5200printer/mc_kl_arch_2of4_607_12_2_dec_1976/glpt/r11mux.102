.TITLE TERMINAL MULTIPEXER AND GOULD DRIVER


;  REGISTERS 

R0=%0
R1=%1
R2=%2
R3=%3
R4=%4
R5=%5
SP=%6
PC=%7

;  MISCELLANEOUS CONSTANT DEFINITIONS

MXTTTY==4		; MAXIMUM NUMBER OF TERMINALS THIS ASSEMBLY
MAXTTY==4		; MAXIMUM NUMBER OF CHANNELS SUPPORTED CURRENT ITS ASSEMBLY
MXRTTY==2		; NUMBER OF DEVICE REGISTER RECEIVE TTYS
MXXTTY==3		; NUMBER OF DEVICE REGISTER TRANSMIT TTYS
MXATTY==1		; NUMBER OF ANN ARBOR TERMINALS
PRIOR0==7_5		; MASK FOR BIC APPLIED TO PS
PRIOR7==7_5		; MASK FOR BIS APPLIED TO PS
P7=PRIOR7
P5=5_5
CG==7			; <CNTL>-G
CBSL==34		; <CNTL>-\
NOPIN==240		; NOP INSTRUCTION
WAITIN==1		; WAIT INSTRUCTION
LBUFL==410	; MAXIMUM SIZE OF A LINE BUFFER (IN BYTES)
RSTRLN==10000	; LENGTH OF TEMPORARY STRING BUFFERS
TSTRLN==24
STRIP==177600	; BIT IN BUFFER WORD WHICH INDICATED STRIPED GRAPHICS
LHS==177400	; LEFT HAND SIDE OF WORD MASK
GLDTIM==30	; TIME (IN 30TH'S OF SECOND) FOR SMEAR TIMEOUT
CORLIM==137472	; LIMIT OF USABLE CORE (24K-LOADERS)

;  CONSTANTS FOR INITIALIZATION OF NON-STANDARD DEVICES 

DR11MI==0
KEYBDI==101
IMLACI==0
INVBIT==40000	; INDICATES VALID DATA ON INPUT MULTIPLEXOR

;  RECEIVE BUFFER PARAMETERS 
RIBFLN==300
ROBFLN==300

ALCMAX==276	; MAXIMUM PERMISSABLE ALLOCATION
		; 2 CHARACTERS LESS THAN BUFFER SIZE, ONE TO ALLOW
		; FOR ^G INSERTION AND ONE FOR PATHOLOGICAL FENCEPOST
		; INTERACTIONS

ALCLIM==ALCMAX/2	; AT THIS POINT, ADD TO ALLOCATION
ALCINC==ALCMAX/2	; THIS IS HOW MUCH TO INCREMENT THE ALLOCATION BY
.PAGE

; GOULD COMMAND CODES
 %GCFF==0	; TOP-OF-FORM COMMAND (128 RASTERS ON ROLL PAPER)
 %GCGRF==1	; GRAPHIC MODE COMMAND
 %GCCUT==2	; CUT COMMAND (NO CUTTER ON THIS MACHINE, THOUGH)
 %GCON==3	; TURN PRINTER ON
 %GCOFF==4	; TURN PRINTER OFF
 %GCLSL==5	; LAST LINE (GRAPHIC MODE).  => 2 MORE SCAN LINES.
 %GCION==6	; INTERRUPT ON
 %GCIOF==7	; INTERRUPT OFF
 %GCHOM==200	; HOME (128 RASTER UNITS)
 %GCADV==201	; ADVANCE ONE LINE

; PSEUDO COMMAND CODES

 %GCSRP==300	; START OF REPEAT
 %GCERP==301	; END OF REPEAT


; MACRO COMMAND CODES

 SLALPH==140000	; SELECT ALPHA MODE
 SLLGRF==150000	; SELECT LOW SPEED GRAPHICS MODE
 SLHGRF==160000	; SELECT HIGH SPEED GRAPHICS MODE
 SLEOF==170000	; EOF (TAIL SHEET HACKERY)

; GOULD STATUS BITS
 %GSNRD==400	; NOT READY (INTERLOCK TRIPPED)
 %GSDON==2000	; DMA TRANSFER COMPLETE
 %GSBSY==4000	; BUSY (PAPER MOVEMENT, SYSTEM BEING RESET, ETC.)
 %GSVAC==10000	; VACUUM FAULT
 %GSPAP==20000	; PAPER LOW
 %GSTIM==40000	; HIGH SPEED GRAPHICS TIMEOUT
 %GSERR==40400	; ALL ERROR BITS EXCEPT PAPER LOW



;  SPECIAL GOULD COMMUNICATION BYTE CODES

%CCSOD=205	; ESCAPE FOR BEGINNING OF DATA
%CCEOD=206	; ESCAPE FOR END OF DATA
%CCQOT=215	; TO QUOTE 8 BIT CODES IN GRAPHICS MODE
%CCACK=301	; ARE WE BEING PAGED?
.PAGE

; 12-BIT KEYBOARD CODES
MASK37==177740
MAXMUX==177774		; NUMBER OF MULTIPLEXED INPUT LINES (POWER OF 2 -USED AS A MASK)
MASCII=177600		; MASK THE ASCII PART OF THE DATA
MBYTE=177400		; MASK FOR CLEARING THE LEFT BYTE (MAINLY FOR FLUSHING SIGN EX.)
%SPKEY=200		; SPECIAL KEY
%SBITS=MASK37		; SPECIAL BITS (META,TOP, CTRL, SHIFT,SHIFT LOCK)
%SHLOK=10		; SHIFT LOCK (LH BYTE ON INPUT)

; ANN ARBOR CODES
%AAPOS==17

;  TRANSMIT BUFFER PARAMETERS 

TIBFLN==40
TOBFLN==MAXTTY*<40+6>


.PAGE
.SBTTL  INTERFACE DEFINITIONS 

; DEC INTERFACES

; SERIAL INTERFACES
%CRCSR==177560			; CONSOLE TTY
%CRBUF==177562
%CXCSR==177564
%CXBUF==177566
%DRCSR==175610			; DL-11E 40 KBAUD
%DRBUF==175612
%DXCSR==175614
%DXBUF==175616
%ERCSR==175620			; DL-11E 9600 BAUD
%ERBUF==175622
%EXCSR==175624
%EXBUF==175626
%FRCSR==175630			; DL-11E 9600 BAUD
%FRBUF==175632
%FXCSR==175634
%FXBUF==175636
%GRCSR==175640			; DL-11E 9600 BAUD
%GRBUF==175642
%GXCSR==175644
%GXBUF==175646

; PARALLEL INTERFACES
; INPUT
%I1ACS==167760			; DR-11L SIDE 1
%I1ABF==167762
%I1BCS==167764			; DR-11L SIDE 2
%I1BBF==167766
; OUT
%O1ACS==167770			; DR-11M SIDE 1
%O1ABF==167772
%O1BCS==167774			; DR-11M SIDE 2
%O1BBF==167776

%UNDEF==0
.PAGE
; HOME BREW HARDWARE

		; ANN ARBOR CONTROLLER
%AACS==%O1ACS
%AABF==%O1ABF

		; KEYBOARD MULTIPLEXOR
%KYSTA==%I1ACS		; STATUS REGISTER
%KYBUF==%I1ABF		; BUFFER REGISTER

		; DIGIVUE PLASMA DISPLAY
%PLACS==%UNDEF		; STATUS
%PLXBF==%UNDEF		; X REGISTER
%PLYBF==%UNDEF		; Y REGISTER
%PLDBF==%UNDEF		; DATA


; COMMERCIAL INTERFACES

		; GOULD ELECTROSTATIC PRINTER PLOTTER
%GLCSR=166000		; COMMAND AND STATUS REGISTER
%GLWC=166002		; NEGATIVE WORD COUNT REG
%GLCA=166004		; CURRENT ADDRESS REG


.PAGE
.SBTTL  DEVICE AND TTY DEFINITIONS 


RDST0==%DRCSR		; DEVICE 0 -> DL-11 CONNECTED TO PDP-10
RDBF0==%DRBUF
XDST0==%DXCSR
XDBF0==%DXBUF

RTST0==%ERCSR		; TTY 0 (T23) -> DL-11 CONNECTED TO IMLAC
RTBF0==%ERBUF
XTST0==%EXCSR
XTBF0==%EXBUF

RTST1==%CRCSR		; TTY 1 (T24) -> CONSOLE TTY, CONNECTED TO TEKTRONIX
RTBF1==%CRBUF		; (NO CHARACTER RECEPTION STATUS BITS)
XTST1==%CXCSR
XTBF1==%CXBUF

XTST2==%AACS		; TTY 2 (T25) -> ANN ARBOR DISPLAY CONTROLLER
XTBF2==%AABF

GLDCSR==%GLCSR		; TTY 3 (T26) -> GOULD LINE PRINTER (SPECIAL HARDWARE REGISTERS)
GLDWC==%GLWC
GLDCA==%GLCA

PLPSTA==%PLACS		; TTY 4  (T27) -> PLASMA PANEL DISPLAY
PLXBUF==%PLXBF
PLYBUF==%PLYBF
PLDBUF==%PLDBF

; SPECIAL DEVICES

KEYSTA==%KYSTA		; KEYBOARD MULTIPLEXOR
KEYBUF==%KYBUF

.PAGE
.SBTTL TABLE OFFSET DEFINITIONS

;  RECEIVE STATUS TABLE OFFSETS 
RI.PTR==0
RI.END==2
RI.BEG==4
RI.LIM==6
RI.FLG==10
RO.PTR==12
RO.END==14
RO.BEG==16
RO.LIM==20
AL.FLG==22
TTYNUM==25
RI.BLK==30
RO.BLK==32
MR.BLK==34
CG.BLK==36
R.FLGS==40
RS.PTR==42
RS.CNT==44
RO.ESF==46
RO.ESC==50
JMPESC==52
ROW==54
COL==56


;  TRANSMIT STATUS TABLE OFFSETS 

TI.PTR==0
TI.END==2
TI.BEG==4
TI.LIM==6
TI.FLG==10
TO.PTR==12
TO.END==14
TO.BEG==16
TO.LIM==20
CG.FLG==22
TTYNUM==25
TI.BLK==30
TO.BLK==32
MT.BLK==34
AL.BLK==36
T.FLGS==40
TS.PTR==42
TS.CNT==44

;  TRANSMIT OUTPUT DEVICE STATUS OFFSETS 

OD.PTR==0
OD.END==2
OD.BEG==4
OD.LIM==6
OD.BLK==10

.PAGE
.SBTTL  INTERRUPT AND TRAP VECTORS 

%ERRV=4
%ILIV=10
%BPTV=14
%IOTV=20
%PWRV=24
%EMTV=30
%TRPV=34
%CLRV=60
%CLXV=64
%LKV=100
%GLDV=174
%KEYV=200

%AADCV=210
%PLPV=214
%DLRV=300
%DLXV=304
%ELRV=310
%ELXV=314
%FLRV=320
%FLXV=324
%GLRV=330
%GLXV=334

%MSTR==340	; MASTER PRIORITY, NO CONDITION CODES SET

	; THESE GIVE MASTER PRIORITY WITH CONDITION CODE BITS SET TO
	; NOTIFY THE UNEXPECTED TRAP HANDLER WHICH STATE WAS RAISED
	; IDEALLY THEY SHOULD NEVER HAVE TO BE USED

%MSTR1==341
%MSTR2==342
%MSTR3==343
%MSTR4==344
%MSTR5==345
%MSTR6==346
%MSTR7==347

%CLRPR=200		; PRI 4, (DEVICE AT BR4)
%CLTPR=200		; PRI 4, (DEVICE AT BR4)
%KEYPR=200		; PRI 4, (DEVICE AT BR4)
%PLPPR=200
%AADPR=200		; PRI 4, (DEVICE AT BR4)
%ELRPR=200		; PRI 4, (DEVICE AT BR4)
%ELXPR=200		; PRI 4, (DEVICE AT BR4)
%FLRPR=200		; PRI 4, (DEVICE AT BR4)
%FLXPR=200		; PRI 4, (DEVICE AT BR4)
%GLRPR=200		; PRI 4, (DEVICE AT BR4)
%GLXPR=200		; PRI 4, (DEVICE AT BR4)
%GLDPR=240		; PRI 5, (DEVICE AT BR5)
%DLRPR=300		; PRI 6, (DEVICE AT BR6)
%DLXPR=300		; PRI 6, (DEVICE AT BR6)
%LKPR=300		; PRI 6, (DEVICE AT PSEUDO BR6)
.PAGE

.=%ERRV
	CPUERR			; CPU ERROR
	%MSTR1
.=%ILIV
	ILLOPR			; ILLEGAL INSTRUCTIONS
	%MSTR2
.=%BPTV
	BPTTRP			; BREAKPOINT TRAP
	%MSTR3
.=%IOTV
	IOTTRP			; IOT TRAP
	%MSTR4
.=%PWRV
	POWROF			; POWER FAIL - RESTART
	%MSTR
.=%EMTV
	EMTTRP			; EMULATOR TRAP
	%MSTR5
.=%TRPV
	UUOH			; TRAP INSTRUCTION
	%MSTR6
.=%CLRV
	INRT1			; CONSOLE RECEIVED CHARACTER
	%CLRPR
.=%CLXV
	INTT1			; CONSOLE TRANSMITTED CHARACTER
	%CLTPR
.=%LKV
	CLKHND			; LINE FREQUENCY CLOCK
	%LKPR
.PAGE
.=%GLDV
	GLDINT			; GOULD INTERRUPT
	%GLDPR
.=%KEYV
	KEYINT			; KEYBOARD MULTIPLEXOR
	%KEYPR
.=%AADCV
	INTT2			; ANN ARBOR DISPLAY CONTROLLER
	%AADPR
.=%PLPV
	PLPINT			; PLASMA PANEL (BUFFER EMPTY)
	%PLPPR
.=%DLRV
	INRD0			; DL-11 #1 RECEIVED CHARACTER
	%DLRPR
.=%DLXV
	INTD0			; DL-11 #1 TRANSMITTED CHARACTER
	%DLXPR
.=%ELRV
	INRT0			; DL-11 #2 RECEIVED CHARACTER
	%ELRPR
.=%ELXV
	INTT0			; DL-11 #2 TRANSMITTED CHARACTER
	%ELXPR
.=%FLRV
	INRT0			; DL-11 #3 RECEIVED CHARACTER
	%FLRPR
.=%FLXV
	INTT0			; DL-11 #3 TRANSMITTED CHARACTER
	%FLXPR
.=%GLRV
	INRT0
	%GLRPR
.=%GLXV
	INTT0
	%GLXPR

.PAGE
.SBTTL TABLE AND VARIABLE DEFINITION MACROS
;  UTILITY MACROS 


.MACRO PUSH X
.IRP Y,<X>
	MOV Y,-(SP)
.ENDM
.ENDM


.MACRO POP X
.IRP Y,<X>
	MOV (SP)+,Y
.ENDM
.ENDM


.MACRO MASK LEVEL
	PUSH %PS
	MOV #<LEVEL>_5,%PS
.ENDM

.MACRO UNMASK
	POP %PS
.ENDM

.MACRO CALL X
	JSR PC,X
.ENDM

.MACRO JCALL X
	JMP X
.ENDM

.MACRO RET
	RTS PC
.ENDM

.MACRO MSG X
.NCHR ZZ,^\X\
	.WORD ZZ
	.ASCII \X\
	.EVEN
.ENDM
.PAGE
;  BRANCH MACROS 

.MACRO SRTYMC NM
PLAC=.
.=SRTY+<NM*2>
SRTY'NM:	BR .+<MRAL'NM-MRTY'NM>
.=PLAC
.ENDM

.MACRO STTYMC NM
PLAC=.
.=STTY+<NM*2>
STTY'NM:	BR .+<MTCG'NM-MTTY'NM>
.=PLAC
.ENDM

.MACRO SRALMC NM,NM1
PLAC=.
.=SRAL+<NM*2>
SRAL'NM:	BR .+<MRTY'NM1-MRAL'NM>
.=PLAC
.ENDM

.MACRO STCGMC NM,NM1
PLAC=.
.=STCG+<NM*2>
STCG'NM:	BR .+<MTTY'NM1-MTCG'NM>
.=PLAC
.ENDM
.PAGE
;  INQUIRY LOOP MACROS 

.MACRO RPROC NM,NM1,MRTYSB,MRALSB	; CREATE A RECEIVE PROCESS
MRTY'NM:	BR MRAL'NM
	MOV #NM*2,R3
	CALL MRTYSB
	JMP TESTLB
	SRTYMC NM
MRAL'NM:	BR MRTY'NM1
	MOV #NM*2,R3
	CALL MRALSB
	JMP TESTLB
	SRALMC NM,NM1
.ENDM

.MACRO RSYM NM			; INQUIRE LOOP RECEIVE TERMINATION SYMBOL
MRTY'NM:
.ENDM

.MACRO TPROC NM,NM1,MTTYSB,MTCGSB	; CREATE A TRANSMIT PROCESS
MTTY'NM:	BR MTCG'NM
	MOV #NM*2,R3
	CALL MTTYSB
	JMP TESTLB
	STTYMC NM
MTCG'NM:	BR MTTY'NM1
	MOV #NM*2,R3
	CALL MTCGSB
	JMP TESTLB
	STCGMC NM,NM1
.ENDM

.MACRO TSYM NM			; INQUIRE LOOP TRANSMIT TERMINATION SYMBOL
MTTY'NM:
.ENDM
.PAGE
;  BUFFER MACROS 

.MACRO	RIBFMC NM		; RECEIVE INPUT BUFFER MACRO
RIBF'NM:	.BLKW RIBFLN/2
.ENDM

.MACRO	ROBFMC NM		; RECEIVE OUTPUT BUFFER MACRO
ROBF'NM:	.BLKW ROBFLN/2
.ENDM

.MACRO	TIBFMC NM		; TRANSMIT INPUT BUFFER MACRO
TIBF'NM:	.BLKW TIBFLN/2
.ENDM

.MACRO	TOBFMC NM		; TRANSMIT OUTPUT BUFFER MACRO
TOBF'NM:	.BLKW TOBFLN/2
.ENDM

.MACRO RSTRMC NM
RSTR'NM:	.BLKW RSTRLN/2
.ENDM

.MACRO	TSTRMC NM
TSTR'NM:	.BLKW TSTRLN/2
.ENDM


;  TABLE UTILITY MACROS 

.MACRO VALCRE NAM,NUM		; VALUE TABLE CREATING MACRO
	.REPT NUM
	NAM'MC \.RPCNT,\.RPCNT+1
.ENDR
.ENDM

.MACRO ADRMAC NAME,NM		; MACRO FOR ADDRESS TABLE ENTRY
	.WORD NAME'NM
.ENDM

.MACRO ADRCRE NAM,NUM		; ADDRESS TABLE CREATING MACRO
NAM:	.REPT NUM
	ADRMAC NAM,\.RPCNT
.ENDR
.ENDM
.PAGE

;  STATUS TABLE MACROS 

.MACRO	RSTAMC NM		; RECEIVE STATUS TABLE MACRO
RSTA'NM:	.WORD RIBF'NM		; RI.PTR
	.WORD RIBF'NM+RIBFLN		; RI.END
	.WORD RIBF'NM			; RI.BEG
	.WORD RIBF'NM			; RI.LIM
	.WORD MRTY'NM			; RI.FLG
	.WORD ROBF'NM			; RO.PTR
	.WORD ROBF'NM+ROBFLN		; RO.END
	.WORD ROBF'NM			; RO.BEG
	.WORD ROBF'NM			; RO.LIM
	.WORD MRAL'NM			; AL.FLAG
	.BYTE 0,200+NM,0,0		; TTYNUM
	.WORD 0				; RI.BLK
	.WORD 0				; RO.BLK
	.WORD 0				; MR.BLK
	.WORD 0				; CG.BLK
	.WORD 0				; R.FLGS
	.WORD RSTR'NM			; RS.PTR
	.WORD 0				; RS.CNT
	.WORD 0				; RO.ESF
	.WORD -1			; RO.ESC
	.WORD 0				; JMPESC
	.WORD 0				; ROW
	.WORD 0				; COL

.ENDM



.MACRO	TSTAMC NM		; TRANSMIT STATUS TABLES MACRO
TSTA'NM:	.WORD TIBF'NM
	.WORD TIBF'NM+TIBFLN
	.WORD TIBF'NM
	.WORD TIBF'NM
	.WORD MTTY'NM
	.WORD TDST0+OD.PTR	;INDIRECT POINTER
	.WORD TDST0+OD.END	;INDIRECT POINTER
	.WORD TDST0+OD.BEG	;INDIRECT POINTER
	.WORD TDST0+OD.LIM	;INDIRECT POINTER
	.WORD MTCG'NM
	.BYTE 0,200+NM,0,0
	.WORD 0
	.WORD TDST0+OD.BLK	;INDIRECT POINTER
	.WORD 0
	.WORD 0
	.WORD 0
	.WORD TSTR'NM
	.WORD 0
.ENDM
.PAGE
;  INTERRUPT HANDLER MACROS 

.MACRO INRTMC NM,INRTSB		; TTY RECEIVE INTERRUPT HANDLER
INRT'NM:	PUSH R3
	MOV #NM*2,R3
	CALL INRTSB
	POP R3
	RTI
.ENDM

.MACRO INTTMC NM,INTTSB		; TTY TRANSMIT INTERRUPT HANDLER
INTT'NM:	PUSH R3
	MOV #NM*2,R3
	CALL INTTSB
	POP R3
	RTI
.ENDM

;  ALLOCATION DATA MACROS 

.MACRO ALCMMC NM		; ALLOCATION MESSAGE MACRO
ALZM'NM:	.BYTE 200+NM,34	; ^\
		.BYTE 200+NM,32	; ^Z
ALCM'NM:	.BYTE 200+NM,34	; ^\
		.BYTE 200+NM,1	; ^A
		.BYTE 200+NM,0	; ALLOCATION
ALCI'NM==.-1
.ENDM


.MACRO MCNTMC NM
MCNT'NM:	.WORD 3		; MACRO FOR STORAGE OF COUNT OF MESSAGE
.ENDM

.MACRO ALCPMC NM
ALCP'NM:	.WORD ALCM'NM	; MACRO FOR STORAGE OF MESSAGE POINTER
.ENDM

.PAGE
.SBTTL $$$$$$ INITIALIZATION $$$$$

.=2000

INIT:	MOV #340,%PS
	RESET
	MOV #INIT,SP			; INITIALIZE STACK
			; INITIALIZE DEVICES
	MOV #TDST0,R1			; DEVICE 0
	MOV #SLRD0,VCRD0		; INTERNAL POINTER IN DEVICE 0
					; RECEIVE INTERRUPT HANDLER
	MOV OD.BEG(R1),OD.PTR(R1)
	MOV OD.BEG(R1),OD.LIM(R1)
	CLR OD.BLK(R1)
	BIS #100,RDST0			; ENABLE DL-11 RECEIVE INTERRUPTS
	BIC #100,XDST0			; DISABLE DL-11 TRANSMIT INTERRUPTS

	BIS #100,RTST0			; ENABLE DL-11 RECEIVE INTERRUPTS
	BIC #100,XTST0			; DISABLE DL-11 TRANSMIT INTERRUPTS

	BIS #100,RTST1			; ENABLE CONSOLE TTY RECEIVE INTERRUPTS
	BIC #100,XTST1			; DISABLE CONSOLE TTY TRANSMIT INTERRUPTS

	BIC #100,%LKS			; TURN OFF LINE CLOCK INTERRUPTS

	BIC #100,XTST2			; DISABLE ANN ARBOR CONTROLLER INTERRUPTS

1$:	MOV KEYBUF,R0			; KEYBOARD MULTIPLEXOR
	BIT #40000,R0			; THIS WILL PROBABLY CHANGE
	BNE 1$
	MOV #KEYBDI,KEYSTA

			; INTIALIZE ALL TTY CHANNELS
	MOV #<MAXTTY-1>*2,R3
2$:	CALL INTYSB			; INTYSB VECTORS TO PROPER INIALIZING ROUTINE
	SUB #2,R3
	BPL 2$

	MOV #WAITIN,WAITPL		; FIX WAIT INSTRUCTION
	CLR %PS				; ALLOW INTERRUPTS
	BR TESTLB			; SKIP OVER BRANCH PATCH TABLES

SRTY:	.BLKW MXTTTY
STTY:	.BLKW MXTTTY
SRAL:	.BLKW MXTTTY
STCG:	.BLKW MXTTTY

.PAGE
.SBTTL  INQUIRY LOOP 

TESTLB:
GLDTTY==3				; TTY CHANNEL NUMBER ASSOCIATED WITH GOULD
	RPROC 3,0,MRGLSB,MRALSB			; TTY 26
	RPROC 0,1,MRTYSB,MRALSB			; TTY 23
	RPROC 1,2,MRTYSB,MRALSB			; TTY 24
AATYST==2				; START OF ANN ARBOR TERMINALS
	RPROC 2,4,MRTYSB,MRALSB			; TTY 25
	RSYM \MXTTTY

	TPROC 0,1,MTTYSB,MTCGSB			; TTY 23
	TPROC 1,2,MTTYSB,MTCGSB			; TTY 24
	TPROC 2,3,MTTYSB,MTCGSB			; TTY 25
	TPROC 3,4,MTTYSB,NULLSB			; TTY 26
	TSYM \MXTTTY

STATBR:	BR GLIBR		; MAIN PROGRAM LEVEL STATUS MESSAGE DAEMON
	MOV #GLDTTY*2,R3
	MOV TSTA(R3),R4
	MOV TI.PTR(R4),R5
	MOV STAMSG,R0
12$:	TST TI.BLK(R4)
	 BEQ 1$
	MOV R0,STAMSG
	MOV R5,TI.PTR(R4)
	CLRB @TI.FLG(R4)
	 JMP TESTLB		; (SINCE CHARACTERS ARE NOT DEPOSITED WITH INTERRUPTS
				; WAITPL HACKERY IS NOT NEEDED)
1$:	MOV (R0)+,(R5)+
	CMP R5,TI.END(R4)
	 BNE 3$
	 MOV TI.BEG(R4),R5
3$:	CMP R5,TI.LIM(R4)
	 BNE 4$
	INC TI.BLK(R4)
4$:	DEC STALEN
	 BNE 12$
	MOV #STLEN,STALEN	; CLEAN UP
	MOV #STMSG,STAMSG
	MOV R5,TI.PTR(R4)
	MOV SSTABR,STATBR
	CLRB @TI.FLG(R4)
	JMP TESTLB
.PAGE
GLIBR:	BR GLIBR		; MAIN PROGRAM ACTIVATION OF GOULD
				; (USEFUL ALSO FROM INTERRUPT LEVELS >= 5)
	TST GLERR
	BNE WAITPL		; SKIP IF GOULD ERROR
	MASK 5
	CALL GLDINT
	MOV SGLIBR,GLIBR	; CLEAN UP AND FALL THROUGH

WAITPL:	WAIT
	JMP TESTLB

SSTABR:	BR .+<GLIBR-STATBR>
SGLIBR:	BR .+<WAITPL-GLIBR>

.PAGE
.SBTTL  TTY INTERRUPT DISPATCH 

	INRTMC 0,INRTSB			; IMLAC		STANDARD RECEIVE INTERRUPT
	INRTMC 1,INRTSB			; TEKTRONIX	STANDARD RECEIVE INTERRUPT
	INRTMC 3,NULLSB			; GOULD		STANDARD RECEIVE INTERRUPT
					; DIGIVUE	KEYMUX   RECEIVE INTERRUPT
					; ANN ARBOR #1  KEYMUX   RECEIVE INTERRUPT
					; ANN ARBOR #2  KEYMUX   RECEIVE INTERRUPT


	INTTMC 0,INTTSB			; IMLAC		STANDARD TRANSMIT INTERRUPT
	INTTMC 1,INTTSB			; TEKTRONIX	STANDARD TRANSMIT INTERRUPT
	INTTMC 2,INTTSB			; ANN ARBOR	STANDARD TRANSMIT INTERRUPT
	INTTMC 3,NULLSB			; GOULD		STANDARD TRANSMIT INTERRUPT


.PAGE
.SBTTL  INTERRUPT HANDLERS 

;  FATAL INTERRUPT HANDLER 

CPUERR:
ILLOPR:
BPTTRP:
IOTTRP:
EMTTRP:
UUOH:
	HALT
 	JMP INIT		; SO CONTINUE WILL WORK

;  CLOCK HANDLER 

CLKHND:	BIC #200,%LKS
	TST EODFLG
	BEQ 3$
	TST GLIDL
	BNE 31$
	CLR CLKCNT		; GOULD NOT SETTLED YET
	RTI

3$:	BIC #100,%LKS		; SHOW'S OVER, GO HOME
	CLR CLKCNT
	RTI

31$:	INC CLKCNT		; COUNTDOWN TO INDICATE LOSS OF ENABLE STATUS ON GOULD
	CMP #GLDTIM,CLKCNT	; SHORT TIMEOUT (1/2 SECOND) FOR PAPER SMEAR
	BEQ 2$
	RTI

2$:	PUSH R4
	MOV GLPTR,R4
	MOV #100000,(R4)+
	MOV SMEARP,(R4)+
	MOV R4,GLPTR
	MOV R4,GTPTR
	CLRB GLIBR
	POP R4
	CLR CLKCNT
	BIC #100,%LKS
	RTI

CLKCNT:	.WORD 0

SMEARP:	.WORD SMRBLK

;  POWER FAIL HANDLER 

POWROF:	MOV #RSTALL,%PWRV
	HALT

RSTALL:	MOV #POWROF,%PWRV
	JMP INIT

.PAGE
;  INTERRUPT ROUTINE FOR RECEIVE INPUT FROM PDP-10 VIA DL-11 
;			DEVICE 0
VCRD0:	.WORD SLRD0		; VECTOR TO ONE OF THREE ROUTINES:
				;	(LINE SELECT, COUNT, CHARACTER OUT HANDLER)
CTRT0:	.WORD 0			; COUNT OF CHARACTERS REMAINING FOR THIS LINE
VCRT0:	.WORD 0			; VECTOR TO TTY STATUS TABLE

INRD0:	PUSH <R0,R1,R2>
	MOV RDBF0,R0		; PICK UP CHARACTER
	BPL 1$
	MOV R0,DLSTA1
	HALT			; BAD CHARACTER
1$:	JMP @VCRD0

DLSTA1:	.WORD 0

SLRD0:	BIT #200,R0		; SELECT LINE FOR INPUT
	 BEQ IN0XIT		; NO LINE SELECT WHEN EXPECTED, IGNORE IT.
1$:	BIC #200,R0		; CLEAR OUT LINE SELECT BIT
	CMP R0,#MAXTTY-1
	BLOS 2$
	HALT			; NON-EXISTENT TTY
2$:	ASL R0			; CONTRUCT INDEX TO PROPER INPUT QUEUE STATUS TABLE
	MOV RSTA(R0),VCRT0
	MOV #CTRD0,VCRD0
	POP <R2,R1,R0>
	RTI

CTRD0:	MOV R0,CTRT0
	BNE 1$
	HALT			; ZERO LENGTH STRING
1$:	MOV #PTRD0,VCRD0
	POP <R2,R1,R0>
	RTI

PTRD0:	MOV VCRT0,R1		; PLACE CHARACTER INTO INPUT QUEUE
	MOV RI.PTR(R1),R2
	MOVB R0,(R2)+		; THERE IT GOES ... (PLOP)
	CMP R2,RI.END(R1)
	BNE 1$
	MOV RI.BEG(R1),R2
1$:	CMP R2,RI.LIM(R1)
	BNE 2$
	HALT			; DATA OVERRUN, SCREWED ALLOCATION
2$:	MOV R2,RI.PTR(R1)
	DEC CTRT0
	BNE 3$
	MOV #SLRD0,VCRD0
3$:	CLRB @RI.FLG(R1)		; SIGNAL MAIN PROGRAM THAT A CHARACTER IS READY
	MOV #NOPIN,WAITPL
IN0XIT:	POP <R2,R1,R0>
	RTI

.PAGE
;  INTERRUPT ROUTINE FOR TRANSMIT OUTPUT TO PDP-10 VIA DL-11 

;NOTE: HAVE MTTY'S INDIRECT THROUGH TRANSMIT OUTPUT STATUS TABLE
; (IMPLIMENTS MANY TO ONE FUNCTION)

INTD0:	PUSH <R0,R1,R2>		; INTERRUPT TRANSMIT DEVICE 0
	MOV #TDST0,R1		; PICK UP POINTER TO STATUS TABLE FOR TRANSMIT DEVICE 0
	MOV OD.LIM(R1),R2	; PICK LOAD POINTER TO CHATACTER DATA
	MOVB (R2)+,R0		; PICK UP CHARACTER
	CMP R2,OD.END(R1)	; ARE WE AT END OF BUFFER
	BNE 1$
	MOV OD.BEG(R1),R2	; THEN CIRCLE AROUND TO THE BEGINNING
1$:	MASK 7			;	TO MAKE SURE NOTHING CAN CATCH US
				;	DISABLING INTERRUPTS WHILE STUFF PENDING
	CMP R2,OD.PTR(R1)	; HAVE WE CAUGHT UP WITH INSERTION POINTER?
	BNE 2$
	BIC #100,XDST0		; THEN TURN OFF INTERRUPT
2$:	UNMASK
	MOV R2,OD.LIM(R1)	; UPDATE POINTER
	MOV R0,XDBF0		; AND PUT OUT CHARACTER
	CLR OD.BLK(R1)
	POP <R2,R1,R0>
	RTI

.PAGE
;  INTERRUPT ROUTINE FOR INPUT FROM TTY 

INRTSB:	PUSH R0			; INPUT DEVICE INTERRUPT HANDLER
	MOV @RTBF(R3),R0	; PICK UP CHARACTER
	 BPL 1$
	MOV R0,DLSTA2		; SAVE BITS FOR A PORT MORTEM
	BR 2$			; SCREWED CHARACTER
1$:	BIC #200,R0		; GET RID OF THAT 8'TH BIT!
	CALL INRPUT
2$:	POP R0
	RET 

DLSTA2:	.WORD 0

INRPUT:	PUSH <R1,R2,R5>
	MOV TSTA(R3),R1		; PICK UP POINTER TO TRANSMIT STATUS TABLE 0
	TST TI.BLK(R1)
	 BEQ 2$
	CLRB @CG.FLG(R1)
	MOV RSTA(R3),R5
	INC MR.BLK(R5)
	 BR 5$
2$:	MOV TI.PTR(R1),R2
	MOV R0,(R2)+
	CMP R2,TI.END(R1)
	 BNE 3$
	MOV TI.BEG(R1),R2
3$:	CMP R2,TI.LIM(R1)
	BNE 4$
	INC TI.BLK(R1)
4$:	MOV R2,TI.PTR(R1)
	CLRB @TI.FLG(R1)
5$:	MOV #NOPIN,WAITPL
	POP <R5,R2,R1>
	RET

.PAGE
;  INTERRUPT ROUTINE FOR OUTPUT TO TTY 

INTTSB:	PUSH <R1,R2>
	MOV RSTA(R3),R1
	MOV RO.LIM(R1),R2
	MASK 7
	TST RO.BLK(R1)
	 BNE 1$
	CMP R2,RO.PTR(R1)
	 BNE 1$
	BIC #100,@XTST(R3)	; NOTHING MORE TO DO SO TURN INTERRUPT ENABLE OFF.
	UNMASK
	BR 3$

1$:	UNMASK
	CLR -(SP)		; ALLOCATE A SLOT ON THE PDL
	MOVB R3,1(SP)		; PUT CHANNEL NUMBER IN LH
	MOVB (R2)+,(SP)		; DATA IN RH
	MOV (SP)+,@XTBF(R3)
	CMP R2,RO.END(R1)
	 BNE 2$
	MOV RO.BEG(R1),R2
2$:	MOV R2,RO.LIM(R1)
	CLR RO.BLK(R1)
3$:
	POP <R2,R1>
	RET
.PAGE
;  KEYBOARD MULTIPLEXER INTERRUPT ROUTINE 
; CURRENTLY THE LINE ADDRESS IS THE LOW 3 BITS OF THE LEFT BYTE.
; EVENTUALLY IT IS INTENDED TO HAVE THE LINE ADDRESS BE IN THE SECOND DR11-L INPUT
; WORD AND A FULL 16-BITS OF DATA IN THE FIRST WORD.  A STATUS BIT OR ADDITIONALL
; DATA BITS IN THE LH OF WORD 2 WILL INDICATE WHETHER THE KEYBOARD IS THE SOURCE OF
; THE DATA OR NOT.
KEYSAV:	0

KEYINT:	PUSH <R0,R3,KEYBUF>		; PICK UP THE DATA

; NEXT 4 INSTR WILL EVENTUALLY BE: MOVB KEYADR,R3
	MOVB 1(SP),R3		; FIND TERMINAL ID FROM KEYBOARD ID
	BIC #MAXMUX,R3		; GET KEYBOARD ID
	ASL R3

	MOV KEYTAB(R3),R3	; FIND TTY LINE ASSOCIATED WITH THIS KBD
; FOR NOW ASSUME ALL LINES ARE KBD'S. LATER CHECK
	BIT #INVBIT,(SP)		; PROTECT AGAINST N KEY LOSSAGE
	 BNE 1$
	MOV (SP),KEYSAV		; FOR DEBUGGING
	POP <R0,R3,R0>
	RTI
1$:	MOVB (SP),R0
	BIC #MBYTE,R0		; FLUSH SIGN EXTENSION
	MOVB AIKTAB(R0),(SP)	; CONVERT KEY CODE BY TABLE LOOKUP

; THIS CODE WILL BE UNNECESSARY WHEN THE MUX IS FIXED
	MOVB 1(SP),R0		; NOW SET UP SPECIAL BITS
	ASR R0
	ASR R0
	ASR R0
	BIC #177774,R0
	BIT #20000,(SP)
	 BEQ 2$
	BIS #10,R0
2$:	MOVB R0,1(SP)
	POP R0
	CALL INRPUT
	POP <R3,R0>
	BIT #200,KEYSTA
	 BNE KEYINT
	RTI

; KEYBOARD VECTOR TABLE ( EACH ENTRY CONTAINS <TTY_CHANNEL_NUMBER>*2)

; KEYBOARD 0 -> ANN ARBOR (TTY 1)
; KEYBOARD 1 -> PLASMA DISPLAY (TTY 4)
; KEYBOARD 2 -> TEKTRONIX ALTERNATE (TTY 2)
; KEYBOARD 3 -> (TTY 5)

KEYTAB:	.WORD 0
	.WORD 2
	.WORD 4
	.WORD 4
	.WORD 4
	.WORD 4
	.WORD 4
	.WORD 4
	.BLKW 4	; LEAVE SPACE FOR TOTAL OF 8 ENTRIES
.PAGE
;  GOULD INTERRUPT HANDLER 

GLDINT:	PUSH <R0,R4,R5>
	MOV GTLIM,R4
GLDERR:	TST GLERR		; ARE WE ALREADY IN AN ERROR STATE?
	BNE 2$
	BIT #%GSERR,GLDCSR	; SHOULD WE GO TO AN ERROR STATE?
	BEQ 1$

	MOVB GLDCSR+1,STAERR		; YEP
	INC GLERR		; INFORM WORLD THAT GOULD IS IN TROUBLE
	INC PAGMNG		; COUNT OF PAGE MUNGING INCIDENTS
				; FOR END OF GOULD ERROR MONITOR
	CLRB STATBR		; TELL UNSPOOLR WHAT HAPPENED
	JMP GLIXIT

2$:	BIT #%GSERR,GLDCSR	; IS AN ERROR STILL PRESENT?
	BEQ 3$
	 JMP GLIXIT		; YEP

3$:	CLR GLERR		; NOPE, CLEAN UP
			; WE ARE ASSUMING THAT SELECTION IS PRESERVED WHEN SYSTEM
			; RESET IS ACHIEVED FOLLOWING MANUAL ERROR CORRECTION
			; (HOPEFULLY, THIS OCCURS WHEN THE PRINTER IS BROUGHT ON LINE)

1$:	JMP @GLIPTR

CMIDEC:	TST JMPFLG		; IF IN MIDDLE OF JUMP MACRO, SHOULD NOT
				; TEST FOR BUFFER LIMITS OR COMMAND COMPLETION
	 BNE 112$
	CMP R4,GLEND		; ARE WE EQUAL TO OR GREATER THAN THE END OF
				; THE FIRST BUFFER LIMIT?
	BLO 111$
	MOV GLBEG,R4		; THEN CIRCLE AROUND TO BEGINNING
111$:	TST REPFLG		; IF IN REPEAT, SHOULD NOT TEST COMMAND COMPLETION
	 BNE 1$
	MOV R4,GLLIM		; SUCCESSFUL COMPLETION OF A FULL COMMAND,
				; UPDATE POINTER THAT MAIN PROGRAM LOOKS AT

	CLR GLBLK		; IN CASE M.P. IS HUNG FOR LACK OF SPACE

1$:	CMP R4,GLPTR		; NOTHING LEFT TO DO?
	BNE 112$
	INC GLIDL		; COMPLAIN TO WORLD
	JMP GLIXIT

112$:	BIT #%GSPAP,GLDCSR	; IS GOULD RUNNING LOW ON PAPER?
	BEQ 11$
	MOVB GLDCSR+1,STAERR		; YEP
	CLRB STATBR		; TELL UNSPOOLER WHAT IS ABOUT TO HAPPEN

11$:	CLR GLIDL		; WE GOT SOMETHING TO DO
	MOV (R4)+,R0
	BMI 2$			; BRANCH IF INTERNAL MACRO COMMAND

14$:	CMP R0,#5		; IF LAST LINE FLAG, DON'T WANT TO WAIT FOR SBUSY
	BEQ 15$


	BIT #%GSBSY,GLDCSR
	BNE 12$			; BRANCH IF BUSY
15$:	SWAB R0
	TSTB R0			; TEST FOR DELAYED COMMAND
	BNE 4$

; IMMEDIATE GOULD COMMAND
	SWAB R0
	BIT #170,R0		; THE FOUR UNUSED BITS IN THE GOULD
				; COMMAND BYTE
	 BEQ 115$
	MOV #PAGLST,R5		; REQUEST FOR TAILSHEET PAGE MUNGING STATUS
	MOV PAGMNG,R0
	CALL CHRNUM
	CLR PAGMNG		; RESET FOR NEXT FILE
	 BR 116$
115$:	MOVB R0,GLDCSR
116$:	MOV #CMIDEC,GLIPTR
	 JMP CMIDEC

; DELAYED GOULD COMMAND
4$:	SWAB R0
	MOVB R0,GLDCSR
	MOV #CMIDEC,GLIPTR
	BR GLIXIT	

12$:	MOV R0,PNDR0
	MOV #13$,GLIPTR
	 BR GLIXIT
	
13$:	MOV PNDR0,R0
	BR 14$


2$:
; MOBY COMMAND
	BIT #17400,R0
	BNE 5$			; DMA COMMAND
	BIT #40000,R0		; REPEAT COMMAND
	BNE 3$
	BIT #20000,R0		; CURRENT PAGE COMMAND
	BNE 6$


; JMP COMING UP
	BIT #1,R0
	BEQ 21$

; POP
	MOV JMPRET,R4
	CLR JMPFLG
	 JMP CMIDEC

;PUSH
21$:	MOV (R4)+,R0		; PUT JUMP ADDRESS INTO R0
	MOV R4,JMPRET		; JMPRET IS ADDRESS AFTER JUMP COMMAND
	INC JMPFLG
	MOV R0,R4
	 JMP CMIDEC

3$:
; REPEAT COMING UP
	BIT #1,R0
	BEQ 31$

; POP
	DEC REPCNT
	 BNE 32$
	CLR REPFLG
	 JMP CMIDEC		; R4 IS LEFT POINT TO INSTRUCTION AFTER REPEAT LOOP

32$:
; ITERATE
	MOV REPRET,R4
	 JMP CMIDEC



;PUSH
31$:	MOV (R4)+,REPCNT	; REPEAT COUNT GOES INTO R0
	MOV R4,REPRET		; REPRET IS THE ADDRESS OF BEGINNING OF LOOP
	INC REPFLG
	 JMP CMIDEC

6$:
; CURRENT PAGE COMMAND COMING UP
	MOVB R0,STAPAG
	 JMP CMIDEC

5$:
; DMA COMMAND COMMING UP
	BIT #%GSDON,GLDCSR
	 BEQ 51$
	MOV R0,GLDWC		; COUNT
	MOV R4,GLDCA		; ADDRESS
	NEG R0
	ASL R0
	ADD R0,R4

53$:	BIT #%GSDON,GLDCSR
	 BEQ 52$
	MOV #CMIDEC,GLIPTR
	 JMP CMIDEC

52$:	MOV #53$,GLIPTR
	 BR GLIXIT

51$:	MOV #5$,GLIPTR
	 BR GLIXIT

GLIXIT:	MOV R4,GTLIM

	POP <R5,R4,R0>
	RTI

.PAGE
; INTERRUPT ROUTINES NOT YET DEFINED

PLPINT:	RTI		; PLASMA DISPLAY

IMLINT:	RTI		; IMLAC

NULL:	RTI		; DUMMY


.PAGE
.SBTTL MAIN PROGRAM QUEUE PROCESSING ROUTINES
;  MAIN PROGRAM ROUTINE FOR RECEIVED CHARACTER PROCESSING 

MRTYSB:	MOV RSTA(R3),R1		; CREATE POINTER TO RECEIVE STATUS BLOCK
	TST RO.BLK(R1)
	 BNE 3$
	TST MR.BLK(R1)
	 BEQ 4$
3$:	ADD #4,(SP)
	RET

4$:	TST RS.CNT(R1)		; CHECK FOR BUFFERED CHARS
	 BEQ RCHGET

RTSTRH:	MOVB @RS.PTR(R1),R0
	DEC RS.CNT(R1)
	 BNE 1$
	MOV RSTR(R3),RS.PTR(R1)
	BR RCHPUT
1$:	INC RS.PTR(R1)
	BR RCHPUT
.PAGE

RCHGET:	MOV RI.LIM(R1),R2
	MOVB (R2)+,R0		; PICK UP CHARACTER
	CMP R2,RI.END(R1)	; ARE WE AT THE END OF THE BUFFER?
	 BNE 1$
	MOV RI.BEG(R1),R2	; CIRCLE AROUND TO BEGINNING THEN
1$:	MOV R2,RI.LIM(R1)	; UPDATE POINTER

	DEC ALNUM(R3)		; UPDATE ALLOCATION
	 BGT 2$
	JMP INIT			; ALLOCATION SCREWED
2$:	CMP ALNUM(R3),#ALCLIM	; NEED TO ALLOCATE CHARACTERS?
	 BGE 20$
	CALL ALLCSB		; CALL ALLOCATION SUBROUTINE

20$:	TST RO.ESF(R1)		; WAITING FOR AN ESCAPE CHAR?
	 BEQ 3$			; NOPE
	TST JMPESC(R1)		; WAITING FOR CURSOR POSITION ESCAPE?
	 BEQ 21$
	JMP @JMPESC(R1)

21$:	BIC #MASK37,R0		; GET THE ESSENTIALS OF THE CODE
	ASL R0			; DONT NEED R0 ANYMORE.
	JMP @VT52TB(R0)

3$:	CMP R0,RO.ESC(R1)	; ESCAPE CHAR?
	 BNE 31$
	INC RO.ESF(R1)		; JUST SET A FLAG.  DON'T STUFF CHAR.
	BR MORECK

31$:	CMP #40,R0		; CONTROL CHAR?
	 BLE 32$
	MOV R0,R2		; SAVE R0 FOR USE UPON RETURN FROM CONTROL CHAR ROUTINES
	ASL R2
	JMP @AACTLT(R2)

32$:	INC COL(R1)		; ORDINARY CHARS COME HERE.
.PAGE

RCHPUT:	MOV RO.PTR(R1),R2
	MOVB R0,(R2)+		; PUT THE CHAR INTO THE RECEIVE OUTPUT BUFFER
	CMP R2,RO.END(R1)	; ARE WE AT THE END OF THE BUFFER?
	 BNE 1$
	MOV RO.BEG(R1),R2	; CIRCLE AROUND TO BEGINNING THEN
1$:	CMP R2,RO.LIM(R1)	; FROM HERE ON, THERE SHOULD BE SOME OUTPUT TO GO OUT
	 BNE MORECK
	INC RO.BLK(R1)		; BLOCK QUEUE

MORECK:	MASK 7			; DONT ALLOW TRANSMIT INTERRUPTS NOW
	TST RS.CNT(R1)
	 BNE 1$			; MORE CHARS LEFT IN THE STRING BUFFER.
	CMP RI.LIM(R1),RI.PTR(R1)
	 BNE 1$			; STILL HAVE CHARS WAITING TO BE PROCESSED
	MOV SRTY(R3),@MRTY(R3)	; NO CHARS PENDING PATCH UP BRANCH INSTRUCTION
1$:	TST RO.ESF(R1)
	 BNE 3$			; JUST WAITING FOR MORE CHARS.  NO OUTPUT YET.
	MOV R2,RO.PTR(R1)	; UPDATE POINTER
	MOV #WAITIN,WAITPL	; PATCH WAIT INSTRUCTION
	BIT #100,@XTST(R3)	; INTERRUPTS ENABLED?
	 BNE 3$			; YES
	CALL INTTSB		; NO, GET THE BALL ROLLING
	BIS #100,@XTST(R3)	; ACTIVATE INTERRUPT FOR OUTPUT TO DEVICE
3$:	UNMASK			; INTERRUPTS CAN HAPPEN NOW.
	RET

.PAGE
; ANN ARBOR ESCAPE HANDLERS
AANOOP:	CLR R0
	BR AACPUT

AAMVUP:	MOV #16,R0		; MOVE UP
	DEC ROW(R1)
	BR AACPUT

AAMVDN:	MOV #12,R0		; MOVE DOWN
	INC ROW(R1)
	BR AACPUT

AAMVRT:	MOV #11,R0		; MOVE RIGHT
	INC COL(R1)
	BR AACPUT

AAMVLF:	MOV #10,R0		; MOVE LEFT
	DEC COL(R1)
	BR AACPUT

AAHOME:	MOV #13,R0		;  HOME UP
	CLR ROW(R1)
	CLR COL(R1)
;	BR AACPUT

AACPUT:	CLR RO.ESF(R1)
	JMP RCHPUT

.PAGE
AAEOL:	MOV RS.PTR(R1),R4	; CLEAR TO END OF LINE
	CALL CPOSDO
	MOV #80.,R2
	SUB COL(R1),R2
	CALL EOLDO
	BR AADONE

AAEOS:	TST ROW(R1)		; CLEAR TO END OF SCREEN
	 BNE 1$
	TST COL(R1)
	 BNE 1$
	MOV #14,R0
	BR AACPUT

1$:	MOV RS.PTR(R1),R4
	MOV #24.,R5
	SUB ROW(R1),R5
	MOV #80.,R2
	SUB COL(R1),R2

2$:	CALL EOLDO
	MOV #80.,R2		; ASSUME WRAPAROUND TO NEXT LINE HAS HAPPENED 
	DEC R5
	 BGT 2$

AADONE:	CALL CPOSDO		; RESTORE THE CURSOR POSITION
	CLR RO.ESF(R1)
	JMP RTSTRH

EOLDO:	ADD R2,RS.CNT(R1)
1$:	MOVB #40,(R4)+			; SPACE
	DEC R2
	 BGT 1$
	RET
.PAGE

AAPOS:	MOV #AAPOS1,JMPESC(R1)		; ABSOLUTE CURSOR POSITION
	JMP MORECK				; ALL WE GOT SO FAR IS $Y

AAPOS1:	SUB #40,R0			; GOT THE ROW
	MOV R0,ROW(R1)
	MOV #AAPOS2,JMPESC(R1)		; WAIT FOR THE COLUMN
	JMP MORECK

AAPOS2: SUB #40,R0			; GOT THE COLUMN
	MOV R0,COL(R1)
	MOV RS.PTR(R1),R4
	CALL CPOSDO
	CLR JMPESC(R1)
	CLR RO.ESF(R1)
	JMP RTSTRH

CPOSDO:	MOVB #%AAPOS,(R4)+		; PUT THE CURSOR POS COMMAND CODE
	MOV COL(R1),R0			; FORMAT THE COLUMN
	CLR R5
1$:	SUB #10.,R0			; DIVIDE BY 10 (DAMN BCD FORMAT!!)
	BLT 2$
	INC R5
	BR 1$
2$:	ADD #10.,R0			; R0 HAS REMAINDER, R5 THE QUOTIENT
	.REPT 4				; SHIFT LEFT 4 BITS TO GET BCD
	ASL R5
	.ENDR
	ADD R5,R0
	MOVB R0,(R4)+
	MOV ROW(R1),R0			; FORMAT THE ROW
	BIS #100,R0
	MOVB R0,(R4)+
	ADD #3,RS.CNT(R1)
	RET				; SOMEONE ELSE RESTORES RS.PTR

.PAGE

; CONTROL CHAR ROUTINES
AACTRL:	BR AACXIT

AABELL:	BR AACXIT

AABS:	DEC COL(R1)
	BR AACXIT

AATAB:	ADD #8.,COL(R1)
	BIC #7,COL(R1)
	CMP #79.,COL(R1)
	 BGE 1$
	MOV #79.,COL(R1)
1$:	MOV RS.PTR(R1),R4
	CALL CPOSDO
;	MOV RSTR(R3),RS.PTR(R1)
	JMP RTSTRH

AALF:	INC ROW(R1)
	BR AACXIT

AAVT:	DEC ROW(R1)
	BR AACXIT

AAFF:	CLR ROW(R1)
	CLR COL(R1)
	BR AACXIT

AACR:	CLR COL(R1)
;	BR AACXIT

AACXIT:	JMP RCHPUT

.PAGE
;  MAIN PROGRAM ROUTINE FOR TRANSMITED CHARACTER PROCESSING 

MTTYSB:	MOV TSTA(R3),R1
	TST MT.BLK(R1)
	 BNE 1$
	TST @TO.BLK(R1)		; IS OUTPUT BLOCKED
	 BEQ 2$
1$:	ADD #4,(SP)		; YEP, PRETEND NOTHING HAPPENED
	RET
2$:	TST TS.CNT(R1)
	 BEQ TCHGET

; TEMPORARY STRING HANDLER
TTSTRH:	MOV @TS.PTR(R1),R0
	DEC TS.CNT(R1)
	 BNE 1$
	MOV TSTR(R3),TS.PTR(R1)
	CLR AL.BLK(R1)
	BR TCHPUT
1$:	ADD #2,TS.PTR(R1)
	BR TCHPUT

; CURRENT FORMAT OF CHARACTER DATA WORD (WILL BE CHANGED FOR NEW INPUT MUXER
; AND DMA IMLAC INTERFACE).
; %MXDAT=100000		THIS DATA CAME FROM THE INPUT MULTIPLEXOR
; MASCII=177600		ASCII PART OF THE DATA
; %SPKEY=200		SPECIAL KEY
; %SBITS=MASK37		SPECIAL BITS
; %SHLOK=10		SHIFT LOCK (INPUT)
; IN THE INPUT WORD, THE BITS BELOW ARE LSH'D 1 (SO THEY ALL APPEAR IN THE HIGH BYTE)
; IN THE OUTPUT SEQUENCE, THE LEFT BYTE HAS 100 ADDED TO IT.
; %TXTOP=4000		TOP BIT
; %TXSFL=2000		SHIFT LOCK
; %TXSHT=1000		SHIFT
; %TXMTA=400		META
; %TXCTL=200		CONTROL
.PAGE
TCHGET:	MOV TI.LIM(R1),R2
	MOV (R2)+,R0
	CMP R2,TI.END(R1)
	 BNE 1$
	MOV TI.BEG(R1),R2
1$:	MOV R2,TI.LIM(R1)

	BIT #%SPKEY,R0		; CHECK FOR SPECIAL CODES (> 177)
	 BEQ 2$
	BIC #MASK37,R0		; GET THE ESSENTIAL BITS
	ASL R0
	JMP @SKEYTB(R0)		; GO DO SOMETHING SPECIAL

2$:	CMP R0,#CBSL		; CNTL BACKSLASH?
	 BNE 3$
	MOV TS.PTR(R1),R2
	MOV R0,(R2)+		; QUOTE IT
	MOV R0,(R2)+
	MOV #2,TS.CNT(R1)
;	MOV TSTR(R3),TS.PTR(R1)
	INC AL.BLK(R1)
	BR TTSTRH

3$:	MOV R0,R2
	SWAB R2
	BIC #%SBITS,R2		; ANY META, CNTL, TOP, ETC. STUFF?
	 BEQ TCHPUT		; NO
	BIS #100,R2
	PUSH R2			; CONSTRUCT TEMPORARY CHARACTER STRING FOR SPECIAL
	BIC #MASCII,R0
	BIT #%SHLOK,R2		; SHIFT LOCK HACKERY
	 BEQ 4$
	BIT #100,R0		; TEST FOR ALPHABETIC CHARS
	 BEQ 4$
	MOV R0,R2
	BIC #MASK37,R2
	 BEQ 4$
	CMP #33,R2
	 BLE 4$
	MOV #40,R2
	BIC R2,R0		; CLEAR THE 40 BIT
	
4$:	MOV TS.PTR(R1),R2	; CHARACTER ESCAPE SEQUENCE
	MOV #CBSL,(R2)+
	MOV (SP)+,(R2)+		; POP (R5)+
	MOV R0,(R2)+
	MOV #3,TS.CNT(R1)
;	MOV TSTR(R3),TS.PTR(R1)
	INC AL.BLK(R1)
	BR TTSTRH
.PAGE
TCHPUT:	MOVB TTYNUM(R1),-(SP)	; CONSTRUCT CHARACTER MESSAGE (CHARACTER,,LINE SELECT)
	BIC #%SPKEY,R0		; DONT SEND 8 BIT CHARS!!
	MOVB R0,1(SP)
	MOV @TO.PTR(R1),R2
	MOV (SP)+,(R2)+
	CMP R2,@TO.END(R1)
	 BNE 1$
	MOV @TO.BEG(R1),R2

1$:	CMP R2,@TO.LIM(R1)	; SEE IF OUTPUT IS NOW BLOCKED
	 BNE 2$
	INC @TO.BLK(R1)		; YES, SO SET INDICATOR

2$:	MASK 7			; INTERRUPT SENSITIVE CODE
	TST TS.CNT(R1)
	 BNE 3$			; THERE IS STILL MORE TEMPORARY STRING STUFF TO DO.
	CMP TI.LIM(R1),TI.PTR(R1)
	 BNE 3$			; THERE ARE MORE INPUT CHARS BUFFERED.
	MOV STTY(R3),@MTTY(R3)	; NOTHING LEFT TO DO.

3$:	MOV R2,@TO.PTR(R1)	; UPDATE THE OUTPUT POINTER NOW
	CLR TI.BLK(R1)
	MOV #WAITIN,WAITPL
	BIS #100,XDST0		; ENABLE INTERRUPTS
	UNMASK
	RET

.PAGE
.SBTTL  SPECIAL KEY HANDLERS

NONAS1:
KBRK:	JCALL INTYSB
KESC:
KCALL:
KCLEAR:
KDEL:
KCIRM:
KGRAD:
KCIRP:
KBACK:
KNEXT:
KHELP:
KFORM:
KBS:
KVT:
KCR:
KLINE:
FDELT:
KRPT:
KTAB:
KSPACE:
KNOOP:	MASK 7			; INTERRUPT SENSITIVE CODE
	CMP TI.LIM(R1),TI.PTR(R1)
	 BNE 1$			; THERE ARE MORE INPUT CHARS BUFFERED.
	MOV STTY(R3),@MTTY(R3)	; NOTHING LEFT TO DO.
1$:	CLR TI.BLK(R1)
	MOV #WAITIN,WAITPL
	UNMASK
	RET

.PAGE
.SBTTL GOULD MAIN PROGRAM ROUTINE 

MRGLSB:	MOV RSTA(R3),R1
;	TST MR.BLK(R1)		; NOTHING SHOULD SET THIS
;	 BNE 11$
;	TST RO.BLK(R1)		; UNNECESSARY UNTIL WE GET A CONSOLE DEVICE
;	 BNE 11$
	TST GLBLK		; OUTPUT QUEUE FILLED
	 BNE 11$
	TST GLERR		; IN THE MIDST OF SOME ERROR
	 BEQ 10$
11$:	ADD #4,(SP)
	RET

10$:	MOV RI.LIM(R1),R2
	MOV GTPTR,R4		; TEMPORARY POINTER (NECESSARY SINCE ITEMS
				; IN QUEUE HAVE "WIDTH")

JMPDEC:	JMP @GLDPND		; DISPATCH TO ANY PENDING OPERATIONS DUE TO GL QUEUE
				; BLOCKAGE (DEFAULT IS CHRDEC)

CHRDEC:	DEC ALNUM(R3)
	BGT 4$
	HALT
4$:	MOVB (R2)+,R0		; PICK UP CHARACTER
	BPL DATHAC		; SKIP AROUND IF CHARACTER IS NOT AN EIGHT BIT CODE
	TST QOTFLG		; IS THIS CHARACTER TO BE QUOTED?
	 BEQ 2$
	CLR QOTFLG		; YEP, PASS IT ON
	BR DATACH
2$:	CMPB R0,#%CCACK		; ARE WE BEING PAGED?
	 BNE HERE
	MOVB GLDCSR+1,STAERR
	CLRB STATBR		; RESPOND WITH STATUS (ACTIVATE DAEMON)
	 JMP GLOOP

HERE:	CMPB R0,#%CCSOD		; START OF DATA?
	BNE 4$
	CLR EODFLG		; YEP, FLAG START OF DATA
	 JMP GLOOP
4$:	TST EODFLG		; ARE WE RECEIVING RANDOM CHARACTERS?
	 BEQ 51$
	 JMP GLOOP		; FORGET THEM
51$:	CMPB R0,#%CCQOT		; SHOULD WE QUOTE THE NEXT CHARACTER?
	 BNE 5$
	INC QOTFLG		; YEP
	 JMP GLOOP
5$:	CMPB R0,#%CCEOD		; END OF DATA?
	 BNE DATACH
	INC EODFLG		; YEP, FLAG END OF DATA
	BIS #100,%LKS 		; START UP CLOCK (COUNT DOWN FOR SMEAR PAGE)
	 JMP GLOOP
.PAGE
DATHAC:	TST EODFLG		; NON EIGHT BIT CODE, IS IT RANDOM DATA?
	BEQ DATACH
	JMP GLOOP

DATACH:	JMP @WRDPTR		; MUST BE DATA THEN

MAKWD1:	MOVB R0,TMPWRD		;FIRST PIECE OF WORD
	MOV #MAKWD2,WRDPTR
	 JMP GLOOP

MAKWD2:	MOVB R0,TMPWRD+1	;SECOND PIECE OF WORD
	MOV #MAKWD1,WRDPTR

	JMP @GLDPTR		; DISPATCH TO PROPER COMMAND HANDLER

DATDEC:	TST TMPWRD		; COMMAND OR LINE BUFFER?
	 BMI COMDEC
	 JMP DMADEC		; BIT 15 NOT SET, LINE BUFFER


.PAGE
.SBTTL GOULD COMMAND PROCESSING
;  COMMAND DECODING 


COMDEC:	BIC #100000,TMPWRD	; REMOVE COMMAND BIT
	MOV R4,R5
	ADD #4,R5		; ADD 4, R5 POINTS TO LAST LOCATION IN POTENTIAL COMMAND

	BIS #PRIOR7,%PS		;MASK
	CMP GTPTR,GLLIM		; ARE WE AHEAD OF PICK UP POINTER ANYWAY?  (THEN OK)
	BHIS 2$
	CMP R5,GLLIM		; IF WE GO THROUGH WITH THIS COMMAND, WILL WE
				; LAP OTHER POINTER?  (THEN NOT OK)
	BLO 2$
	INC GLBLK		; GL QUEUE IS BLOCKED, WAIT FOR QUEUE TO EMPTY A LITTLE
	BIC #PRIOR0,%PS
	MOV #COMDEC,GLDPND	; AND MAKE SURE WE WIND UP IN THE RIGHT PLACE ON RETURN
	 JMP GLDXIT
2$:	BIC #PRIOR0,%PS		; NO PROBLEM
	MOV #CHRDEC,GLDPND

	BIT #40000,TMPWRD	; MACRO BIT TEST
	 BEQ DLYTST		; NOPE, IS STANDARD OR PSEUDO COMMAND

; GOULD MACRO COMMANDS
	MOVB TMPWRD,UPWORD	; UP COMING PAGE NUMBER
	MOVB TMPWRD+1,R0
	BIC #177700,R0	
	ASR R0
	ASR R0
	ASR R0
	MOV UPWORD,(R4)+
	MOV #100000,(R4)+
	MOV MACTAB(R0),(R4)+
	ASR R0
	MOV R0,GRFFLG
	CMP R0,#3
	BNE 4$
	CLR GRFFLG
4$:	 JMP GLDFIN		; COMPLETION OF COMMAND
	
MACTAB:	.WORD SALBLK
	.WORD SLGBLK
	.WORD SHGBLK
	.WORD EOFBLK

UPWORD:	.WORD 120000

.PAGE
; NORMAL GOULD COMMANDS

;DETERMINE IF THIS IS A DELAYED COMMAND
DLYTST:	BIT #200,TMPWRD		; LINE ADVANCE OR HOME? (OR PSEUDO COMMAND)
	 BNE DLAYCM
	CMPB #%GCON,TMPWRD	; ENABLE?
	 BEQ DLAYCM
	TSTB TMPWRD		; FEED?
	BEQ DLAYCM

;IF WE GOT TO HERE, MUST BE AN IMMEDIATE COMMAND
	CMPB #%GCGRF,TMPWRD	; GRAPHIC SELECT?
	 BNE 1$
	INC GRFFLG
1$:	CMPB #%GCOFF,TMPWRD	; DISABLE?
	 BNE 2$
	CLR GRFFLG		; CLEAR MODE SELECTION
2$:	CLRB TMPWRD+1		; IMMEDIATE COMMAND SIGNIFIED BY 0 IN BYTE 1
	MOV TMPWRD,(R4)+
	 JMP GLDFIN		; COMPLETION OF A COMMAND

DLAYCM:	BIT #100,TMPWRD
	BEQ HERE4

; REQUEST FOR REPEAT, IN ACTUALITY
	BIT #2,TMPWRD
	BNE 1$

; START OF REPEAT
	MOV #140000,(R4)+
	MOV #REPTRN,GLDPTR	; WE NEED ANOTHER WORD HERE (THE REPEAT COUNT)
	 JMP GLDXIT

; END OF REPEAT
1$:	MOV #140001,(R4)+
	 JMP GLDFIN		; COMPLETION OF A COMMAND

REPTRN:	MOV TMPWRD,(R4)+
	MOV #DATDEC,GLDPTR
	 JMP GLDFIN		; COMPLETION OF A COMAND


HERE4:	MOVB #1,TMPWRD+1	; DELAYED COMMAND SIGNIFIED BY 1 IN BYTE 1
	MOV TMPWRD,(R4)+
	JMP GLDFIN		; COMPLETION OF A COMMAND

;  DMA BUFFER DECODING 


DMADEC:	TST GRFFLG
	BEQ ALPHAM		; MUST BE ALPHA MODE

;  GRAPHICS MODE 

GRAPHM:	BIT #200,TMPWRD		; RUN LENGTH ENCODED?
	 BEQ IMAGE
	 JMP RUNLEN		; YEP
.PAGE
.SBTTL  GOULD IMAGE MODE DATA HANDLING

IMAGE:	MOVB TMPWRD,DATLEN	; LENGTH OF DATA
	MOVB TMPWRD+1,R5
	MOV R5,MARLEN		; LENGTH OF MARGIN
	ADD DATLEN,R5		; TOTAL SIZE OF BUFFER (IN WORDS)
	MOV R5,MARLN1		; SAVE FOR DMA COUNT
	ASL R5			; NOW IN BYTES
	ADD R4,R5
				; LOCATION OF PROPOSED BUFFER

	BIS #PRIOR7,%PS		; MASK
	CMP R4,GLLIM		; ARE WE AHEAD OF PICK UP POINTER ANYWAY? (THEN OK)
	BHIS 4$
	CMP R5,GLLIM		; IF WE GO THROUGH WITH THIS BUFFER, WILL WE
				; LAP THE OTHER POINTER? (THEN NOT OK)
	BLO 4$
	INC GLBLK		; BLOCKED OUTPUT, WAIT FOR QUEUE TO EMPTY A LITTLE
	BIC #PRIOR0,%PS		; UNMASK
	MOV #IMAGE,GLDPND	; MAKE SURE WE COME BACK TO THE RIGHT PLACE
	 JMP GLDXIT		; NEED MORE SPACE

4$:	BIC #PRIOR0,%PS		; NO PROBLEM
	MOV #CHRDEC,GLDPND	; WE HAVE ENOUGH SPACE NOW

	NEG MARLN1		; NEGATION OF TOTAL SIZE OF BUFFER
	MOV MARLN1,(R4)+	; WORD COUNT HEADER FOR DMA COMMAND
	TST MARLEN		; ZERO MARGIN?
	BEQ 2$
1$:	CLR (R4)+
3$:	DEC MARLEN
	BNE 1$
2$:	MOV #IMTRAN,GLDPTR
	 JMP GLDXIT		; NEED MORE WORDS (REST OF LINE BUFFER)


IMTRAN:	MOV TMPWRD,(R4)+
	DEC DATLEN
	 BEQ 2$
	 JMP GLDXIT		; IF MORE IMAGE DATA COMING (NEED MORE WORDS)
2$:	MOV #DATDEC,GLDPTR	; DON'T NEED ANY MORE WORDS
	 JMP GLDFIN		; COMPLETION OF COMMAND
.PAGE
.SBTTL  GOULD ALPHA MODE DATA HANDLING

ALPHAM:	MOVB TMPWRD,R5
	MOV R5,DATLEN
	MOV R5,DATLN1
	ASL R5
	ADD R4,R5


	BIS #PRIOR7,%PS		;MASK
	CMP R4,GLLIM		; ARE WE AHEAD OF PICK UP POINTER ANYWAY? (OK)
	BHIS 2$
	CMP R5,GLLIM		; IF WE GO THROUGH WITH THIS BUFFER, WILL WE
				; LAP OTHER POINTER? (NOT OK)
	BLO 2$
	INC GLBLK		; BLOCKED OUTPUT, WAIT FOR QUEUE TO EMPTY A LITTLE
	BIC #PRIOR0,%PS		;UNMASK
	MOV #ALPHAM,GLDPND	; MAKE SURE WE COME BACK HERE (NEED MORE SPACE)
	 JMP GLDXIT
2$:	BIC #PRIOR0,%PS		;UNMASK, NO PROBLEM
	MOV #CHRDEC,GLDPND	; WE'VE GOT THE SPACE NOW

	NEG DATLN1
	MOV DATLN1,(R4)+
	MOV #ALPTRN,GLDPTR	; GOBBLE WORDS FOR BUFFER
	 JMP GLDXIT

ALPTRN:	MOV TMPWRD,(R4)+
	DEC DATLEN
	 BEQ 2$
	 JMP GLDXIT		; WE NEED MORE WORDS
2$:	MOV #DATDEC,GLDPTR
	 JMP GLDFIN		; COMPLETION OF COMMAND

.PAGE
.SBTTL  GOULD RUN LENGTH ENCODING MODE DATA HANDLING

RUNLEN: MOVB TMPWRD,ENCLEN
	BIC #STRIP,ENCLEN	; WORD COUNT OF RUN LENGTH ENCODED DATA
	MOV #RUNLN2,GLDPTR	; WE NEED ANOTHER WORD OF COMMAND
	 JMP GLDXIT

RUNLN2:	CLR COLOR
	MOVB TMPWRD,MARLEN
	 BPL 1$
	INC COLOR
	BIC #STRIP,MARLEN	; LENGTH OR MARGIN (IN WORDS)
1$:	MOVB TMPWRD+1,R5
	BIC #STRIP,R5		; LENGTH OF DECODED BUFFER, LESS MARGIN
	ADD MARLEN,R5		; TOTAL LENGTH OF BUFFER (IN WORDS)
	MOV R5,DATLEN
	ASL R5			; NOW IN BYTES
	ADD R4,R5

	BIS #PRIOR7,%PS		;MASK
	CMP R4,GLLIM		; ARE WE AHEAD OF PICK UP POINTER ANYWAY? (OK)
	BHIS 2$
	CMP R5,GLLIM		; IF WE GO THROUGH WITH THIS BUFFER, WILL WE
				; LAP OTHER POINTER (NOT OK)
	BLO 2$
	INC GLBLK		; BLOCKED OUTPUT, WAIT FOR QUEUE TO EMPTY A LITTLE
	BIC #PRIOR0,%PS		;UNMASK
	MOV #RUNLN2,GLDPND
	 JMP GLDXIT
2$:	BIC #PRIOR0,%PS		;UNMASK, NO PROBLEM
	MOV #CHRDEC,GLDPND	; WE'VE GOT ENOUGH SPACE NOW

	MOV #RUNTRN,GLDPTR
	NEG DATLEN
	MOV DATLEN,(R4)+	; WORD COUNT, DMA COMMAND HEADER
	CLR DATLEN
	TST MARLEN
	BEQ 3$			; ZERO LENGTH MARGIN?
	TST COLOR
	BEQ 21$			; IF COLOR = 0, THEN WHITE MARGIN
22$:	MOV #177777,(R4)+
	DEC MARLEN
	BNE 22$
	BR 3$

21$:	CLR (R4)+
	DEC MARLEN
	BNE 21$

3$:	 JMP GLDXIT		; NEED MORE WORDS
.PAGE
RUNTRN:	MOVB TMPWRD,R5
	BPL 1$
	BIC #STRIP,R5
	 BEQ 4$
2$:	MOVB #177777,(R4)+
	DEC R5
	 BNE 2$
	 BR 4$

1$:	 BEQ 4$
3$:	CLRB (R4)+
	DEC R5
	 BNE 3$

4$:	MOVB TMPWRD+1,(R4)+
	DEC ENCLEN
	 BEQ 41$
	 JMP GLDXIT		; STILL NEED MORE WORDS

41$:	MOV #DATDEC,GLDPTR
	 JMP GLDFIN		; COMPLETED COMMAND


.PAGE
GLDFIN:	CMP R4,GLEND
	BLO 1$
	MOV GLBEG,R4
1$:	CMP R4,GLLIM
	BNE 2$
	INC GLBLK
2$:	MOV R4,GLPTR
	MOV R4,GTPTR
	TST GLIDL		; IS THE GOULD IDLE?
	BEQ GLOOP
	MASK 5			; FAKE AN INTERRUPT
	CALL GLDINT		; GO TO HANDLER WITH ANXIOUSLY AWAITED CRUFT
	BR GLOOP

GLDXIT:	MOV R4,GTPTR

GLOOP:	CMP R2,RI.END(R1)	; END OF INPUT QUEUE?
	 BNE 1$
	MOV RI.BEG(R1),R2	; CIRCLE AROUND TO BEGINNING
1$:	MOV R2,RI.LIM(R1)
	CMP ALNUM(R3),#ALCLIM
	BGE 5$
	CALL ALLCSB
	INC GLDALC		; NECESSARY, ELSE GOULD LOCKS OUT ITS OWN ALLOCATER
5$:	BIS #PRIOR7,%PS
	CMP R2,RI.PTR(R1)
	 BEQ 3$
	BIC #PRIOR0,%PS
;	TST RO.BLK(R1)
;	 BNE 6$			; UNNECESSARY UNTIL CONSOLE DEVICE EXISTS
	TST GLBLK
	 BNE 6$
	TST GLDALC
	 BNE 7$
	 JMP JMPDEC

7$:	CLR GLDALC
	 BR 8$

3$:	MOV SRTY(R3),@MRTY(R3)
	BIC #PRIOR0,%PS

6$:	MOV #WAITIN,WAITPL
8$:	RET


.PAGE
.SBTTL  PREDEFINED  GOULD MACRO BLOCKS 

			; ALPHA MODE SELECT
SALBLK:	.WORD 4			; DISABLE
	.WORD 403		; ENABLE
	.WORD 2			; CUT
	.WORD 100001		; POPJ
SALEND:

			; LOW SPEED GRAPHICS MODE SELECT
SLGBLK:	.WORD 4			; DISABLE
	.WORD 1			; GRAPHIC COMMAND
	.WORD 5			; LAST LINE FLAG
	.WORD 403		; ENABLE
	.WORD 2			; CUT
	.WORD 100001		; POPJ
SLGEND:

			; HIGH SPEED GRAPHICS MODE SELECT
SHGBLK:	.WORD 4			; DISABLE
	.WORD 1			; GRAPHIC COMMAND
	.WORD 403		; ENABLE
	.WORD 2			; CUT
	.WORD 100001		; POPJ
SHGEND:


			; EOF OF FILE
EOFBLK:	.WORD 2			; CUT	------|
				;	      |
	.WORD 4			; DISABLE     |
	.WORD 403		; ENABLE      |
				;       <-----|
	.WORD 601		; LINE ADVANCE
	.WORD 140000		; REPEAT 12 (OCTAL) TIMES
	.WORD 12
	.WORD -102			; DMA COUNT
	.REPT 102
	.NLIST
	.WORD 36475		; DOUBLE DASH
	.LIST
.ENDR
	.WORD 140001		; END OF REPEAT
;	.WORD 100		; END OF FILE INDICATOR
;	.WORD -22			; DMA COUNT
;	.ASCII /          /
;	.BLKW 3
;PAGLST:	.ASCII /  O(TCLA )APEG SAB D/	;  (OCTAL) PAGES BAD
	.WORD 140000		; REPEAT 12 (OCTAL) TIMES
	.WORD 12
	.WORD -102			; DMA COUNT
	.REPT 102		; DOUBLE DASH
	.NLIST
	.WORD 36475
	.LIST
.ENDR
	.WORD 140001		; END OF REPEAT

	.WORD 100001		; JMP TO WHERE WE WERE BEFORE
EOFEND:
PAGLST:	.BLKW 40		; TEMPORARY
.PAGE

			; SMEAR PROTECTION PAGE
SMRBLK:	.WORD 4			; DISABLE
	.WORD 403		; ENABLE
	.WORD 2			; CUT
	.WORD 140000		; START REPEAT
	.WORD 25		;	25 (OCTAL) TIMES
	.WORD -1		; DMA COUNT
	.WORD 20040		; DOUBLE SPACE
	.WORD 140001		; END REPEAT
	.WORD 100001		; END JUMP
SMREND:
.PAGE
.SBTTL NUMBER TO STRING CONVERSION ROUTINE

CHRNUM:	PUSH <R1,R4>
	MOV #5,R4
1$:	MOV R0,R1
	BIC #177770,R1
	ADD #60,R1
	MOVB R1,-(R5)
	DEC R4
	BEQ 2$
	ASR R0
	ASR R0
	ASR R0
	BR 1$
2$:	TST R0
	BMI 3$
	MOVB #60,-(R5)
	 BR 4$
3$:	MOVB #61,-(R5)
4$:	SWAB (R5)+		; GOULD LIKES 'EM BACKWARDS
	SWAB (R5)+
	SWAB (R5)+
	POP <R4,R1>
	RET


.PAGE
.SBTTL ALLOCATION AND ^G M.P. MESSAGE HANDLERS
;  MAIN PROGRAM ROUTINE FOR ALLOCATION MESSAGE HANDLING 

; AL.BLK SET FOR 12 BIT CODE EXPANSION AND ^\ DOUBLING


MRALSB:	MOV TSTA(R3),R1		; CREATE POINTER TO TRANSMIT STATUS BLOCK
	TST @TO.BLK(R1)
	 BNE 11$
	TST AL.BLK(R1)		; ARE WE OUT OF ORDER?
	 BEQ 10$
11$:	ADD #4,(SP)		; THEN PRETEND NOTHING HAPPENED
	RET
10$:	MOV @ALCP(R3),R0	; POINTER ALLOCATION MESSAGE
	MOV @MCNT(R3),R5	; COUNT OF WORDS TO TRANSFER
	MOV @TO.PTR(R1),R2	; LOAD POINTER TO QUEUE
4$:	MOV (R0)+,(R2)+		; OUTPUT CHARACTER MESSAGE
	CMP R2,@TO.END(R1)	; ARE WE AT END OF QUEUE?
	 BNE 1$
	MOV @TO.BEG(R1),R2	; CIRCLE AROUND TO BEGINNING THEN
1$:	CMP R2,@TO.LIM(R1)	; POINTER OVERLAP?
	 BNE 2$
	INC @TO.BLK(R1)
	DEC R5			; HAVE WE FINISHED YET
	BEQ 3$	
	MOV R5,@MCNT(R3)		; NOPE, SAVE COUNT
	MOV R0,@ALCP(R3)	; AND ALLOCATION MESSAGE POINTER
	MOV R2,@TO.PTR(R1)	; RESTORE POINTER
	INC MT.BLK(R1)
	MOV #WAITIN,WAITPL	; PATCH WAIT SINCE WE MADE SOME HEADWAY
	RET
2$:	DEC R5
	BNE 4$
3$:	MOV SRAL(R3),@MRAL(R3)	; PATCH FLAG
	MOV #3,@MCNT(R3)	; RE-INITIALIZE COUNT
	MOV #WAITIN,WAITPL	; PATCH WAIT
	CLR MT.BLK(R1)		; UNBLOCK NORMAL TTY OUTPUT
	MOV R2,@TO.PTR(R1)	; RESTORE POINTER	
	BIS #100,XDST0		; ACTIVATE INTERRUPT
	RET


.PAGE
;  MAIN PROGRAM ROUTINE FOR CONTROL-G MESSAGE HANDLING 
; NOTE: IF IN THE FUTURE MORE THAN ONE CHARACTER MUST BE OUTPUT
;(I.E. MORE THAN JUST ^G) REMEMBER TO INCREMENT MR.BLK(R1)
; WHEN CAN'T FINSIH MESSAGE DUE TO FULL RO QUEUE


MTCGSB:	MOV RSTA(R3),R1
	TST CG.BLK(R1)
	BNE 11$
	TST RO.BLK(R1)
	 BEQ 10$
11$:	ADD #4,(SP)		; RETURN TO .+4
	RET
10$:	MOV #CG,R0
	MOV RO.PTR(R1),R2
	MOVB R0,(R2)+
	CMP R2,RO.END(R1)
	 BNE 1$
	MOV RO.BEG(R1),R2
1$:	CMP R2,RO.LIM(R1)
	 BNE 2$
	INC RO.BLK(R1)
2$:	MOV R2,RO.PTR(R1)
	BIS #100,@XTST(R3)
	MOV STCG(R3),@MTCG(R3)
	MOV #WAITIN,WAITPL
	CLR MR.BLK(R1)
	RET

; OTHER M.P. ROUTINES NOT DEFINED YET
MRPLSB:	RET		; PLASMA DISPLAY

MRIMSB:	RET		; IMLAC RECEIVE

MTIMSB:	RET		; IMLAC XMIT

NULLSB:	RET		; DUMMY

.PAGE
.SBTTL ROUTINES FOR INTIALIZING TTY CHANNELS
INTYSB:	MOV RSTA(R3),R1
	MOV RI.BEG(R1),RI.PTR(R1)
	MOV RI.BEG(R1),RI.LIM(R1)
	MOV RO.BEG(R1),RO.PTR(R1)
	MOV RO.BEG(R1),RO.LIM(R1)
	CLR RI.BLK(R1)
	CLR RO.BLK(R1)
	CLR MR.BLK(R1)
	CLR CG.BLK(R1)
	CLR RO.ESF(R1)
	CLR JMPESC(R1)
	MOV ESCHTB(R3),RO.ESC(R1)
	MOV SRTY(R3),@RI.FLG(R1)
;	MOV SRAL(R3),@AL.FLG(R1)	; GOING TO BE FLAGGED ANYWAY
	CLR ALNUM(R3)
	MOV #5,@MCNT(R3)		; MOVE WORD COUNT OF MESSAGE INTO PLACE
	CLR RS.CNT(R1)
	MOV RSTR(R3),RS.PTR(R1)
	CLR COL(R1)
	CLR ROW(R1)
	MOV TSTA(R3),R1
	MOV TI.BEG(R1),TI.PTR(R1)
	MOV TI.BEG(R1),TI.LIM(R1)
	CLR TI.BLK(R1)
	CLR MT.BLK(R1)
	CLR AL.BLK(R1)
	MOV STTY(R3),@TI.FLG(R1)
	MOV STCG(R3),@CG.FLG(R1)
	CALL ALLCSB
	MOV TSTR(R3),TS.PTR(R1)
	CLR TS.CNT(R1)
;	MOV TS.PTR(R1),R0
;	MOV #37,(R0)+		; CLEAR THE SCREEN INITIALLY ON ALL TTYS BY ^_L
;	MOV #114,(R0)
;	MOV #2,TS.CNT(R1)
;	CLRB @TI.FLG(R1)
	MOV ALZM(R3),@ALCP(R3)		; MOVE ALLOCATION POINTER INTO PLACE
	JMP @INSPTB(R3)			; JCALL TERMINAL DEPENDANT ROUTINES


INSPTB:	.WORD NULLSB
	.WORD NULLSB
	.WORD NULLSB
	.WORD INGLSB
	.WORD NULLSB
	.WORD NULLSB
	.WORD NULLSB

ALLCSB:	PUSH <R5,R1>
	MOV RSTA(R3),R1
	MOVB #ALCINC,@ALCI(R3)		;SET ALLOCATION
	ADD #ALCINC,ALNUM(R3)
	MOV ALCM(R3),@ALCP(R3)		;SET POINTER TO ALLOCATION
	MOV TSTA(R3),R5			;GET POINTER TO TRANSMIT STATUS TABLE
	INC MT.BLK(R5)			;BLOCK MAIN PROGRAM TRANSMIT CHAR PROCESSING
	CLRB @AL.FLG(R1)		;AND SET FLAG
	POP <R1,R5>
	RET
.PAGE
INGLSB:
	MOV GLBEG,GLPTR		; INITALIZE GOULD DATA QUEUE POINTERS
	MOV GLBEG,GTPTR
	MOV GLBEG,GLLIM
	MOV GLBEG,GTLIM
	MOV SSTABR,STATBR	; FIX BRANCH FOR STATUS ROUTINE
	MOV SGLIBR,GLIBR	; FIX BRANCH FOR M.P. FAKERY OF GOULD INTERRUPT
	MOV #STLEN,STALEN
	MOV #STMSG,STAMSG
	.IRP VAL,<GLBLK,JMPFLG,REPFLG,GLERR,PAGMNG,QOTFLG,GRFFLG,CLKCNT,GLDALC>
	CLR VAL
.ENDM
	MOV #1,GLIDL
	MOV #CMIDEC,GLIPTR
	MOV #CHRDEC,GLDPND
	MOV #MAKWD1,WRDPTR
	MOV #DATDEC,GLDPTR
	MOVB #177,STAPAG
	MOV #1,EODFLG
	MOV #%GCOFF,@#GLDCSR	; DISABLE THE PRINTER TO CLEAR ANY OLD INTERRUPTS
	MOV #%GCION,@#GLDCSR	; ENABLE GOULD INTERRUPTS
	RET	

.PAGE
.SBTTL AI KEYBOARD TABLES

;WHAT FOLLOWS IS THE GRAND CHARACTER CONVERSION TABLE

;AN 8 BIT QUANTITY IS USED TO INDEX INTO THE XTAB
;	0-5	KEYBOARD KEY NUMBER
;	  6	SHIFT
;	  7	TOP 

;IF THE BYTE PICKED IS NEGATIVE, YOU HAVE STRUCK A KEY THAT DOES NOT
;HAVE AN ASCII CODE.  THESE CODES ARE ASSIGNED AS FOLLOWS:

AINASC:	NONAS1	;	200	ILLEGAL
	KBRK	;	201	BREAK
	KESC	;	202	ESCAPE
	KCALL	;	203	CALL
	KCLEAR	;	204	CLEAR
	KDEL	;	205	CAP DELTA
	KCIRM	;	206	CIRCLE MINUS
	KGRAD	;	207	DEL
	KCIRP	;	210	CIRCLE PLUS
	KBACK	;	211	BACK
	KNEXT	;	212	NEXT
	KHELP	;	213	HELP
	KFORM	;	214	FORM
	KBS	;	215	BACK SPACE
	KVT	;	216	VERTICAL TAB
	KCR	;	217	CRLF AND BS
	KLINE	;	220	LF OR DNAR
	FDELT	;	221	FORWARD DELETE
	KRPT	;	222	KBD REPEAT
	KTAB	;	223	TAB
	KSPACE	;	224	SPACE

NATEND==<.-AINASC>-1	;MAXIMUM # NON-ASCII CHARACTERS

; SHIFT+TOP CURRENT IDENTICAL TO TOP
.MACRO KBDKEY KEY,CHAR,SHIFTC,TOPC,SHTOPC
	.BYTE CHAR,SHIFTC,TOPC,SHTOPC
.ENDM
.PAGE

AIKTAB:
KBDKEY	0,	201,	201,	201,	201	;BREAK
KBDKEY	1,	202,	202,	202,	202	;ESCAPE
KBDKEY	2,	'1,	'!,	222,	222
KBDKEY	3,	'2,	'",	222,	222
KBDKEY	4,	'3,	'#,	222,	222
KBDKEY	5,	'4,	'$,	222,	222
KBDKEY	6,	'5,	'%,	222,	222
KBDKEY	7,	'6,	'&,	222,	222
KBDKEY	10,	'7,	'',	222,	222
KBDKEY	11,	'8,	'(,	222,	222
KBDKEY	12,	'9,	'),	222,	222
KBDKEY	13,	'0,	'_,	222,	222
KBDKEY	14,	'-,	'=,	'=,	'=
KBDKEY	15,	'@,	'`,	'`,	'`
KBDKEY	16,	'^,	'~,	'~,	'~
KBDKEY	17,	10,	215,	215,	215	;BACK SPACE
KBDKEY	20,	32,	203,	203,	203	;CALL
KBDKEY	21,	14,	204,	204,	204	;CLEAR
KBDKEY	22,	11,	223,	223,	223	;TAB
KBDKEY	23,	33,	33,	33,	33	;ALT-MODE
KBDKEY	24,	'q,	'Q,	4,	4,	;and
KBDKEY	25,	'w,	'W,	37,	37	;or
KBDKEY	26,	'e,	'E,	22,	22	;intersection
KBDKEY	27,	'r,	'R,	23,	23	;union
KBDKEY	30,	't,	'T,	20,	20	;subset
KBDKEY	31,	'y,	'Y,	21,	21	;superset
KBDKEY	32,	'u,	'U,	5,	5	;not
KBDKEY	33,	'i,	'I,	26,	26	;xor
KBDKEY	34,	'o,	'O,	1,	1	;down arrow
KBDKEY	35,	'p,	'P,	13,	13	;up arrow
KBDKEY	36,	'[,	'{,	'{,	'{
KBDKEY	37,	'],	'},	'},	'}
KBDKEY	40,	'\,	'|,	'|,	'|
KBDKEY	41,	'/,	16,	16,	16	;infinity
KBDKEY	42,	206,	206,	205,	205	;circle minus, cap delta
KBDKEY	43,	210,	210,	207,	207	;circle plus, cap del
KBDKEY	44,	14,	214,	214,	214	;form
KBDKEY	45,	16,	216,	216,	216	;vertical tab
KBDKEY	46,	177,	177,	221,	221	;rubout
KBDKEY	47,	'a,	'A,	34,	34	;.leq.
KBDKEY	50,	's,	'S,	35,	35	;.geq
KBDKEY	51,	'd,	'D,	36,	36	;equivalence
KBDKEY	52,	'f,	'F,	17,	17	;delta (partial derivative)
KBDKEY	53,	'g,	'G,	32,	32	;not equals
KBDKEY	54,	'h,	'H,	213,	213	;HELP!!!!!
KBDKEY	55,	'j,	'J,	30,	30	;back arrow
KBDKEY	56,	'k,	'K,	31,	31	;forward arrow
KBDKEY	57,	'l,	'L,	27,	27	;both ways arrow
KBDKEY	60,	73,	'+,	'+,	'+	; ";"
KBDKEY	61,	':,	'*,	'*,	'*
KBDKEY	62,	15,	217,	217,	217	;carriage return
KBDKEY	63,	12,	220,	220,	220	;line feed
KBDKEY	64,	37,	212,	211,	211	;next, back
KBDKEY	65,	'z,	'Z,	2,	2	;alpha
KBDKEY	66,	'x,	'X,	3,	3	;beta
KBDKEY	67,	'c,	'C,	6,	6	;epsilon
KBDKEY	70,	'v,	'V,	10,	10	;lambda
KBDKEY	71,	'b,	'B,	7,	7	;pi
KBDKEY	72,	'n,	'N,	24,	24	;for all
KBDKEY	73,	'm,	'M,	25,	25	;there exists
KBDKEY	74,	54,	74,	74,	74	; <
KBDKEY	75,	'.,	76,	76,	76	; >
KBDKEY	76,	'/,	'?,	'?,	'?	; ?
KBDKEY	77,	40,	224,	222,	222	;space

.PAGE
.SBTTL TTY TABLES AND BUFFERS FOR TTYS

;  ADDRESS AND VALUE TABLES FOR MAIN PROGRAM SUBROUTINE CALLS 

.IRP NAM,<MCNT,ALCM,ALCP,RSTA,TSTA,RIBF,ROBF,TIBF,RSTR,TSTR>
VALCRE NAM,MAXTTY
.ENDM

.IRP NAM,<MCNT,ALCM,ALCP,RSTA,TSTA,RSTR,TSTR> ;MACRO TABLES
	ADRCRE NAM,MAXTTY
.ENDM
.IRP NAM,<MRTY,MRAL,MTTY,MTCG,ALCI,ALZM>  ;PREDEFINED TABLES
	ADRCRE NAM,MAXTTY
.ENDM

.IRP NAM,<RTST,RTBF>
	ADRCRE NAM,MXRTTY
.ENDM

.IRP NAM,<XTST,XTBF>
	ADRCRE NAM,MXXTTY
.ENDM

ALNUM:	.BLKW MXTTTY		; TABLE OF CURRENT ALLOCATIONS


;  TRANSMIT OUTPUT DEVICE STATUS TABLE (MANY TO ONE NECESSITATES INDIRECTION
; 	TO THIS TABLE)

	TOBFMC <0>

TDST0:	.WORD TOBF0
	.WORD TOBF0+TOBFLN
	.WORD TOBF0
	.WORD TOBF0
	.WORD 0
.PAGE
; TTY ESCAPE CHAR TABLE
ESCHTB:	-1		;TTY 23
	-1		;TTY 24
	33		;TTY 25
	-1		;TTY 36
	33
	-1
	-1
	-1

; VT52 TO ANN ARBOR DISPLAY CONTROLLER ESCAPE CODE TRANSLATIONS

VT52TB:	AANOOP
	AAMVUP		; A - MOVE UP
	AAMVDN		; B - MOVE DOWN
	AAMVRT		; C - MOVE RIGHT
	AAMVLF		; D - MOVE LEFT
	AANOOP
	AANOOP
	AANOOP
	AAHOME		; H - HOME UP
	AANOOP
	AAEOS		; J - ERASE TO END OF SCREEN
	AAEOL		; K - ERASE TO END OF LINE
	.REPT 15
	AANOOP
.ENDR
	AAPOS		; Y - ABSOLUTE CURSOR POSITIONING
	AANOOP

; ANN ARBOR CONTROLER CONTROL CHAR DISPATCH TABLE
AACTLT:	.REPT 7
	AACTRL
	.ENDR
	AABELL
	AABS
	AATAB
	AALF
	AAVT
	AAFF
	AACR
	.REPT 22
	AACTRL
	.ENDR
.PAGE

SKEYTB:	NONAS1
	KBRK
	KESC
	KCALL
	KCLEAR
	KDEL
	KCIRM
	KGRAD
	KCIRP
	KBACK
	KNEXT
	KHELP
	KFORM
	KBS
	KVT
	KCR
	KLINE
	FDELT
	KRPT
	KTAB
	KSPACE
	.REPT 13
	KNOOP
	.ENDR
.PAGE
.SBTTL  GOULD VARIABLES AND BUFFERS AND TABLES 
MARLEN:	.WORD 0
DATLEN:	.WORD 0
DATLN1:	.WORD 0
ENCLEN:	.WORD 0
MARLN1:	.WORD 0
TMPWRD:	.WORD 0
VALWRD:	.WORD 0
GLDPND:	.WORD CHRDEC
WRDPTR:	.WORD MAKWD1
GLDPTR:	.WORD DATDEC
EODFLG:	.WORD 0
QOTFLG:	.WORD 0
GRFFLG:	.WORD 0
COLOR:	.WORD 0
GLPTR:	.WORD GLDBUF
GTPTR:	.WORD GLDBUF
GLEND:	.WORD <CORLIM-<LBUFL+22>>
GLBEG:	.WORD GLDBUF
GLLIM:	.WORD GLDBUF
GTLIM:	.WORD GLDBUF
GLBLK:	.WORD 0

GLIPTR:	.WORD CMIDEC
JMPFLG:	.WORD 0
REPFLG:	.WORD 0
PNDR0:	.WORD 0
JMPRET:	.WORD 0
REPRET:	.WORD 0
REPCNT:	.WORD 0
GLIDL:	.WORD 0
GLERR:	.WORD 0
PAGMNG:	.WORD 0
SMRFLG:	.WORD 0
STMSG:	.WORD 177
STAPAG:	.WORD 177
STAERR:	.WORD 0
	.WORD 0
	.WORD 0
STLEN==<.-STMSG>/2

STAMSG:	.WORD STMSG
STALEN:	.WORD STLEN
GLDALC:	.WORD 0

;  START OF GOULD BUFFER 
GLDBUF:
.END INIT
