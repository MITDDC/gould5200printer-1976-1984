	.title Terminal multiplexer, Gould driver, and self-debugger.


;  REGISTERS 

R0=%0
R1=%1
R2=%2
R3=%3
R4=%4
R5=%5
SP=%6
PC=%7

;  MISCELLANEOUS CONSTANT DEFINITIONS

MXTTTY==10.		; MAXIMUM NUMBER OF TERMINALS THIS ASSEMBLY
MAXTTY==11.		; MAXIMUM NUMBER OF CHANNELS SUPPORTED CURRENT ITS ASSEMBLY
MXRTTY==4		; NUMBER OF DEVICE REGISTER RECEIVE TTYS
MXXTTY==MXTTTY		; NUMBER OF DEVICE REGISTER TRANSMIT TTYS
DTTY==12		; NUMBER OF THE DEBUGGING TTY LINE
PRIOR0==7_5		; MASK FOR BIC APPLIED TO PS
PRIOR7==7_5		; MASK FOR BIS APPLIED TO PS
P7=PRIOR7
P5=5_5
CG==7			; <CNTL>-G
CBSL==34		; <CNTL>-\
NOPIN==240		; NOP INSTRUCTION
WAITIN==1		; WAIT INSTRUCTION
LBUFL==410	; MAXIMUM SIZE OF A LINE BUFFER (IN BYTES)
RSTRLN==24	; LENGTH OF TEMPORARY STRING BUFFERS
TSTRLN==24
STRIP==177600	; BIT IN BUFFER WORD WHICH INDICATED STRIPED GRAPHICS
LHS==177400	; LEFT HAND SIDE OF WORD MASK
GLDTIM==30	; TIME (IN 30TH'S OF SECOND) FOR SMEAR TIMEOUT
CORLIM==137472	; LIMIT OF USABLE CORE (24K-LOADERS)

;  CONSTANTS FOR INITIALIZATION OF NON-STANDARD DEVICES 

DR11MI==0
KEYBDI==101
IMLACI==0
INVBIT==40000	; INDICATES VALID DATA ON INPUT MULTIPLEXOR

;  RECEIVE BUFFER PARAMETERS 
RIBFLN==300
ROBFLN==300

ALCMAX==276	; MAXIMUM PERMISSABLE ALLOCATION
		; 2 CHARACTERS LESS THAN BUFFER SIZE, ONE TO ALLOW
		; FOR ^G INSERTION AND ONE FOR PATHOLOGICAL FENCEPOST
		; INTERACTIONS

ALCLIM==ALCMAX/2	; AT THIS POINT, ADD TO ALLOCATION
ALCINC==ALCMAX/2	; THIS IS HOW MUCH TO INCREMENT THE ALLOCATION BY


; GOULD COMMAND CODES
 %GCFF==0	; TOP-OF-FORM COMMAND (128 RASTERS ON ROLL PAPER)
 %GCGRF==1	; GRAPHIC MODE COMMAND
 %GCCUT==2	; CUT COMMAND (NO CUTTER ON THIS MACHINE, THOUGH)
 %GCON==3	; TURN PRINTER ON
 %GCOFF==4	; TURN PRINTER OFF
 %GCLSL==5	; LAST LINE (GRAPHIC MODE).  => 2 MORE SCAN LINES.
 %GCION==6	; INTERRUPT ON
 %GCIOF==7	; INTERRUPT OFF
 %GCHOM==200	; HOME (128 RASTER UNITS)
 %GCADV==201	; ADVANCE ONE LINE

; PSEUDO COMMAND CODES

 %GCSRP==300	; START OF REPEAT
 %GCERP==301	; END OF REPEAT


; MACRO COMMAND CODES

 SLALPH==140000	; SELECT ALPHA MODE
 SLLGRF==150000	; SELECT LOW SPEED GRAPHICS MODE
 SLHGRF==160000	; SELECT HIGH SPEED GRAPHICS MODE
 SLEOF==170000	; EOF (TAIL SHEET HACKERY)

; GOULD STATUS BITS
 %GSNRD==400	; NOT READY (INTERLOCK TRIPPED)
 %GSDON==2000	; DMA TRANSFER COMPLETE
 %GSBSY==4000	; BUSY (PAPER MOVEMENT, SYSTEM BEING RESET, ETC.)
 %GSVAC==10000	; VACUUM FAULT
 %GSPAP==20000	; PAPER LOW
 %GSTIM==40000	; HIGH SPEED GRAPHICS TIMEOUT
 %GSERR==40400	; ALL ERROR BITS EXCEPT PAPER LOW



;  SPECIAL GOULD COMMUNICATION BYTE CODES

%CCSOD=205	; ESCAPE FOR BEGINNING OF DATA
%CCEOD=206	; ESCAPE FOR END OF DATA
%CCQOT=215	; TO QUOTE 8 BIT CODES IN GRAPHICS MODE
%CCACK=301	; ARE WE BEING PAGED?

; TCTYPE'S
%TCGLD==0
%TCTEK==1
%TCAAD==2
%TCIML==3
%TCGTV==4

; 12-BIT KEYBOARD CODES
MASK37==177740
MAXMUX==177770		; NUMBER OF MULTIPLEXED INPUT LINES (POWER OF 2 -USED AS A MASK)
MASCII=177600		; MASK THE ASCII PART OF THE DATA
MBYTE=177400		; MASK FOR CLEARING THE LEFT BYTE (MAINLY FOR FLUSHING SIGN EX.)
%SPKEY=200		; SPECIAL KEY
%SBITS=MASK37		; SPECIAL BITS (META,TOP, CTRL, SHIFT,SHIFT LOCK)
%SHLOK=10		; SHIFT LOCK (LH BYTE ON INPUT)

; ANN ARBOR CODES
%AAPOS==17
%BELL==207
AASRLN==10000
AACOLX==79.			; LAST COLUMN

; GRINNELL TV TEST CODES

%GRTST==053777			; 124000 - ENTER TEST MODE
%GRTS1==047777			; 130000 - TEST 1
%GRTS2==047776			; 130001 - TEST 2
%GRTS3==047775			; 130002 - TEST 3
%GRTS4==047764			; 130004 - TEST 4

;  TRANSMIT BUFFER PARAMETERS 

TIBFLN==100
TOBFLN==MAXTTY*<40+6>

; Receive String Buffer sizes
RSLN0==RSTRLN
RSLN1==RSTRLN
RSLN2==RSTRLN
RSLN3==RSTRLN
RSLN4==AASRLN
RSLN5==AASRLN
RSLN6==0
RSLN7==0
RSLN10==0
RSLN11==0
RSLN12==0


.SBTTL  INTERFACE DEFINITIONS 

; DEC INTERFACES

; SERIAL INTERFACES
%CRCSR==177560			; CONSOLE TTY
%CRBUF==177562
%CXCSR==177564
%CXBUF==177566
%DRCSR==175610			; DL-11E 40 KBAUD
%DRBUF==175612
%DXCSR==175614
%DXBUF==175616
%ERCSR==175620			; DL-11E 9600 BAUD
%ERBUF==175622
%EXCSR==175624
%EXBUF==175626
%FRCSR==175630			; DL-11E 9600 BAUD
%FRBUF==175632
%FXCSR==175634
%FXBUF==175636
%GRCSR==175640			; DL-11E 9600 BAUD
%GRBUF==175642
%GXCSR==175644
%GXBUF==175646

; PARALLEL INTERFACES
; INPUT
%I1ACS==167760			; DR-11L SIDE 1
%I1ABF==167762
%I1BCS==167764			; DR-11L SIDE 2
%I1BBF==167766
; OUT
%O1ACS==167770			; DR-11M SIDE 1
%O1ABF==167772
%O1BCS==167774			; DR-11M SIDE 2
%O1BBF==167776

%UNDEF==0

; HOME BREW HARDWARE

		; ANN ARBOR CONTROLLER
%AACS==%O1ACS
%AABF==%O1ABF

		; BELL DINGER
%BELBF==%O1ABF

		; GRINNELL TV SYSTEM
GTVCSR==%O1BCS
GTVBUF==%O1BBF

		; KEYBOARD MULTIPLEXOR
%KYSTA==%I1ACS		; STATUS REGISTER
%KYBUF==%I1ABF		; BUFFER REGISTER

		; DIGIVUE PLASMA DISPLAY
%PLACS==%UNDEF		; STATUS
%PLXBF==%UNDEF		; X REGISTER
%PLYBF==%UNDEF		; Y REGISTER
%PLDBF==%UNDEF		; DATA


; COMMERCIAL INTERFACES

		; GOULD ELECTROSTATIC PRINTER PLOTTER
%GLCSR=166000		; COMMAND AND STATUS REGISTER
%GLWC=166002		; NEGATIVE WORD COUNT REG
%GLCA=166004		; CURRENT ADDRESS REG



.SBTTL  DEVICE AND TTY DEFINITIONS 


RDST0==%DRCSR		; DEVICE 0 -> DL-11 MULTIPLEXED LINE CONNECTED TO PDP-10
RDBF0==%DRBUF
XDST0==%DXCSR
XDBF0==%DXBUF

GLDCSR==%GLCSR		; TTY 0 (T23) -> GOULD LINE PRINTER (SPECIAL HARDWARE REGISTERS)
GLDWC==%GLWC
GLDCA==%GLCA

RTST1==%CRCSR		; TTY 1 (T24) ->  (CPU CONSOLE TTY) CONNECTED TO A TEKTRONIX
RTBF1==%CRBUF
XTST1==%CXCSR
XTBF1==%CXBUF

RTST2==%ERCSR		; TTY 2 (T25) -> DL-11 CONNECTED TO A TEKTRONIX (BLDG 26.)
RTBF2==%ERBUF
XTST2==%EXCSR
XTBF2==%EXBUF

			; TTY 3 (T26) -> DMA IMLAC INTERFACE


XTST4==%AACS		; TTY 4 ANN ARBOR #1
XTBF4==%AABF
XTST5==%AACS		; TTY 5 ANN ARBOR #2
XTBF5==%AABF

PLPSTA==%PLACS
PLXBUF==%PLXBF
PLYBUF==%PLYBF
PLDBUF==%PLDBF

MRTST1==%FRCSR			; MODEM TTY 1
MRTBF1==%FRBUF
MXTST1==%FXCSR
MXTBF1==%FXBUF

MRTST2==%GRCSR			; MODEM TTY 2 (DL-11 1200 BAUD)
MRTBF2==%GRBUF
MXTST2==%GXCSR
MXTBF2==%GXBUF

; TTYS I.T.S. THINKS ARE HERE BUT AREN'T YET.

XTST3==XTSTD
XTBF3==XTBFD
XTST6==XTSTD
XTBF6==XTBFD
XTST7==XTSTD
XTBF7==XTBFD
XTST10==XTSTD
XTBF10==XTBFD
XTST11==XTSTD
XTBF11==XTBFD
XTST12==XTSTD
XTBF12==XTBFD

; SPECIAL DEVICES

KEYSTA==%KYSTA		; KEYBOARD MULTIPLEXOR
KEYBUF==%KYBUF

; TTY 12 (T35) -> DEBUGGING TTY LINE (NO HARDWARE TERMINAL CONNECTION).


.SBTTL TABLE OFFSET DEFINITIONS

;  RECEIVE STATUS TABLE OFFSETS 
RI.PTR==0
RI.END==2
RI.BEG==4
RI.LIM==6
RI.FLG==10
RO.PTR==12
RO.END==14
RO.BEG==16
RO.LIM==20
AL.FLG==22
TTYNUM==25
RI.BLK==30
RO.BLK==32
MR.BLK==34
CG.BLK==36
R.FLGS==40
RS.PTR==42
RS.CNT==44
RO.ESF==46
RO.ESC==50
JMPESC==52
ROW==54
COL==56


;  TRANSMIT STATUS TABLE OFFSETS 

TI.PTR==0
TI.END==2
TI.BEG==4
TI.LIM==6
TI.FLG==10
TO.PTR==12
TO.END==14
TO.BEG==16
TO.LIM==20
CG.FLG==22
TTYNUM==25
TI.BLK==30
TO.BLK==32
MT.BLK==34
AL.BLK==36
T.FLGS==40
TS.PTR==42
TS.CNT==44

;  TRANSMIT OUTPUT DEVICE STATUS OFFSETS 

OD.PTR==0		;Place to put more stuff in
OD.END==2		;End of buffer
OD.BEG==4		;Beginning of buffer
OD.LIM==6		;Place at which we're reading out
OD.BLK==10


.SBTTL  INTERRUPT AND TRAP VECTORS 

%ERRV=4
%ILIV=10
%BPTV=14
%IOTV=20
%PWRV=24
%EMTV=30
%TRPV=34
%CLRV=60
%CLXV=64
%LKV=100
%GLDV=174
%KEYV=200

%AADCV=210
%PLPV=214
%DLRV=300
%DLXV=304
%ELRV=310
%ELXV=314
%FLRV=320
%FLXV=324
%GLRV=330
%GLXV=334

%MSTR==340	; MASTER PRIORITY, NO CONDITION CODES SET

	; THESE GIVE MASTER PRIORITY WITH CONDITION CODE BITS SET TO
	; NOTIFY THE UNEXPECTED TRAP HANDLER WHICH STATE WAS RAISED
	; IDEALLY THEY SHOULD NEVER HAVE TO BE USED

%MSTR1==341
%MSTR2==342
%MSTR3==343
%MSTR4==344
%MSTR5==345
%MSTR6==346
%MSTR7==347

%CLRPR=200		; PRI 4, (DEVICE AT BR4)
%CLTPR=200		; PRI 4, (DEVICE AT BR4)
%KEYPR=200		; PRI 4, (DEVICE AT BR4)
%PLPPR=200
%AADPR=200		; PRI 4, (DEVICE AT BR4)
%ELRPR=200		; PRI 4, (DEVICE AT BR4)
%ELXPR=200		; PRI 4, (DEVICE AT BR4)
%FLRPR=200		; PRI 4, (DEVICE AT BR4)
%FLXPR=200		; PRI 4, (DEVICE AT BR4)
%GLRPR=200		; PRI 4, (DEVICE AT BR4)
%GLXPR=200		; PRI 4, (DEVICE AT BR4)
%GLDPR=240		; PRI 5, (DEVICE AT BR5)
%DLRPR=300		; PRI 6, (DEVICE AT BR6)
%DLXPR=300		; PRI 6, (DEVICE AT BR6)
%LKPR=300		; PRI 6, (DEVICE AT PSEUDO BR6)


.=%ERRV
	CPUERR			; CPU ERROR
	%MSTR1
.=%ILIV
	ILLOPR			; ILLEGAL INSTRUCTIONS
	%MSTR2
.=%BPTV
	BPTTRP			; BREAKPOINT TRAP
	%MSTR3
.=%IOTV
	IOTTRP			; IOT TRAP
	%MSTR4
.=%PWRV
	POWROF			; POWER FAIL - RESTART
	%MSTR
.=%EMTV
	EMTTRP			; EMULATOR TRAP
	%MSTR5
.=%TRPV
	UUOH			; TRAP INSTRUCTION
	%MSTR6
.=%CLRV
	INRT1			; CONSOLE RECEIVED CHARACTER
	%CLRPR
.=%CLXV
	INTT1			; CONSOLE TRANSMITTED CHARACTER
	%CLTPR
.=%LKV
	CLKHND			; LINE FREQUENCY CLOCK
	%LKPR

.=%GLDV
	GLDINT			; GOULD INTERRUPT
	%GLDPR
.=%KEYV
	KEYINT			; KEYBOARD MULTIPLEXOR
	%KEYPR
.=%AADCV
	AAINT			; ANN ARBOR DISPLAY CONTROLLER
	%AADPR
.=%PLPV
	PLPINT			; PLASMA PANEL (BUFFER EMPTY)
	%PLPPR
.=%DLRV
	INRD0			; DL-11 #1 RECEIVED CHARACTER
	%DLRPR
.=%DLXV
	INTD0			; DL-11 #1 TRANSMITTED CHARACTER
	%DLXPR
.=%ELRV
	INRT2			; DL-11 #2 RECEIVED CHARACTER
	%ELRPR
.=%ELXV
	INTT2			; DL-11 #2 TRANSMITTED CHARACTER
	%ELXPR
.=%FLRV
	RTI			; DL-11 #3 RECEIVED CHARACTER
	%FLRPR
.=%FLXV
	RTI			; DL-11 #3 TRANSMITTED CHARACTER
	%FLXPR
.=%GLRV
	RTI		; FOR NOW
	%GLRPR
.=%GLXV
	RTI			; FOR NOW
	%GLXPR


.SBTTL TABLE AND VARIABLE DEFINITION MACROS
;  UTILITY MACROS 


.MACRO PUSH X
.IRP Y,<X>
	MOV Y,-(SP)
.ENDM
.ENDM


.MACRO POP X
.IRP Y,<X>
	MOV (SP)+,Y
.ENDM
.ENDM


.MACRO MASK LEVEL
	PUSH %PS
	MOV #<LEVEL>_5,%PS
.ENDM

.MACRO UNMASK
	POP %PS
.ENDM

.MACRO CALL X
	JSR PC,X
.ENDM

.MACRO JCALL X
	JMP X
.ENDM

.MACRO RET
	RTS PC
.ENDM

.MACRO MSG X
.NCHR ZZ,^\X\
	.WORD ZZ
	.ASCII \X\
	.EVEN
.ENDM

;  BRANCH MACROS 

.MACRO SRTYMC NM
PLAC=.
.=SRTY+<NM*2>
SRTY'NM:	BR .+<MRAL'NM-MRTY'NM>
.=PLAC
.ENDM

.MACRO STTYMC NM
PLAC=.
.=STTY+<NM*2>
STTY'NM:	BR .+<MTCG'NM-MTTY'NM>
.=PLAC
.ENDM

.MACRO SRALMC NM,NM1
PLAC=.
.=SRAL+<NM*2>
SRAL'NM:	BR .+<MRTY'NM1-MRAL'NM>
.=PLAC
.ENDM

.MACRO STCGMC NM,NM1
PLAC=.
.=STCG+<NM*2>
STCG'NM:	BR .+<MTTY'NM1-MTCG'NM>
.=PLAC
.ENDM

;  INQUIRY LOOP MACROS 

.MACRO RPROC NM,NM1,MRTYSB,MRALSB	; CREATE A RECEIVE PROCESS
MRTY'NM:	BR MRAL'NM
	MOV #NM*2,R3
	CALL MRTYSB
	JMP TESTLB
	SRTYMC NM
MRAL'NM:	BR MRTY'NM1
	MOV #NM*2,R3
	CALL MRALSB
	JMP TESTLB
	SRALMC NM,NM1
.ENDM

.MACRO RSYM NM			; INQUIRE LOOP RECEIVE TERMINATION SYMBOL
MRTY'NM:
.ENDM

.MACRO TPROC NM,NM1,MTTYSB,MTCGSB	; CREATE A TRANSMIT PROCESS
MTTY'NM:	BR MTCG'NM
	MOV #NM*2,R3
	CALL MTTYSB
	JMP TESTLB
	STTYMC NM
MTCG'NM:	BR MTTY'NM1
	MOV #NM*2,R3
	CALL MTCGSB
	JMP TESTLB
	STCGMC NM,NM1
.ENDM

.MACRO TSYM NM			; INQUIRE LOOP TRANSMIT TERMINATION SYMBOL
MTTY'NM:
.ENDM

;  BUFFER MACROS 

.MACRO	RIBFMC NM		; RECEIVE INPUT BUFFER MACRO
RIBF'NM:	.BLKW RIBFLN/2
.ENDM

.MACRO	ROBFMC NM		; RECEIVE OUTPUT BUFFER MACRO
ROBF'NM:	.BLKW ROBFLN/2
.ENDM

.MACRO	TIBFMC NM		; TRANSMIT INPUT BUFFER MACRO
TIBF'NM:	.BLKW TIBFLN/2
.ENDM

.MACRO	TOBFMC NM		; TRANSMIT OUTPUT BUFFER MACRO
TOBF'NM:	.BLKW TOBFLN/2
.ENDM

.MACRO RSTRMC NM
RSTR'NM:	.BLKW RSLN'NM/2
.ENDM

.MACRO	TSTRMC NM
TSTR'NM:	.BLKW TSTRLN/2
.ENDM


;  TABLE UTILITY MACROS 

.MACRO VALCRE NAM,NUM		; VALUE TABLE CREATING MACRO
	.REPT NUM
	NAM'MC \.RPCNT,\.RPCNT+1
.ENDR
.ENDM

.MACRO ADRMAC NAME,NM		; MACRO FOR ADDRESS TABLE ENTRY
	.IFDF	NAME'NM
		.WORD NAME'NM
	.ENDC
	.ELSE
		.WORD 0
	.ENDC
.ENDM

.MACRO ADRCRE NAM,NUM		; ADDRESS TABLE CREATING MACRO
NAM:	.REPT NUM
	ADRMAC NAM,\.RPCNT
.ENDR
.ENDM


;  STATUS TABLE MACROS 

.MACRO	RSTAMC NM		; RECEIVE STATUS TABLE MACRO
RSTA'NM:	.WORD RIBF'NM		; RI.PTR
	.WORD RIBF'NM+RIBFLN		; RI.END
	.WORD RIBF'NM			; RI.BEG
	.WORD RIBF'NM			; RI.LIM
	.WORD MRTY'NM			; RI.FLG
	.WORD ROBF'NM			; RO.PTR
	.WORD ROBF'NM+ROBFLN		; RO.END
	.WORD ROBF'NM			; RO.BEG
	.WORD ROBF'NM			; RO.LIM
	.WORD MRAL'NM			; AL.FLAG
	.BYTE 0,200+NM,0,0		; TTYNUM
	.WORD 0				; RI.BLK
	.WORD 0				; RO.BLK
	.WORD 0				; MR.BLK
	.WORD 0				; CG.BLK
	.WORD 0				; R.FLGS
	.WORD RSTR'NM			; RS.PTR
	.WORD 0				; RS.CNT
	.WORD 0				; RO.ESF
	.WORD -1			; RO.ESC
	.WORD 0				; JMPESC
	.WORD 0				; ROW
	.WORD 0				; COL

.ENDM



.MACRO	TSTAMC NM		; TRANSMIT STATUS TABLES MACRO
TSTA'NM:	.WORD TIBF'NM
	.WORD TIBF'NM+TIBFLN
	.WORD TIBF'NM
	.WORD TIBF'NM
	.WORD MTTY'NM
	.WORD TDST0+OD.PTR	;INDIRECT POINTER
	.WORD TDST0+OD.END	;INDIRECT POINTER
	.WORD TDST0+OD.BEG	;INDIRECT POINTER
	.WORD TDST0+OD.LIM	;INDIRECT POINTER
	.WORD MTCG'NM
	.BYTE 0,200+NM,0,0
	.WORD 0
	.WORD TDST0+OD.BLK	;INDIRECT POINTER
	.WORD 0
	.WORD 0
	.WORD 0
	.WORD TSTR'NM
	.WORD 0
.ENDM

;  INTERRUPT HANDLER MACROS 

.MACRO INRTMC NM,INRTSB		; TTY RECEIVE INTERRUPT HANDLER
INRT'NM:	PUSH R3
	MOV #NM*2,R3
	CALL INRTSB
	POP R3
	RTI
.ENDM

.MACRO INTTMC NM,INTTSB		; TTY TRANSMIT INTERRUPT HANDLER
INTT'NM:	PUSH R3
	MOV #NM*2,R3
	CALL INTTSB
	POP R3
	RTI
.ENDM

;  ALLOCATION DATA MACROS 

.MACRO ALCMMC NM		; ALLOCATION MESSAGE MACRO
ALZM'NM:	.BYTE 200+NM,34	; ^\
		.BYTE 200+NM,32	; ^Z
ALCM'NM:	.BYTE 200+NM,34	; ^\
		.BYTE 200+NM,1	; ^A
		.BYTE 200+NM,0	; ALLOCATION
ALCI'NM==.-1
.ENDM


.MACRO MCNTMC NM
MCNT'NM:	.WORD 3		; MACRO FOR STORAGE OF COUNT OF MESSAGE
.ENDM

.MACRO ALCPMC NM
ALCP'NM:	.WORD ALCM'NM	; MACRO FOR STORAGE OF MESSAGE POINTER
.ENDM

.macro fatal
	halt		;This will become a call to the debugging routine
	jmp init
.endm


.SBTTL $$$$$$ INITIALIZATION $$$$$

.=1700
PDL:
.=1770
TTYPdl:
SavTPdl: .word 0

;.=1774
;	jmp ddt
.=2000

INIT0:	BR INIT			; Screen preserving initialization
INIT1:	INC TTYCLR		; Screen clearing initialization

;;		Initialize processor.

INIT:	MOV #340,%PS
	RESET

;;		Initialize stacks.

	MOV #PDL,SP			; INITIALIZE STACK
	mov #TTYPdl-2,SavTPdl		; Initialize debug-TTY stack.
	mov #dbt,TTYPdl

;;		Initialize device buffers and control.

	MOV #TDST0,R1			; DEVICE 0
	MOV #SLRD0,VCRD0		; INTERNAL POINTER IN DEVICE 0
					; RECEIVE INTERRUPT HANDLER
	MOV OD.BEG(R1),OD.PTR(R1)
	MOV OD.BEG(R1),OD.LIM(R1)
	CLR OD.BLK(R1)
	CLR LINEN			; FORCES FIRST LINE SELECT

;;		Set up device interrupts.

	BIS #100,RDST0			; ENABLE DL-11 RECEIVE INTERRUPTS
	BIC #100,XDST0			; DISABLE DL-11 TRANSMIT INTERRUPTS

	BIS #100,RTST1			; ENABLE DL-11 RECEIVE INTERRUPTS
	BIC #100,XTST1			; DISABLE DL-11 TRANSMIT INTERRUPTS

	BIS #100,RTST2
	BIC #100,XTST2

	BIC #100,%LKS			; TURN OFF LINE CLOCK INTERRUPTS

	BIC #100,%AACS			; DISABLE ANN ARBOR CONTROLLER INTERRUPTS

;;		Initialize keyboard multiplexer

	MOV KEYBUF,R0			; JUST A RANDOM EXTRA TIME
1$:	MOV KEYBUF,R0			; KEYBOARD MULTIPLEXER
	INC R0				; IF CLEARED, WILL BE -1, INCREMENTED TO 0
	 BNE 1$
	MOV #KEYBDI,KEYSTA

;;		Initialize all tty channels

	MOV #WAITIN,WAITPL		; FIX WAIT INSTRUCTION

	MOV #<MAXTTY-1>*2,R3
2$:	CALL INTYSB			; INTYSB VECTORS TO PROPER INIALIZING ROUTINE
	SUB #2,R3
	BPL 2$

	CLR TTYCLR
	CLR %PS				; ALLOW INTERRUPTS
	BR TESTLB			; SKIP OVER BRANCH PATCH TABLES

TTYCLR:	.WORD 0
XTSTD:	.WORD 0
XTBFD:	.WORD 0

SRTY:	.BLKW MXTTTY
STTY:	.BLKW MXTTTY
SRAL:	.BLKW MXTTTY
STCG:	.BLKW MXTTTY


.SBTTL  INQUIRY LOOP 

TESTLB:
GLDTTY==0				; TTY CHANNEL NUMBER ASSOCIATED WITH GOULD
	RPROC 0,1,MRGLSB,MRALSB			; TTY 23 - GOULD
	RPROC 1,2,MRTYSB,MRALSB			; TTY 24 - TEK (LOCAL)
	RPROC 2,3,MRTYSB,MRALSB			; TTY 25 - TEK (BLDG. 26)
	RPROC 3,4,MRTYSB,MRALSB			; TTY 26 - IMLAC
	RPROC 4,5,MRTYSB,MRALSB			; TTY 27 - ANN ARBOR DISPLAY
	RPROC 5,6,MRTYSB,MRALSB			; TTY 30 - (FOR NOW) ANN ARBOR DISPLAY
	RPROC 6,7,MRTYSB,MRALSB			; TTY 31 - TV 1
	RPROC 7,10,MRTYSB,MRALSB		; TTY 32 - TV 2
	RPROC 10,11,MRTYSB,MRALSB		; TTY 33 - TV 3
	RPROC 11,12,MRTYSB,MRALSB		; TTY 34 - TV 4

	RSYM \MXTTTY

	TPROC 0,1,MTTYSB,NULLSB			; TTY 23
	TPROC 1,2,MTTYSB,MTCGSB			; TTY 24
	TPROC 2,3,MTTYSB,MTCGSB			; TTY 25
	TPROC 3,4,MTTYSB,MTCGSB			; TTY 26
	TPROC 4,5,MTTYSB,NULLSB			; TTY 27
	TPROC 5,6,MTTYSB,NULLSB			; TTY 30
	TPROC 6,7,MTTYSB,MTCGSB			; TTY 31
	TPROC 7,10,MTTYSB,MTCGSB		; TTY 32
	TPROC 10,11,MTTYSB,MTCGSB		; TTY 33
	TPROC 11,12,MTTYSB,MTCGSB		; TTY 34
	TSYM \MXTTTY

STATBR:	BR GLIBR		; MAIN PROGRAM LEVEL STATUS MESSAGE DAEMON
	MOV #GLDTTY*2,R3
	MOV TSTA(R3),R4
	MOV TI.PTR(R4),R5
	MOV STAMSG,R0
12$:	TST TI.BLK(R4)
	 BEQ 1$
	MOV R0,STAMSG
	MOV R5,TI.PTR(R4)
	CLRB @TI.FLG(R4)
	 JMP TESTLB		; (SINCE CHARACTERS ARE NOT DEPOSITED WITH INTERRUPTS
				; WAITPL HACKERY IS NOT NEEDED)
1$:	MOV (R0)+,(R5)+
	CMP R5,TI.END(R4)
	 BNE 3$
	 MOV TI.BEG(R4),R5
3$:	CMP R5,TI.LIM(R4)
	 BNE 4$
	INC TI.BLK(R4)
4$:	DEC STALEN
	 BNE 12$
	MOV #STLEN,STALEN	; CLEAN UP
	MOV #STMSG,STAMSG
	MOV R5,TI.PTR(R4)
	MOV SSTABR,STATBR
	CLRB @TI.FLG(R4)
	JMP TESTLB

GLIBR:	BR WAITPL		; MAIN PROGRAM ACTIVATION OF GOULD
				; (USEFUL ALSO FROM INTERRUPT LEVELS >= 5)
	TST GLERR
	BNE WAITPL		; SKIP IF GOULD ERROR
	MASK 5
	CALL GLDINT
	MOV SGLIBR,GLIBR	; CLEAN UP AND FALL THROUGH

WAITPL:	WAIT
	JMP TESTLB

SSTABR:	BR .+<GLIBR-STATBR>
SGLIBR:	BR .+<WAITPL-GLIBR>


.SBTTL  TTY INTERRUPT DISPATCH 

	INRTMC 1,INRTSB			; TEKTRONIX	STANDARD RECEIVE INTERRUPT
	INRTMC 2,INRTSB			; TEKTRONIX	STANDARD RECEIVE INTERRUPT

; MODEM TTYS?

	INTTMC 1,INTTSB			; TEKTRONIX	STANDARD TRANSMIT INTERRUPT
	INTTMC 2,INTTSB			; TEKTRONIX	STANDARD TRANSMIT INTERRUPT
	INTTMC 4,INTTSB

.SBTTL  INTERRUPT HANDLERS 

;  FATAL INTERRUPT HANDLER 

CPUERR:
ILLOPR:
BPTTRP:
IOTTRP:
EMTTRP:
UUOH:
	Fatal
 	JMP INIT		; SO CONTINUE WILL WORK

;  CLOCK HANDLER 

CLKHND:	BIC #200,%LKS
	TST EODFLG
	BEQ 3$
	TST GLIDL
	BNE 31$
	CLR CLKCNT		; GOULD NOT SETTLED YET
	RTI

3$:	BIC #100,%LKS		; SHOW'S OVER, GO HOME
	CLR CLKCNT
	RTI

31$:	INC CLKCNT		; COUNTDOWN TO INDICATE LOSS OF ENABLE STATUS ON GOULD
	CMP #GLDTIM,CLKCNT	; SHORT TIMEOUT (1/2 SECOND) FOR PAPER SMEAR
	BEQ 2$
	RTI

2$:	PUSH R4
	MOV GLPTR,R4
	MOV #100000,(R4)+
	MOV SMEARP,(R4)+
	MOV R4,GLPTR
	MOV R4,GTPTR
	CLRB GLIBR
	POP R4
	CLR CLKCNT
	BIC #100,%LKS
	RTI

CLKCNT:	.WORD 0

SMEARP:	.WORD SMRBLK

;  POWER FAIL HANDLER 

POWROF:	MOV #RSTALL,%PWRV
	HALT

RSTALL:	MOV #POWROF,%PWRV
	JMP INIT


;  INTERRUPT ROUTINE FOR RECEIVE INPUT FROM PDP-10 VIA DL-11 
;			DEVICE 0
VCRD0:	.WORD SLRD0		; Vector to one of three routines: Line select
	.SEE CTRD0		;   Count
	.SEE PTRDO		;   Character out handler
CTRT0:	.WORD 0			; Count of characters remaining for this line
VCRT0:	.WORD 0			; Vector to tty status table

INRD0:	PUSH <R0,R1>
	MOV RDBF0,R0		; PICK UP CHARACTER
;	BPL 1$
;	MOV R0,DLSTA1
;	Fatal			; BAD CHARACTER
1$:	JMP @VCRD0

DLSTA1:	.WORD 0

SLRD0:	BIT #200,R0		; SELECT LINE FOR INPUT
	 BEQ RST2RT			; NO LINE SELECT WHEN EXPECTED, IGNORE IT.
1$:	BIC #200,R0		; CLEAR OUT LINE SELECT BIT
	cmp #dtty,r0		; Debug tty?
	 beq dbgtty		; Processing happens directly at interrupt level
	CMP R0,#MAXTTY-1
	BLOS 2$
	Fatal			; NON-EXISTENT TTY
2$:	ASL R0			; CONTRUCT INDEX TO PROPER INPUT QUEUE STATUS TABLE
	MOV RSTA(R0),VCRT0
	MOV #CTRD0,VCRD0
rst2rt:	POP <R1,R0>
	RTI


;;;	The debugging TTY stuff

;;  This routine doesn't use the usual software because I don't want to
;;   have to decipher its conventions. -s

dbgtty:	mov #dbgt1,vcrd0	; The debugging "tty"
	br rst2rt

dbgt1:	mov r0,Ctrt0		;Save byte count.
	mov #dbgt2,vcrd0
	br rst2rt

;;  Debug TTY continuation processor

;;		How it works.
;;       The problem is that there are co-operating processes each
;; of which wants its own control and data structures.  In order to
;; do that, we give each a PDL.  One process is main program
;; execution and interrupts other than this one, the other is the
;; debug-TTY process.  The interface has to allow both to leave off
;; and resume anywhere.  Packets going to the debug-tty may cross
;; message-blocks from the ten, and there may be more than one
;; debug-tty packet in a message-block.  So the debug-tty has its
;; own stack, kept in SavTPDL when the other stack is in use. 
;; When the debug-tty wants another character (.iot), it calls
;; dgtret, which exchanges pdl's and returns from the interrupt.
;; The next message for the debug TTY will bring about an exchange
;; of PDL's, and a RET executed on the debug-tty PDL, which will
;; return to the routine which wanted a character.


;; Dbgt2 handles getting back into debug-tty co-routine
dbgt2:	push <r2,r3>	;We'll need scratch registers.
	mov sp,sptemp	;Random temporary
	mov SavTPdl,sp	;Restore debug-tty PDL
	jmp @(sp)+	;Continue

sptemp:	.word 0		; Temporary for SP

;; Dgtfin handles getting back to MP co-routine while restoring
;;	debug co-routine so that it will start at the beginning
;;	next time.
dgtfin:	mov #dbt,(sp)
;; Dgtret returns to MP co-routine.
dgtret:	mov sp,SavTPdl
	mov sptemp,sp
	pop <r3,r2>
	br rst2rt

;;  Body of Debugging TTY stuff

;; Dbt: decode debugger instruction and dispatch.
dbt:	cmp r0,#maxhl	;Largest hali code
	bhi dbterr
	asl r0		;convert to word number
	jmp @dbtab(r0)	;dispatch

dbtab:	.irp y,<terr,read,write,terr,stop,continue,sstep,dmpreg,ldreg>
	  .word db'y
	.endm

	maxhl==.-dbtab-1

dbterr:	Fatal
;;Must be fatal because we don't know how many words to expect
;; Another possibility is to ignore subsequent stuff on that line.
;; that would also be a loss.

;; Handle hl.read
dbread:	call dbadrr	;Get address
	mov @(sp),(sp)	;Read
	call dbsend	;Send contents
	call dgtfin	;done

;; Handle hl.write
dbwrite: call dbadrr	;Get address
	mov @(sp),-(sp)	;Old contents
	call dbsend	;Send
	call dbadrr	;Get new contents
	mov (sp)+,@(sp)+  ;Write
	call dgtfin	;done

;; Handle hl.stop
dbstop:	Fatal

;; Handle hl.continue
dbcontinue: Fatal

;; Handle hl.sstep
dbsstep: Fatal

;; Handle hl.dmpreg
dbdmpreg: Fatal

;; Handle hl.ldreg
dbldreg: Fatal

;; Get a word from the 10.
dbadrr:	call dgtret	;Get a byte
	mov r0,-(sp)	;Stack up
	call dgtret	; another
	movb r0,1(sp)	;Put together result
	ret

;; Send word on top of stack to 10
dbsend:	movb 1(sp),r0
	.rept 3
	  asr r0
	.endr
	call hksend	;First byte
	mov (sp),r0
	bic #174077,r0
	.rept 6
	  asr r0
	.endr
	call hksend	;Second byte
	mov (sp)+,r0
	bic #177700,r0
;	jcall hksend	;Last byte


;; Send byte in r0 to 10 in hackish way: back up buffer pointer.
;;  If you fail, lose.

hksend:	bic #200,r0		;Make sure character cannot be mistaken as line select
	mov <tdst0+od.lim>,r1	;Get buffer readout pointer
	cmp r1,tdst0+od.ptr	;At write-in pointer?
;; would this be the same condition?:
;;	tst tdst0+od.blk
	beq hklose		;can't fiddle it.
	cmp r1,tdst0+od.beg	;at beginning?
	bne 1$
	 mov tdst0+od.end+2,r1	;then go back to end
1$:	sub #2,r1
	mov r1,tdst0+od.lim	;back up write pointer
	movb #dtty,(r1)+	;write in select
	movb r0,(r1)+		; and data byte.
	cmp r1,tdst0+od.ptr	;caught up to write-in pointer?
	bne 2$
	 inc tdst0+od.blk	;If so, set block indication
2$:	bis #100,xdst0
	ret

hklose:	Unmask
	Fatal


CTRD0:	MOV R0,CTRT0
	BNE 1$
	mov #slrd0,vcrd0	; ZERO LENGTH STRING
;	Fatal
	br 2$
1$:	MOV #PTRD0,VCRD0
2$:	jmp rst2rt

PTRD0:	push r2
	MOV VCRT0,R1		; PLACE CHARACTER INTO INPUT QUEUE
	MOV RI.PTR(R1),R2
	MOVB R0,(R2)+		; THERE IT GOES ... (PLOP)
	CMP R2,RI.END(R1)
	BNE 1$
	MOV RI.BEG(R1),R2
1$:	CMP R2,RI.LIM(R1)
	BNE 2$
	Fatal			; DATA OVERRUN, SCREWED ALLOCATION
2$:	MOV R2,RI.PTR(R1)
	DEC CTRT0
	BNE 3$
	MOV #SLRD0,VCRD0
3$:	CLRB @RI.FLG(R1)		; SIGNAL MAIN PROGRAM THAT A CHARACTER IS READY
	MOV #NOPIN,WAITPL
IN0XIT:	POP r2
	jmp rst2rt


;  INTERRUPT ROUTINE FOR TRANSMIT OUTPUT TO PDP-10 VIA DL-11 

;NOTE: HAVE MTTY'S INDIRECT THROUGH TRANSMIT OUTPUT STATUS TABLE
; (IMPLEMENTS MANY TO ONE FUNCTION)
LINEN:	0			; CURRENT LINE NUMBER

INTD0:	PUSH <R0,R1,R2>		; INTERRUPT TRANSMIT DEVICE 0

	MOV #TDST0,R1		; PICK UP POINTER TO STATUS TABLE FOR TRANSMIT DEVICE 0
	MOV OD.LIM(R1),R2	; PICK LOAD POINTER TO CHARACTER DATA
	MOVB (R2)+,R0		; PICK UP LINE NUMBER
	CMPB R0,LINEN
	 BEQ 1$			; LINE HAS BEEN PREVIOUSLY SELECTED
	MOVB R0,LINEN		; SEND LINE SELECT BUT DON'T UPDATE POINTER
	BIC #MBYTE,R0
	BR 4$
1$:	MOVB (R2)+,R0		; GET DATA, AND NOW UPDATE POINTER
	CMP R2,OD.END(R1)	; ARE WE AT END OF BUFFER
	 BNE 2$
	MOV OD.BEG(R1),R2	; THEN CIRCLE AROUND TO THE BEGINNING
2$:	CMP R2,OD.PTR(R1)	; HAVE WE CAUGHT UP WITH INSERTION POINTER?
	 BNE 3$
	BIC #100,XDST0		; THEN TURN OFF INTERRUPT
3$:	MOV R2,OD.LIM(R1)	; UPDATE POINTER (ALWAYS EVEN HERE)
	CLR OD.BLK(R1)
4$:	MOV R0,XDBF0		; AND PUT OUT CHARACTER
	POP <R2,R1,R0>
	RTI


;  INTERRUPT ROUTINE FOR INPUT FROM TTY 

INRTSB:	PUSH R0
	MOV @RTBF(R3),R0	; PICK UP CHARACTER
	 BPL 1$
	MOV R0,DLSTA2		; SAVE BITS FOR A PORT MORTEM
	BR 2$
1$:	BIC #200,R0		; GET RID OF THAT 8'TH BIT!
	CALL INRPUT
2$:	POP R0
	RET 

DLSTA2:	.WORD 0

INRPUT: PUSH <R1,R2>
	MOV TSTA(R3),R1		; PICK UP POINTER TO TRANSMIT STATUS TABLE 0
	TST TI.BLK(R1)
	 BEQ 2$
	CLRB @CG.FLG(R1)
	MOV RSTA(R3),R2
	INC MR.BLK(R2)
	 BR 5$
2$:	MOV TI.PTR(R1),R2
	MOV R0,(R2)+
	CMP R2,TI.END(R1)
	 BNE 3$
	MOV TI.BEG(R1),R2
3$:	CMP R2,TI.LIM(R1)
	BNE 4$
	INC TI.BLK(R1)
4$:	MOV R2,TI.PTR(R1)
	CLRB @TI.FLG(R1)
5$:	MOV #NOPIN,WAITPL
	POP <R2,R1>
	RET

;  KEYBOARD MULTIPLEXER INTERRUPT ROUTINE 
; CURRENT FORMAT IS THE 3 HIGH BITS ARE KEYBOARD ID.
; BIT 0 (LOW) IS SHIFT, BIT 1 IS TOP, BITS 2-7 ARE KEY NUMBER,
; BIT 8 IS CTRL, BIT 9 IS META, BIT 10 IS SHIFT, BIT 11 IS SHIFT LOCK
; AND BIT 12 IS TOP.  (BITS 13-15 ARE THE ID).

IDBITS=160000

KEY:	.WORD 0

KEYINT:	PUSH <R0,R3>
KEYIN1:	MOV KEYBUF,KEY		; PICK UP THE DATA
	MOVB KEY,R3
	BIC #MBYTE,R3		; FLUSH SIGN EXTENSION
	MOVB AIKTAB(R3),KEY	; CONVERT KEY CODE BY TABLE LOOKUP

; NEXT 7 INSTR WILL EVENTUALLY BE: MOVB KEYADR,R3
	
	MOV KEY,R3		; FIND TERMINAL ID FROM KEYBOARD ID
	.REPT 4
	ROL R3
	.ENDR
	BIC #MAXMUX,R3		; GET KEYBOARD ID
	ASL R3
	MOV KEYTAB(R3),R3	; FIND TTY LINE ASSOCIATED WITH THIS KBD

	CMPB #%KYBRK,KEY	; CHECK FOR BREAK
	 BNE 1$
	BITB #<%TXMTA_-7>,KEY+1	; C-M-BREAK?
	 BEQ 10$
	BITB #<%TXCTL_-7>,KEY+1
	 BEQ 10$		; CONTROL-BREAK IS LIKE BREAK
	JMP INIT		; SUPER INIT ON CONTROL-META-BREAK
10$:	CALL INTYSB
	BITB #<%TXMTA_-7>,KEY+1
	 BEQ 2$			; REGULAR BREAK
	MOVB #%KYCLR,KEY	; CLEAR ON META BREAK

1$:	BIC #IDBITS,KEY	; CLEAR OUT THE ID BITS
	MOV KEY,R0
	CALL INRPUT		; GET ARG FROM R0

	BIT #200,KEYSTA		; ANOTHER INTERRUPT IMMEDIATELY PENDING?
	 BNE KEYIN1
2$:	POP <R3,R0>
	RTI

; KEYBOARD VECTOR TABLE ( EACH ENTRY CONTAINS <TTY_CHANNEL_NUMBER>*2)

KEYTAB:	.WORD 2
	.WORD 10
	.WORD 10
	.WORD 10
	.WORD 12
	.WORD 12
	.WORD 12
	.WORD 12		; Tektronix T24

	.BLKW 4	; LEAVE SPACE FOR TOTAL OF 8 ENTRIES

;  INTERRUPT ROUTINE FOR OUTPUT TO TTY 

INTTSB:	PUSH <R1,R2>
	MOV RSTA(R3),R1
	MOV RO.LIM(R1),R2
	TST RO.BLK(R1)
	 BNE 1$
	CMP R2,RO.PTR(R1)
	 BNE 1$
	BIC #100,@XTST(R3)	; NOTHING MORE TO DO SO TURN INTERRUPT ENABLE OFF.
	BR 3$

1$:	MOVB (R2)+,@XTBF(R3)
	CMP R2,RO.END(R1)
	 BNE 2$
	MOV RO.BEG(R1),R2
2$:	MOV R2,RO.LIM(R1)
	CLR RO.BLK(R1)
3$:
	POP <R2,R1>
	RET

;  INTERRUPT ROUTINE FOR OUTPUT TO THE ANN ARBOR DISPLAY CONTROLERS
AA1==4*2			; FIRST AA CHANNEL
AA2==AA1+2			; SECOND AA CHANNEL
AAINTA:	AA1			; WORDS FOR ALTERNATING WHO GETS LOOKED AT FIRST
AAINTB:	AA2
AABITS:	.WORD 1
	.WORD 2

AAINT:	PUSH <R1,R2,R3>
	MOV AAINTA,R3		; FIRST CHECK AAINTA
	MOV RSTA(R3),R1		; GET AAINTA STATUS BLOCK PTR
	MOV RO.LIM(R1),R2	; GET AAINTA BUFFER PTR
	TST RO.BLK(R1)		; IS AAINTA OUTPUT BLOCKED
	 BNE 1$			; YES, GO PUT SOME OUT
	CMP R2,RO.PTR(R1)	; IS THERE STUFF TO DO FOR AAINTA?
	 BNE 1$			; YES, GO DO IT
	MOV AAINTB,R3		; NONE OF THE ABOVE, TRY AAINTB
	MOV RSTA(R3),R1
	MOV RO.LIM(R1),R2
	TST RO.BLK(R1)
	 BNE 1$
	CMP R2,RO.PTR(R1)
	 BNE 1$
	BIC #100,%AACS	; NOTHING MORE TO DO SO TURN INTERRUPT ENABLE OFF.
	BR 2$
1$:	CALL AAINT1
	MOV AAINTA,R3		; SWAP AAINTA,AAINTB
	MOV AAINTB,R2
	MOV R3,AAINTB
	MOV R2,AAINTA
2$:	POP <R3,R2,R1>
	RTI

; ASSUMES R1,R2,R3 ARE SET UP

AAINT1:	CLR -(SP)		; ALLOCATE A PDL SLOT
	MOVB (R2)+,(SP)		; PUT DATA IN RH
	CMPB #%BELL,(SP)
	 BNE 1$
	BISB <AABBIT-AA1>(R3),1(SP)
1$:	BISB <AABITS-AA1>(R3),1(SP)	; SET BITS IN LH
	MOV (SP)+,%AABF		; PUT DATA OUT
	CMP R2,RO.END(R1)
	 BNE 2$
	MOV RO.BEG(R1),R2
2$:	MOV R2,RO.LIM(R1)
	CLR RO.BLK(R1)
	RET

;  GOULD INTERRUPT HANDLER 

GLDINT:	PUSH <R0,R4,R5>
	MOV GTLIM,R4
GLDERR:	TST GLERR		; ARE WE ALREADY IN AN ERROR STATE?
	BNE 2$
	BIT #%GSERR,GLDCSR	; SHOULD WE GO TO AN ERROR STATE?
	BEQ 1$

	MOVB GLDCSR+1,STAERR		; YEP
	INC GLERR		; INFORM WORLD THAT GOULD IS IN TROUBLE
	INC PAGMNG		; COUNT OF PAGE MUNGING INCIDENTS
				; FOR END OF GOULD ERROR MONITOR
	CLRB STATBR		; TELL UNSPOOLR WHAT HAPPENED
	JMP GLIXIT

2$:	BIT #%GSERR,GLDCSR	; IS AN ERROR STILL PRESENT?
	BEQ 3$
	 JMP GLIXIT		; YEP

3$:	CLR GLERR		; NOPE, CLEAN UP
			; WE ARE ASSUMING THAT SELECTION IS PRESERVED WHEN SYSTEM
			; RESET IS ACHIEVED FOLLOWING MANUAL ERROR CORRECTION
			; (HOPEFULLY, THIS OCCURS WHEN THE PRINTER IS BROUGHT ON LINE)

1$:	JMP @GLIPTR

CMIDEC:	TST JMPFLG		; IF IN MIDDLE OF JUMP MACRO, SHOULD NOT
				; TEST FOR BUFFER LIMITS OR COMMAND COMPLETION
	 BNE 112$
	CMP R4,GLEND		; ARE WE EQUAL TO OR GREATER THAN THE END OF
				; THE FIRST BUFFER LIMIT?
	BLO 111$
	MOV GLBEG,R4		; THEN CIRCLE AROUND TO BEGINNING
111$:	TST REPFLG		; IF IN REPEAT, SHOULD NOT TEST COMMAND COMPLETION
	 BNE 1$
	MOV R4,GLLIM		; SUCCESSFUL COMPLETION OF A FULL COMMAND,
				; UPDATE POINTER THAT MAIN PROGRAM LOOKS AT

	CLR GLBLK		; IN CASE M.P. IS HUNG FOR LACK OF SPACE

1$:	CMP R4,GLPTR		; NOTHING LEFT TO DO?
	BNE 112$
	INC GLIDL		; COMPLAIN TO WORLD
	JMP GLIXIT

112$:	BIT #%GSPAP,GLDCSR	; IS GOULD RUNNING LOW ON PAPER?
	BEQ 11$
	MOVB GLDCSR+1,STAERR		; YEP
	CLRB STATBR		; TELL UNSPOOLER WHAT IS ABOUT TO HAPPEN

11$:	CLR GLIDL		; WE GOT SOMETHING TO DO
	MOV (R4)+,R0
	BMI 2$			; BRANCH IF INTERNAL MACRO COMMAND

14$:	CMP R0,#5		; IF LAST LINE FLAG, DON'T WANT TO WAIT FOR SBUSY
	BEQ 15$


	BIT #%GSBSY,GLDCSR
	BNE 12$			; BRANCH IF BUSY
15$:	SWAB R0
	TSTB R0			; TEST FOR DELAYED COMMAND
	BNE 4$

; IMMEDIATE GOULD COMMAND
	SWAB R0
	BIT #170,R0		; THE FOUR UNUSED BITS IN THE GOULD
				; COMMAND BYTE
	 BEQ 115$
	MOV #PAGLST,R5		; REQUEST FOR TAILSHEET PAGE MUNGING STATUS
	MOV PAGMNG,R0
	CALL CHRNUM
	CLR PAGMNG		; RESET FOR NEXT FILE
	 BR 116$
115$:	MOVB R0,GLDCSR
116$:	MOV #CMIDEC,GLIPTR
	 JMP CMIDEC

; DELAYED GOULD COMMAND
4$:	SWAB R0
	MOVB R0,GLDCSR
	MOV #CMIDEC,GLIPTR
	BR GLIXIT	

12$:	MOV R0,PNDR0
	MOV #13$,GLIPTR
	 BR GLIXIT
	
13$:	MOV PNDR0,R0
	BR 14$


2$:
; MOBY COMMAND
	BIT #17400,R0
	BNE 5$			; DMA COMMAND
	BIT #40000,R0		; REPEAT COMMAND
	BNE 3$
	BIT #20000,R0		; CURRENT PAGE COMMAND
	BNE 6$


; JMP COMING UP
	BIT #1,R0
	BEQ 21$

; POP
	MOV JMPRET,R4
	CLR JMPFLG
	 JMP CMIDEC

;PUSH
21$:	MOV (R4)+,R0		; PUT JUMP ADDRESS INTO R0
	MOV R4,JMPRET		; JMPRET IS ADDRESS AFTER JUMP COMMAND
	INC JMPFLG
	MOV R0,R4
	 JMP CMIDEC

3$:
; REPEAT COMING UP
	BIT #1,R0
	BEQ 31$

; POP
	DEC REPCNT
	 BNE 32$
	CLR REPFLG
	 JMP CMIDEC		; R4 IS LEFT POINT TO INSTRUCTION AFTER REPEAT LOOP

32$:
; ITERATE
	MOV REPRET,R4
	 JMP CMIDEC



;PUSH
31$:	MOV (R4)+,REPCNT	; REPEAT COUNT GOES INTO R0
	MOV R4,REPRET		; REPRET IS THE ADDRESS OF BEGINNING OF LOOP
	INC REPFLG
	 JMP CMIDEC

6$:
; CURRENT PAGE COMMAND COMING UP
	MOVB R0,STAPAG
	 JMP CMIDEC

5$:
; DMA COMMAND COMMING UP
	BIT #%GSDON,GLDCSR
	 BEQ 51$
	MOV R0,GLDWC		; COUNT
	MOV R4,GLDCA		; ADDRESS
	NEG R0
	ASL R0
	ADD R0,R4

53$:	BIT #%GSDON,GLDCSR
	 BEQ 52$
	MOV #CMIDEC,GLIPTR
	 JMP CMIDEC

52$:	MOV #53$,GLIPTR
	 BR GLIXIT

51$:	MOV #5$,GLIPTR
	 BR GLIXIT

GLIXIT:	MOV R4,GTLIM

	POP <R5,R4,R0>
	RTI


; INTERRUPT ROUTINES NOT YET DEFINED

PLPINT:	RTI		; PLASMA DISPLAY

IMLINT:	RTI		; IMLAC

NULL:	RTI		; DUMMY



.SBTTL MAIN PROGRAM QUEUE PROCESSING ROUTINES
;  MAIN PROGRAM ROUTINE FOR RECEIVED CHARACTER PROCESSING 

MRTYSB:	MOV RSTA(R3),R1		; CREATE POINTER TO RECEIVE STATUS BLOCK
	TST RO.BLK(R1)
	 BNE 3$
	TST MR.BLK(R1)
	 BEQ 4$
3$:	ADD #4,(SP)
	RET

4$:	TST RS.CNT(R1)		; CHECK FOR BUFFERED CHARS
	 BEQ RCHGET

RTSTRH:	MOVB @RS.PTR(R1),R0
	DEC RS.CNT(R1)
	 BNE 1$
	MOV RSTR(R3),RS.PTR(R1)
	BR RCHPUT
1$:	INC RS.PTR(R1)
	BR RCHPUT


RCHGET:	MOV RI.LIM(R1),R2
	MOVB (R2)+,R0		; PICK UP CHARACTER
	CMP R2,RI.END(R1)	; ARE WE AT THE END OF THE BUFFER?
	 BNE 1$
	MOV RI.BEG(R1),R2	; CIRCLE AROUND TO BEGINNING THEN
1$:	MOV R2,RI.LIM(R1)	; UPDATE POINTER

	DEC ALNUM(R3)		; UPDATE ALLOCATION
	 BGT 2$
	JMP INIT		; ALLOCATION SCREWED
2$:	CMP ALNUM(R3),#ALCLIM	; NEED TO ALLOCATE CHARACTERS?
	 BGE 20$
	CALL ALLCSB		; CALL ALLOCATION SUBROUTINE

20$:	TST RO.ESF(R1)		; WAITING FOR AN ESCAPE CHAR?
	 BEQ 3$			; NOPE
	TST JMPESC(R1)		; WAITING FOR CURSOR POSITION ESCAPE?
	 BEQ 21$
	JMP @JMPESC(R1)

21$:	BIC #MASK37,R0		; GET THE ESSENTIALS OF THE CODE
	ASL R0			; DONT NEED R0 ANYMORE.
	JMP @VT52TB(R0)

3$:	CMP R0,RO.ESC(R1)	; ESCAPE CHAR?
	 BNE 31$
	INC RO.ESF(R1)		; JUST SET A FLAG.  DON'T STUFF CHAR.
	BR MORECK

31$:	CMP #40,R0		; CONTROL CHAR?
	 BLE 32$
	CMP #%TCAAD,TCTYP(R3)
	 BNE RCHPUT
	MOV R0,R2		; SAVE R0 FOR USE UPON RETURN FROM CONTROL CHAR ROUTINES
	ASL R2
	JMP @AACTLT(R2)

32$:	INC COL(R1)		; ORDINARY CHARS COME HERE.
	CMP #%TCAAD,TCTYP(R3)
	 BNE RCHPUT
	CMP #AACOLX,COL(R1)	; CHECK FOR TYPEOUT IN LAST COLUMN
	 BNE RCHPUT
	MOV RS.PTR(R1),R4	; MUST REPOSITION THE CURSOR
	MOVB R0,(R4)+		; USE THE STRING BUFFER
	INC RS.CNT(R1)
	CALL CPOSDO
	JMP RTSTRH


RCHPUT:	MOV RO.PTR(R1),R2
	MOVB R0,(R2)+		; PUT THE CHAR INTO THE RECEIVE OUTPUT BUFFER
	CMP R2,RO.END(R1)	; ARE WE AT THE END OF THE BUFFER?
	 BNE 1$
	MOV RO.BEG(R1),R2	; CIRCLE AROUND TO BEGINNING THEN
1$:	CMP R2,RO.LIM(R1)	; FROM HERE ON, THERE SHOULD BE SOME OUTPUT TO GO OUT
	 BNE MORECK
	INC RO.BLK(R1)		; BLOCK QUEUE

MORECK:	MASK 6			; DONT ALLOW TRANSMIT INTERRUPTS NOW
	TST RS.CNT(R1)
	 BNE 1$			; MORE CHARS LEFT IN THE STRING BUFFER.
	CMP RI.LIM(R1),RI.PTR(R1)
	 BNE 1$			; STILL HAVE CHARS WAITING TO BE PROCESSED
	MOV SRTY(R3),@MRTY(R3)	; NO CHARS PENDING PATCH UP BRANCH INSTRUCTION
1$:	TST RO.ESF(R1)
	 BNE 5$			; JUST WAITING FOR MORE CHARS.  NO OUTPUT YET.
	MOV #WAITIN,WAITPL	; PATCH WAIT INSTRUCTION
	CMP XTST(R3),#XTSTD	; IS THIS A DUMMY CHANNEL?
	 BEQ 5$			; YES, SO PUNT THIS
	MOV R2,RO.PTR(R1)	; UPDATE POINTER
	BIT #100,@XTST(R3)	; INTERRUPTS ENABLED?
	 BNE 5$			; YES
	CMP #AA1,R3
	 BNE 3$
2$:	MOV RSTA(R3),R1
	MOV RO.LIM(R1),R2
	CALL AAINT1
	 BR 4$
3$:	CMP #AA2,R3
	 BEQ 2$ 
	CALL INTTSB		; NO, GET THE BALL ROLLING
4$:	BIS #100,@XTST(R3)	; ACTIVATE INTERRUPT FOR OUTPUT TO DEVICE
5$:	UNMASK			; INTERRUPTS CAN HAPPEN NOW.
	RET


; ANN ARBOR ESCAPE HANDLERS
AANOOP:	CLR R0
	BR AACPUT

AAMVUP:	MOV #16,R0		; MOVE UP
	DEC ROW(R1)
	BR AACPUT

AAMVDN:	MOV #12,R0		; MOVE DOWN
	INC ROW(R1)
	BR AACPUT

AAMVRT:	MOV #11,R0		; MOVE RIGHT
	INC COL(R1)
	BR AACPUT

AAMVLF:	MOV #10,R0		; MOVE LEFT
	DEC COL(R1)
	BR AACPUT

AAHOME:	MOV #13,R0		;  HOME UP
	CLR ROW(R1)
	CLR COL(R1)
;	BR AACPUT

AACPUT:	CLR RO.ESF(R1)
	JMP RCHPUT


AAEOL:	MOV RS.PTR(R1),R4	; CLEAR TO END OF LINE
	CALL CPOSDO
	MOV #80.,R2
	SUB COL(R1),R2
	CALL EOLDO
	BR AADONE

AAEOS:	TST ROW(R1)		; CLEAR TO END OF SCREEN
	 BNE 1$
	TST COL(R1)
	 BNE 1$
	MOV #14,R0
	BR AACPUT

1$:	MOV RS.PTR(R1),R4
	MOV #24.,R5
	SUB ROW(R1),R5
	MOV #80.,R2
	SUB COL(R1),R2

2$:	CALL EOLDO
	MOV #80.,R2		; ASSUME WRAPAROUND TO NEXT LINE HAS HAPPENED 
	DEC R5
	 BGT 2$

AADONE:	CALL CPOSDO		; RESTORE THE CURSOR POSITION
	CLR RO.ESF(R1)
	JMP RTSTRH

EOLDO:	ADD R2,RS.CNT(R1)
1$:	MOVB #40,(R4)+			; SPACE
	DEC R2
	 BGT 1$
	RET


AAPOS:	MOV #AAPOS1,JMPESC(R1)		; ABSOLUTE CURSOR POSITION
	JMP MORECK				; ALL WE GOT SO FAR IS $Y

AAPOS1:	SUB #40,R0			; GOT THE ROW
	MOV R0,ROW(R1)
	MOV #AAPOS2,JMPESC(R1)		; WAIT FOR THE COLUMN
	JMP MORECK

AAPOS2: SUB #40,R0			; GOT THE COLUMN
	MOV R0,COL(R1)
	MOV RS.PTR(R1),R4
	CALL CPOSDO
	CLR JMPESC(R1)
	CLR RO.ESF(R1)
	JMP RTSTRH

CPOSDO:	MOVB #%AAPOS,(R4)+		; PUT THE CURSOR POS COMMAND CODE
	MOV COL(R1),R0			; FORMAT THE COLUMN
	CLR R5
1$:	SUB #10.,R0			; DIVIDE BY 10 (DAMN BCD FORMAT!!)
	BLT 2$
	INC R5
	BR 1$
2$:	ADD #10.,R0			; R0 HAS REMAINDER, R5 THE QUOTIENT
	.REPT 4				; SHIFT LEFT 4 BITS TO GET BCD
	ASL R5
	.ENDR
	ADD R5,R0
	MOVB R0,(R4)+
	MOV ROW(R1),R0			; FORMAT THE ROW
	BIS #100,R0
	MOVB R0,(R4)+
	ADD #3,RS.CNT(R1)
	RET				; SOMEONE ELSE RESTORES RS.PTR



; CONTROL CHAR ROUTINES
AACTRL:	BR AACXIT

AABELL:	MOV #%BELL,R0
	BR AACXIT

AABBIT:	.WORD 100
	.WORD 140

AABS:	DEC COL(R1)
	BR AACXIT

AATAB:	ADD #8.,COL(R1)
	BIC #7,COL(R1)
	CMP #79.,COL(R1)
	 BGE 1$
	MOV #79.,COL(R1)
1$:	MOV RS.PTR(R1),R4
	CALL CPOSDO
	JMP RTSTRH

AALF:	INC ROW(R1)		; MUST USE CPOS SO ^J IN LAST COL WORKS
	MOV RS.PTR(R1),R4
	CALL CPOSDO
	JMP RTSTRH

AAVT:	DEC ROW(R1)
	BR AACXIT

AAFF:	CLR ROW(R1)
	CLR COL(R1)
	BR AACXIT

AACR:	CLR COL(R1)		; MUST USE CURSOR POS SO THAT ^M IN LAST
	MOV RS.PTR(R1),R4	; COLUMN WILL WORK
	CALL CPOSDO
	JMP RTSTRH

AACXIT:	JMP RCHPUT


;  MAIN PROGRAM ROUTINE FOR TRANSMITED CHARACTER PROCESSING 

MTTYSB:	MOV TSTA(R3),R1
	TST MT.BLK(R1)
	 BNE 1$
	TST @TO.BLK(R1)		; IS OUTPUT BLOCKED
	 BEQ 2$
1$:	ADD #4,(SP)		; YEP, PRETEND NOTHING HAPPENED
	RET
2$:	TST TS.CNT(R1)
	 BEQ TCHGET

; TEMPORARY STRING HANDLER
TTSTRH:	MOV @TS.PTR(R1),R0
	DEC TS.CNT(R1)
	 BNE 1$
	MOV TSTR(R3),TS.PTR(R1)
	CLR AL.BLK(R1)
	BR TCHPUT
1$:	ADD #2,TS.PTR(R1)
	BR TCHPUT

; CURRENT FORMAT OF CHARACTER DATA WORD (WILL BE CHANGED FOR NEW INPUT MUXER
; AND DMA IMLAC INTERFACE).
; %MXDAT=100000		THIS DATA CAME FROM THE INPUT MULTIPLEXOR
; MASCII=177600		ASCII PART OF THE DATA
; %SPKEY=200		SPECIAL KEY
; %SBITS=MASK37		SPECIAL BITS
; %SHLOK=10		SHIFT LOCK (INPUT)
; IN THE INPUT WORD, THE BITS BELOW ARE LSH'D 1 (SO THEY ALL APPEAR IN THE HIGH BYTE)
; IN THE OUTPUT SEQUENCE, THE LEFT BYTE HAS 100 ADDED TO IT.
%TXTOP=4000		; TOP BIT
%TXSFL=2000		; SHIFT LOCK
%TXSHT=1000		; SHIFT
%TXMTA=400		; META
%TXCTL=200		; CONTROL

TCHGET:	MOV TI.LIM(R1),R2
	MOV (R2)+,R0
	CMP R2,TI.END(R1)
	 BNE 1$
	MOV TI.BEG(R1),R2
1$:	MASK 4
	MOV R2,TI.LIM(R1)
	CLR TI.BLK(R1)
	UNMASK

	BIT #%SPKEY,R0		; CHECK FOR SPECIAL CODES (> 177)
	 BEQ 2$
	MOV R0,R2
	BIC #MASK37,R2		; GET THE ESSENTIAL BITS
	ASL R2
	JMP @SKEYTB(R2)		; GO DO SOMETHING SPECIAL

2$:	CMP R0,#CBSL		; CNTL BACKSLASH?
	 BNE 3$
	MOV TS.PTR(R1),R2
	MOV R0,(R2)+		; QUOTE IT
	MOV R0,(R2)+
	MOV #2,TS.CNT(R1)
	INC AL.BLK(R1)
	BR TTSTRH

3$:	MOV R0,R2
	SWAB R2
	BIC #%SBITS,R2		; ANY META, CNTL, TOP, ETC. STUFF?
	 BEQ TCHPUT		; NO
	BIS #100,R2
	PUSH R2			; CONSTRUCT TEMPORARY CHARACTER STRING FOR SPECIAL
	BIC #MASCII,R0
	BIT #%SHLOK,R2		; SHIFT LOCK HACKERY
	 BEQ 4$
	BIT #100,R0		; TEST FOR ALPHABETIC CHARS
	 BEQ 4$
	MOV R0,R2
	BIC #MASK37,R2
	 BEQ 4$
	CMP #33,R2
	 BLE 4$
	MOV #40,R2
	BIC R2,R0		; CLEAR THE 40 BIT
	
4$:	MOV TS.PTR(R1),R2	; CHARACTER ESCAPE SEQUENCE
	MOV #CBSL,(R2)+
	MOV (SP)+,(R2)+		; POP special bits
	MOV R0,(R2)+
	MOV #3,TS.CNT(R1)
	INC AL.BLK(R1)
	BR TTSTRH

TCHPUT:	MOVB TTYNUM(R1),-(SP)	; CONSTRUCT CHARACTER MESSAGE (CHARACTER,,LINE SELECT)
	BIC #%SPKEY,R0		; DONT SEND 8 BIT CHARS!!
	MOVB R0,1(SP)
	MOV @TO.PTR(R1),R2
	MOV (SP)+,(R2)+
	CMP R2,@TO.END(R1)
	 BNE 1$
	MOV @TO.BEG(R1),R2

1$:	MASK 6			; INTERRUPT SENSITIVE
	CMP R2,@TO.LIM(R1)	; SEE IF OUTPUT IS NOW BLOCKED
	 BNE 2$
	INC @TO.BLK(R1)		; YES, SO SET INDICATOR

2$:	TST TS.CNT(R1)
	 BNE 3$			; THERE IS STILL MORE TEMPORARY STRING STUFF TO DO.
	CMP TI.LIM(R1),TI.PTR(R1)
	 BNE 3$			; THERE ARE MORE INPUT CHARS BUFFERED.
	MOV STTY(R3),@MTTY(R3)	; NOTHING LEFT TO DO.

3$:	MOV R2,@TO.PTR(R1)	; UPDATE THE OUTPUT POINTER NOW
	MOV #WAITIN,WAITPL
	BIS #100,XDST0		; ENABLE INTERRUPTS
	UNMASK
	RET


.SBTTL  SPECIAL KEY HANDLERS

NONAS1:	JMP KNOOP		; IGNORE IT

KBRK:	JCALL INTYSB		; NORMALLY HANDLED AT INTERRUPT LEVEL

KESC:	BIT #<%TXSHT_1>,R0	
	 BEQ 1$
	CMP #%TCTEK,TCTYP(R3)
	 BNE 1$
	PUSH <R1,R2>		; HACK FOR TEKTRONIX (SIMPLE, NO ERROR CHECKS)
	MOV RSTA(R3),R1		; CREATE POINTER TO RECEIVE STATUS BLOCK
	MOV RO.PTR(R1),R2
	MOVB #26,(R2)+		; PUT THE CHAR INTO THE RECEIVE OUTPUT BUFFER
	CMP R2,RO.END(R1)	; ARE WE AT THE END OF THE BUFFER?
	 BNE 10$
	MOV RO.BEG(R1),R2	; CIRCLE AROUND TO BEGINNING THEN
10$:	MASK 6
	MOV R2,RO.PTR(R1)	; UPDATE POINTER
	BIS #100,@XTST(R3)	; ACTIVATE INTERRUPT FOR OUTPUT TO DEVICE
	UNMASK
	POP <R2,R1>
	JMP KNOOP
1$:	; PUT COMMAND DISPATCH HERE SOMEDAY
	JMP KNOOP

KCALL:	MOV #32,R0
	JMP TCHPUT

KCLEAR:	MOV TS.PTR(R1),R2	;SEND ^_L
	MOV #37,(R2)+
	MOV #114,(R2)+
	MOV #2,TS.CNT(R1)
	INC AL.BLK(R1)
	JMP TTSTRH

KDEL:	MOV #%GRTS1,GTVBUF
	JMP KNOOP
KCIRM:	MOV #%GRTS2,GTVBUF
	JMP KNOOP
KGRAD:	MOV #%GRTS3,GTVBUF
	JMP KNOOP
KCIRP:	MOV #%GRTS4,GTVBUF
	JMP KNOOP
KBACK:
KNEXT:	MOV #37,R0
	JMP TCHPUT

KHELP:	MOV #%GRTST,GTVBUF
	JMP KNOOP
KFORM:
KBS:
KVT:
KCR:
KLINE:
FDELT:
KRPT:
KTAB:
KSPACE:
KNOOP:	MASK 6			; INTERRUPT SENSITIVE CODE
	CMP TI.LIM(R1),TI.PTR(R1)
	 BNE 1$			; THERE ARE MORE INPUT CHARS BUFFERED.
	MOV STTY(R3),@MTTY(R3)	; NOTHING LEFT TO DO.
1$:	CLR TI.BLK(R1)
	MOV #WAITIN,WAITPL
	UNMASK
	RET


.SBTTL GOULD MAIN PROGRAM ROUTINE 

MRGLSB:	MOV RSTA(R3),R1
;	TST MR.BLK(R1)		; NOTHING SHOULD SET THIS
;	 BNE 11$
;	TST RO.BLK(R1)		; UNNECESSARY UNTIL WE GET A CONSOLE DEVICE
;	 BNE 11$
	TST GLBLK		; OUTPUT QUEUE FILLED
	 BNE 11$
	TST GLERR		; IN THE MIDST OF SOME ERROR
	 BEQ 10$
11$:	ADD #4,(SP)
	RET

10$:	MOV RI.LIM(R1),R2
	MOV GTPTR,R4		; TEMPORARY POINTER (NECESSARY SINCE ITEMS
				; IN QUEUE HAVE "WIDTH")

JMPDEC:	JMP @GLDPND		; DISPATCH TO ANY PENDING OPERATIONS DUE TO GL QUEUE
				; BLOCKAGE (DEFAULT IS CHRDEC)

CHRDEC:	DEC ALNUM(R3)
	BGT 4$
	Fatal
4$:	MOVB (R2)+,R0		; PICK UP CHARACTER
	BPL DATHAC		; SKIP AROUND IF CHARACTER IS NOT AN EIGHT BIT CODE
	TST QOTFLG		; IS THIS CHARACTER TO BE QUOTED?
	 BEQ 2$
	CLR QOTFLG		; YEP, PASS IT ON
	BR DATACH
2$:	CMPB R0,#%CCACK		; ARE WE BEING PAGED?
	 BNE HERE
	MOVB GLDCSR+1,STAERR
	CLRB STATBR		; RESPOND WITH STATUS (ACTIVATE DAEMON)
	 JMP GLOOP

HERE:	CMPB R0,#%CCSOD		; START OF DATA?
	BNE 4$
	CLR EODFLG		; YEP, FLAG START OF DATA
	 JMP GLOOP
4$:	TST EODFLG		; ARE WE RECEIVING RANDOM CHARACTERS?
	 BEQ 51$
	 JMP GLOOP		; FORGET THEM
51$:	CMPB R0,#%CCQOT		; SHOULD WE QUOTE THE NEXT CHARACTER?
	 BNE 5$
	INC QOTFLG		; YEP
	 JMP GLOOP
5$:	CMPB R0,#%CCEOD		; END OF DATA?
	 BNE DATACH
	INC EODFLG		; YEP, FLAG END OF DATA
	BIS #100,%LKS 		; START UP CLOCK (COUNT DOWN FOR SMEAR PAGE)
	 JMP GLOOP

DATHAC:	TST EODFLG		; NON EIGHT BIT CODE, IS IT RANDOM DATA?
	BEQ DATACH
	JMP GLOOP

DATACH:	JMP @WRDPTR		; MUST BE DATA THEN

MAKWD1:	MOVB R0,TMPWRD		;FIRST PIECE OF WORD
	MOV #MAKWD2,WRDPTR
	 JMP GLOOP

MAKWD2:	MOVB R0,TMPWRD+1	;SECOND PIECE OF WORD
	MOV #MAKWD1,WRDPTR

	JMP @GLDPTR		; DISPATCH TO PROPER COMMAND HANDLER

DATDEC:	TST TMPWRD		; COMMAND OR LINE BUFFER?
	 BMI COMDEC
	 JMP DMADEC		; BIT 15 NOT SET, LINE BUFFER



.SBTTL GOULD COMMAND PROCESSING
;  COMMAND DECODING 


COMDEC:	BIC #100000,TMPWRD	; REMOVE COMMAND BIT
	MOV R4,R5
	ADD #4,R5		; ADD 4, R5 POINTS TO LAST LOCATION IN POTENTIAL COMMAND

	MASK 6
	CMP GTPTR,GLLIM		; ARE WE AHEAD OF PICK UP POINTER ANYWAY?  (THEN OK)
	BHIS 2$
	CMP R5,GLLIM		; IF WE GO THROUGH WITH THIS COMMAND, WILL WE
				; LAP OTHER POINTER?  (THEN NOT OK)
	BLO 2$
	INC GLBLK		; GL QUEUE IS BLOCKED, WAIT FOR QUEUE TO EMPTY A LITTLE
	UNMASK
	MOV #COMDEC,GLDPND	; AND MAKE SURE WE WIND UP IN THE RIGHT PLACE ON RETURN
	 JMP GLDXIT
2$:	UNMASK
	MOV #CHRDEC,GLDPND

	BIT #40000,TMPWRD	; MACRO BIT TEST
	 BEQ DLYTST		; NOPE, IS STANDARD OR PSEUDO COMMAND

; GOULD MACRO COMMANDS
	MOVB TMPWRD,UPWORD	; UP COMING PAGE NUMBER
	MOVB TMPWRD+1,R0
	BIC #177700,R0	
	ASR R0
	ASR R0
	ASR R0
	MOV UPWORD,(R4)+
	MOV #100000,(R4)+
	MOV MACTAB(R0),(R4)+
	ASR R0
	MOV R0,GRFFLG
	CMP R0,#3
	BNE 4$
	CLR GRFFLG
4$:	 JMP GLDFIN		; COMPLETION OF COMMAND
	
MACTAB:	.WORD SALBLK
	.WORD SLGBLK
	.WORD SHGBLK
	.WORD EOFBLK

UPWORD:	.WORD 120000


; NORMAL GOULD COMMANDS

;DETERMINE IF THIS IS A DELAYED COMMAND
DLYTST:	BIT #200,TMPWRD		; LINE ADVANCE OR HOME? (OR PSEUDO COMMAND)
	 BNE DLAYCM
	CMPB #%GCON,TMPWRD	; ENABLE?
	 BEQ DLAYCM
	TSTB TMPWRD		; FEED?
	BEQ DLAYCM

;IF WE GOT TO HERE, MUST BE AN IMMEDIATE COMMAND
	CMPB #%GCGRF,TMPWRD	; GRAPHIC SELECT?
	 BNE 1$
	INC GRFFLG
1$:	CMPB #%GCOFF,TMPWRD	; DISABLE?
	 BNE 2$
	CLR GRFFLG		; CLEAR MODE SELECTION
2$:	CLRB TMPWRD+1		; IMMEDIATE COMMAND SIGNIFIED BY 0 IN BYTE 1
	MOV TMPWRD,(R4)+
	 JMP GLDFIN		; COMPLETION OF A COMMAND

DLAYCM:	BIT #100,TMPWRD
	BEQ HERE4

; REQUEST FOR REPEAT, IN ACTUALITY
	BIT #2,TMPWRD
	BNE 1$

; START OF REPEAT
	MOV #140000,(R4)+
	MOV #REPTRN,GLDPTR	; WE NEED ANOTHER WORD HERE (THE REPEAT COUNT)
	 JMP GLDXIT

; END OF REPEAT
1$:	MOV #140001,(R4)+
	 JMP GLDFIN		; COMPLETION OF A COMMAND

REPTRN:	MOV TMPWRD,(R4)+
	MOV #DATDEC,GLDPTR
	 JMP GLDFIN		; COMPLETION OF A COMAND


HERE4:	MOVB #1,TMPWRD+1	; DELAYED COMMAND SIGNIFIED BY 1 IN BYTE 1
	MOV TMPWRD,(R4)+
	JMP GLDFIN		; COMPLETION OF A COMMAND

;  DMA BUFFER DECODING 


DMADEC:	TST GRFFLG
	BEQ ALPHAM		; MUST BE ALPHA MODE

;  GRAPHICS MODE 

GRAPHM:	BIT #200,TMPWRD		; RUN LENGTH ENCODED?
	 BEQ IMAGE
	 JMP RUNLEN		; YEP

.SBTTL  GOULD IMAGE MODE DATA HANDLING

IMAGE:	MOVB TMPWRD,DATLEN	; LENGTH OF DATA
	MOVB TMPWRD+1,R5
	MOV R5,MARLEN		; LENGTH OF MARGIN
	ADD DATLEN,R5		; TOTAL SIZE OF BUFFER (IN WORDS)
	MOV R5,MARLN1		; SAVE FOR DMA COUNT
	ASL R5			; NOW IN BYTES
	ADD R4,R5
				; LOCATION OF PROPOSED BUFFER

	MASK 6
	CMP R4,GLLIM		; ARE WE AHEAD OF PICK UP POINTER ANYWAY? (THEN OK)
	BHIS 4$
	CMP R5,GLLIM		; IF WE GO THROUGH WITH THIS BUFFER, WILL WE
				; LAP THE OTHER POINTER? (THEN NOT OK)
	BLO 4$
	INC GLBLK		; BLOCKED OUTPUT, WAIT FOR QUEUE TO EMPTY A LITTLE
	UNMASK
	MOV #IMAGE,GLDPND	; MAKE SURE WE COME BACK TO THE RIGHT PLACE
	 JMP GLDXIT		; NEED MORE SPACE

4$:	UNMASK
	MOV #CHRDEC,GLDPND	; WE HAVE ENOUGH SPACE NOW

	NEG MARLN1		; NEGATION OF TOTAL SIZE OF BUFFER
	MOV MARLN1,(R4)+	; WORD COUNT HEADER FOR DMA COMMAND
	TST MARLEN		; ZERO MARGIN?
	BEQ 2$
1$:	CLR (R4)+
3$:	DEC MARLEN
	BNE 1$
2$:	MOV #IMTRAN,GLDPTR
	 JMP GLDXIT		; NEED MORE WORDS (REST OF LINE BUFFER)


IMTRAN:	MOV TMPWRD,(R4)+
	DEC DATLEN
	 BEQ 2$
	 JMP GLDXIT		; IF MORE IMAGE DATA COMING (NEED MORE WORDS)
2$:	MOV #DATDEC,GLDPTR	; DON'T NEED ANY MORE WORDS
	 JMP GLDFIN		; COMPLETION OF COMMAND

.SBTTL  GOULD ALPHA MODE DATA HANDLING

ALPHAM:	MOVB TMPWRD,R5
	MOV R5,DATLEN
	MOV R5,DATLN1
	ASL R5
	ADD R4,R5


	MASK 6
	CMP R4,GLLIM		; ARE WE AHEAD OF PICK UP POINTER ANYWAY? (OK)
	BHIS 2$
	CMP R5,GLLIM		; IF WE GO THROUGH WITH THIS BUFFER, WILL WE
				; LAP OTHER POINTER? (NOT OK)
	BLO 2$
	INC GLBLK		; BLOCKED OUTPUT, WAIT FOR QUEUE TO EMPTY A LITTLE
	UNMASK
	MOV #ALPHAM,GLDPND	; MAKE SURE WE COME BACK HERE (NEED MORE SPACE)
	 JMP GLDXIT
2$:	UNMASK
	MOV #CHRDEC,GLDPND	; WE'VE GOT THE SPACE NOW

	NEG DATLN1
	MOV DATLN1,(R4)+
	MOV #ALPTRN,GLDPTR	; GOBBLE WORDS FOR BUFFER
	 JMP GLDXIT

ALPTRN:	MOV TMPWRD,(R4)+
	DEC DATLEN
	 BEQ 2$
	 JMP GLDXIT		; WE NEED MORE WORDS
2$:	MOV #DATDEC,GLDPTR
	 JMP GLDFIN		; COMPLETION OF COMMAND


.SBTTL  GOULD RUN LENGTH ENCODING MODE DATA HANDLING

RUNLEN: MOVB TMPWRD,ENCLEN
	BIC #STRIP,ENCLEN	; WORD COUNT OF RUN LENGTH ENCODED DATA
	MOV #RUNLN2,GLDPTR	; WE NEED ANOTHER WORD OF COMMAND
	 JMP GLDXIT

RUNLN2:	CLR COLOR
	MOVB TMPWRD,MARLEN
	 BPL 1$
	INC COLOR
	BIC #STRIP,MARLEN	; LENGTH OR MARGIN (IN WORDS)
1$:	MOVB TMPWRD+1,R5
	BIC #STRIP,R5		; LENGTH OF DECODED BUFFER, LESS MARGIN
	ADD MARLEN,R5		; TOTAL LENGTH OF BUFFER (IN WORDS)
	MOV R5,DATLEN
	ASL R5			; NOW IN BYTES
	ADD R4,R5

	MASK 6
	CMP R4,GLLIM		; ARE WE AHEAD OF PICK UP POINTER ANYWAY? (OK)
	BHIS 2$
	CMP R5,GLLIM		; IF WE GO THROUGH WITH THIS BUFFER, WILL WE
				; LAP OTHER POINTER (NOT OK)
	BLO 2$
	INC GLBLK		; BLOCKED OUTPUT, WAIT FOR QUEUE TO EMPTY A LITTLE
	UNMASK
	MOV #RUNLN2,GLDPND
	 JMP GLDXIT
2$:	UNMASK
	MOV #CHRDEC,GLDPND	; WE'VE GOT ENOUGH SPACE NOW

	MOV #RUNTRN,GLDPTR
	NEG DATLEN
	MOV DATLEN,(R4)+	; WORD COUNT, DMA COMMAND HEADER
	CLR DATLEN
	TST MARLEN
	BEQ 3$			; ZERO LENGTH MARGIN?
	TST COLOR
	BEQ 21$			; IF COLOR = 0, THEN WHITE MARGIN
22$:	MOV #177777,(R4)+
	DEC MARLEN
	BNE 22$
	BR 3$

21$:	CLR (R4)+
	DEC MARLEN
	BNE 21$

3$:	 JMP GLDXIT		; NEED MORE WORDS

RUNTRN:	MOVB TMPWRD,R5
	BPL 1$
	BIC #STRIP,R5
	 BEQ 4$
2$:	MOVB #177777,(R4)+
	DEC R5
	 BNE 2$
	 BR 4$

1$:	 BEQ 4$
3$:	CLRB (R4)+
	DEC R5
	 BNE 3$

4$:	MOVB TMPWRD+1,(R4)+
	DEC ENCLEN
	 BEQ 41$
	 JMP GLDXIT		; STILL NEED MORE WORDS

41$:	MOV #DATDEC,GLDPTR
	 JMP GLDFIN		; COMPLETED COMMAND



GLDFIN:	CMP R4,GLEND
	BLO 1$
	MOV GLBEG,R4
1$:	CMP R4,GLLIM
	BNE 2$
	INC GLBLK
2$:	MOV R4,GLPTR
	MOV R4,GTPTR
	TST GLIDL		; IS THE GOULD IDLE?
	BEQ GLOOP
	MASK 5			; FAKE AN INTERRUPT
	CALL GLDINT		; GO TO HANDLER WITH ANXIOUSLY AWAITED CRUFT
	BR GLOOP

GLDXIT:	MOV R4,GTPTR

GLOOP:	CMP R2,RI.END(R1)	; END OF INPUT QUEUE?
	 BNE 1$
	MOV RI.BEG(R1),R2	; CIRCLE AROUND TO BEGINNING
1$:	MOV R2,RI.LIM(R1)
	CMP ALNUM(R3),#ALCLIM
	BGE 5$
	CALL ALLCSB
	INC GLDALC		; NECESSARY, ELSE GOULD LOCKS OUT ITS OWN ALLOCATER
5$:	MASK 6
	CMP R2,RI.PTR(R1)
	 BEQ 3$
	UNMASK
;	TST RO.BLK(R1)
;	 BNE 6$			; UNNECESSARY UNTIL CONSOLE DEVICE EXISTS
	TST GLBLK
	 BNE 6$
	TST GLDALC
	 BNE 7$
	 JMP JMPDEC

7$:	CLR GLDALC
	 BR 8$

3$:	MOV SRTY(R3),@MRTY(R3)
	UNMASK

6$:	MOV #WAITIN,WAITPL
8$:	RET



.SBTTL  PREDEFINED  GOULD MACRO BLOCKS 

			; ALPHA MODE SELECT
SALBLK:	.WORD 4			; DISABLE
	.WORD 403		; ENABLE
	.WORD 2			; CUT
	.WORD 100001		; POPJ
SALEND:

			; LOW SPEED GRAPHICS MODE SELECT
SLGBLK:	.WORD 4			; DISABLE
	.WORD 1			; GRAPHIC COMMAND
	.WORD 5			; LAST LINE FLAG
	.WORD 403		; ENABLE
	.WORD 2			; CUT
	.WORD 100001		; POPJ
SLGEND:

			; HIGH SPEED GRAPHICS MODE SELECT
SHGBLK:	.WORD 4			; DISABLE
	.WORD 1			; GRAPHIC COMMAND
	.WORD 403		; ENABLE
	.WORD 2			; CUT
	.WORD 100001		; POPJ
SHGEND:


			; EOF OF FILE
EOFBLK:	.WORD 2			; CUT	------|
				;	      |
	.WORD 4			; DISABLE     |
	.WORD 403		; ENABLE      |
				;       <-----|
	.WORD 601		; LINE ADVANCE
	.WORD 140000		; REPEAT 12 (OCTAL) TIMES
	.WORD 12
	.WORD -102			; DMA COUNT
	.REPT 102
	.NLIST
	.WORD 36475		; DOUBLE DASH
	.LIST
.ENDR
	.WORD 140001		; END OF REPEAT
;	.WORD 100		; END OF FILE INDICATOR
;	.WORD -22			; DMA COUNT
;	.ASCII /          /
;	.BLKW 3
;PAGLST:	.ASCII /  O(TCLA )APEG SAB D/	;  (OCTAL) PAGES BAD
	.WORD 140000		; REPEAT 12 (OCTAL) TIMES
	.WORD 12
	.WORD -102			; DMA COUNT
	.REPT 102		; DOUBLE DASH
	.NLIST
	.WORD 36475
	.LIST
.ENDR
	.WORD 140001		; END OF REPEAT

	.WORD 100001		; JMP TO WHERE WE WERE BEFORE
EOFEND:
PAGLST:	.BLKW 40		; TEMPORARY


			; SMEAR PROTECTION PAGE
SMRBLK:	.WORD 4			; DISABLE
	.WORD 403		; ENABLE
	.WORD 2			; CUT
	.WORD 140000		; START REPEAT
	.WORD 25		;	25 (OCTAL) TIMES
	.WORD -1		; DMA COUNT
	.WORD 20040		; DOUBLE SPACE
	.WORD 140001		; END REPEAT
	.WORD 100001		; END JUMP
SMREND:

.SBTTL NUMBER TO STRING CONVERSION ROUTINE

CHRNUM:	PUSH <R1,R4>
	MOV #5,R4
1$:	MOV R0,R1
	BIC #177770,R1
	ADD #60,R1
	MOVB R1,-(R5)
	DEC R4
	BEQ 2$
	ASR R0
	ASR R0
	ASR R0
	BR 1$
2$:	TST R0
	BMI 3$
	MOVB #60,-(R5)
	 BR 4$
3$:	MOVB #61,-(R5)
4$:	SWAB (R5)+		; GOULD LIKES 'EM BACKWARDS
	SWAB (R5)+
	SWAB (R5)+
	POP <R4,R1>
	RET



.SBTTL ALLOCATION AND ^G M.P. MESSAGE HANDLERS
;  MAIN PROGRAM ROUTINE FOR ALLOCATION MESSAGE HANDLING 

; AL.BLK SET FOR 12 BIT CODE EXPANSION AND ^\ DOUBLING


MRALSB:	MOV TSTA(R3),R1		; CREATE POINTER TO TRANSMIT STATUS BLOCK
	TST @TO.BLK(R1)
	 BNE 11$
	TST AL.BLK(R1)		; ARE WE OUT OF ORDER?
	 BEQ 10$
11$:	ADD #4,(SP)		; THEN PRETEND NOTHING HAPPENED
	RET
10$:	MOV @ALCP(R3),R0	; POINTER ALLOCATION MESSAGE
	MOV @MCNT(R3),R5	; COUNT OF WORDS TO TRANSFER
	MOV @TO.PTR(R1),R2	; LOAD POINTER TO QUEUE
4$:	MOV (R0)+,(R2)+		; OUTPUT CHARACTER MESSAGE
	CMP R2,@TO.END(R1)	; ARE WE AT END OF QUEUE?
	 BNE 1$
	MOV @TO.BEG(R1),R2	; CIRCLE AROUND TO BEGINNING THEN
1$:	CMP R2,@TO.LIM(R1)	; POINTER OVERLAP?
	 BNE 2$
	INC @TO.BLK(R1)
	DEC R5			; HAVE WE FINISHED YET
	BEQ 3$	
	MOV R5,@MCNT(R3)		; NOPE, SAVE COUNT
	MOV R0,@ALCP(R3)	; AND ALLOCATION MESSAGE POINTER
	MOV R2,@TO.PTR(R1)	; RESTORE POINTER
	INC MT.BLK(R1)
	MOV #WAITIN,WAITPL	; PATCH WAIT SINCE WE MADE SOME HEADWAY
	RET
2$:	DEC R5
	BNE 4$
3$:	MOV SRAL(R3),@MRAL(R3)	; PATCH FLAG
	MOV #3,@MCNT(R3)	; RE-INITIALIZE COUNT
	MOV #WAITIN,WAITPL	; PATCH WAIT
	CLR MT.BLK(R1)		; UNBLOCK NORMAL TTY OUTPUT
	MASK 6
	MOV R2,@TO.PTR(R1)	; RESTORE POINTER	
	BIS #100,XDST0		; ACTIVATE INTERRUPT
	UNMASK
	RET



;  MAIN PROGRAM ROUTINE FOR CONTROL-G MESSAGE HANDLING 
; NOTE: IF IN THE FUTURE MORE THAN ONE CHARACTER MUST BE OUTPUT
;(I.E. MORE THAN JUST ^G) REMEMBER TO INCREMENT MR.BLK(R1)
; WHEN CAN'T FINSIH MESSAGE DUE TO FULL RO QUEUE


MTCGSB:	MOV RSTA(R3),R1
	TST CG.BLK(R1)
	BNE 11$
	TST RO.BLK(R1)
	 BEQ 10$
11$:	ADD #4,(SP)		; RETURN TO .+4
	RET
10$:	MOV #CG,R0
	MOV RO.PTR(R1),R2
	MOVB R0,(R2)+
	CMP R2,RO.END(R1)
	 BNE 1$
	MOV RO.BEG(R1),R2
1$:	MASK 4
	CMP R2,RO.LIM(R1)
	 BNE 2$
	INC RO.BLK(R1)
2$:	MOV R2,RO.PTR(R1)
	BIS #100,@XTST(R3)
	MOV STCG(R3),@MTCG(R3)
	MOV #WAITIN,WAITPL
	CLR MR.BLK(R1)
	UNMASK
	RET

; OTHER M.P. ROUTINES NOT DEFINED YET
MRPLSB:	RET		; PLASMA DISPLAY

MRIMSB:	RET		; IMLAC RECEIVE

MTIMSB:	RET		; IMLAC XMIT

NULLSB:	RET		; DUMMY



.SBTTL ROUTINES FOR INTIALIZING TTY CHANNELS
INTYSB:	MOV RSTA(R3),R1
	MOV RI.BEG(R1),RI.PTR(R1)
	MOV RI.BEG(R1),RI.LIM(R1)
	MOV RO.BEG(R1),RO.PTR(R1)
	MOV RO.BEG(R1),RO.LIM(R1)
	CLR RI.BLK(R1)
	CLR RO.BLK(R1)
	CLR MR.BLK(R1)
	CLR CG.BLK(R1)
	CLR RO.ESF(R1)
	CLR JMPESC(R1)
	MOV ESCHTB(R3),RO.ESC(R1)
	MOV SRTY(R3),@RI.FLG(R1)
;	MOV SRAL(R3),@AL.FLG(R1)	; GOING TO BE FLAGGED ANYWAY
	CLR ALNUM(R3)
	MOV #5,@MCNT(R3)		; MOVE WORD COUNT OF MESSAGE INTO PLACE
	CLR RS.CNT(R1)
	MOV RSTR(R3),RS.PTR(R1)
	MOV TSTA(R3),R1
	MOV TI.BEG(R1),TI.PTR(R1)
	MOV TI.BEG(R1),TI.LIM(R1)
	CLR TI.BLK(R1)
	CLR MT.BLK(R1)
	CLR AL.BLK(R1)
	MOV STTY(R3),@TI.FLG(R1)
	MOV STCG(R3),@CG.FLG(R1)
	CALL ALLCSB
	MOV TSTR(R3),TS.PTR(R1)
	CLR TS.CNT(R1)
	TST TTYCLR		; Screen clearing initialization?
	 BEQ 1$			; No
	MASK 4
	MOV #37,R0		; Clear the screen by sending ^_L (works only on I.T.S.)
	CALL INRPUT
	MOV #114,R0
	CALL INRPUT
	UNMASK
1$:	MOV ALZM(R3),@ALCP(R3)		; MOVE ALLOCATION POINTER INTO PLACE
	JMP @INSPTB(R3)			; JCALL TERMINAL DEPENDANT ROUTINES



INSPTB:	.WORD INGLSB
	.REPT <MAXTTY-1>
	.WORD NULLSB
	.ENDR

ALLCSB:	PUSH <R5,R1>
	MOV RSTA(R3),R1
	MOVB #ALCINC,@ALCI(R3)		;SET ALLOCATION
	ADD #ALCINC,ALNUM(R3)
	MOV ALCM(R3),@ALCP(R3)		;SET POINTER TO ALLOCATION
	MOV TSTA(R3),R5			;GET POINTER TO TRANSMIT STATUS TABLE
	INC MT.BLK(R5)			;BLOCK MAIN PROGRAM TRANSMIT CHAR PROCESSING
	CLRB @AL.FLG(R1)		;AND SET FLAG
	POP <R1,R5>
	RET

INGLSB:
	MOV GLBEG,GLPTR		; INITALIZE GOULD DATA QUEUE POINTERS
	MOV GLBEG,GTPTR
	MOV GLBEG,GLLIM
	MOV GLBEG,GTLIM
	MOV SSTABR,STATBR	; FIX BRANCH FOR STATUS ROUTINE
	MOV SGLIBR,GLIBR	; FIX BRANCH FOR M.P. FAKERY OF GOULD INTERRUPT
	MOV #STLEN,STALEN
	MOV #STMSG,STAMSG
	.IRP VAL,<GLBLK,JMPFLG,REPFLG,GLERR,PAGMNG,QOTFLG,GRFFLG,CLKCNT,GLDALC>
	CLR VAL
.ENDM
	MOV #1,GLIDL
	MOV #CMIDEC,GLIPTR
	MOV #CHRDEC,GLDPND
	MOV #MAKWD1,WRDPTR
	MOV #DATDEC,GLDPTR
	MOVB #177,STAPAG
	MOV #1,EODFLG
	MOV #%GCOFF,@#GLDCSR	; DISABLE THE PRINTER TO CLEAR ANY OLD INTERRUPTS
	MOV #%GCION,@#GLDCSR	; ENABLE GOULD INTERRUPTS
	RET	


.SBTTL AI KEYBOARD TABLES

;WHAT FOLLOWS IS THE GRAND CHARACTER CONVERSION TABLE

;AN 8 BIT QUANTITY IS USED TO INDEX INTO THE XTAB
;	0-5	KEYBOARD KEY NUMBER
;	  6	SHIFT
;	  7	TOP 

;IF THE BYTE PICKED IS NEGATIVE, YOU HAVE STRUCK A KEY THAT DOES NOT
;HAVE AN ASCII CODE.  THESE CODES ARE ASSIGNED AS FOLLOWS:

AINASC:	NONAS1	;	200	ILLEGAL
	KBRK	;	201	BREAK
	KESC	;	202	ESCAPE
	KCALL	;	203	CALL
	KCLEAR	;	204	CLEAR
	KDEL	;	205	CAP DELTA
	KCIRM	;	206	CIRCLE MINUS
	KGRAD	;	207	DEL
	KCIRP	;	210	CIRCLE PLUS
	KBACK	;	211	BACK
	KNEXT	;	212	NEXT
	KHELP	;	213	HELP
	KFORM	;	214	FORM
	KBS	;	215	BACK SPACE
	KVT	;	216	VERTICAL TAB
	KCR	;	217	CRLF AND BS
	KLINE	;	220	LF OR DNAR
	FDELT	;	221	FORWARD DELETE
	KRPT	;	222	KBD REPEAT
	KTAB	;	223	TAB
	KSPACE	;	224	SPACE

NATEND==<.-AINASC>-1	;MAXIMUM # NON-ASCII CHARACTERS

	%KYILL==200	; ILLEGAL
	%KYBRK==201	; BREAK
	%KYESC==202	; ESCAPE
	%KYCAL==203	; CALL
	%KYCLR==204	; CLEAR
	%KYDEL==205	; CAP  DELTA
	%KYCM==206	; CIRCLE  MINUS
	%KYGRD==207	; DEL
	%KYCP==210	; CIRCLE  PLUS
	%KYBCK==211	; BACK
	%KYNXT==212	; NEXT
	%KYHLP==213	; HELP
	%KYFRM==214	; FORM
	%KYBS==215	; BACK  SPACE
	%KYVT==216	; VERTICAL  TAB
	%KYCR==217	; CRLF AND  BS
	%KYLN==220	; LF OR  DNAR
	%KYRB==221	; FORWARD  DELETE
	%KYRPT==222	; KBD  REPEAT
	%KYTAB==223	; TAB
	%KYSPC==224	; SPACE


; SHIFT+TOP CURRENT IDENTICAL TO TOP
.MACRO KBDKEY KEY,CHAR,SHIFTC,TOPC,SHTOPC
	.BYTE CHAR,SHIFTC,TOPC,SHTOPC
.ENDM


AIKTAB:
KBDKEY	0,	201,	201,	201,	201	;BREAK
KBDKEY	1,	202,	202,	202,	202	;ESCAPE
KBDKEY	2,	'1,	'!,	222,	222
KBDKEY	3,	'2,	'",	222,	222
KBDKEY	4,	'3,	'#,	222,	222
KBDKEY	5,	'4,	'$,	222,	222
KBDKEY	6,	'5,	'%,	222,	222
KBDKEY	7,	'6,	'&,	222,	222
KBDKEY	10,	'7,	'',	222,	222
KBDKEY	11,	'8,	'(,	222,	222
KBDKEY	12,	'9,	'),	222,	222
KBDKEY	13,	'0,	'_,	222,	222
KBDKEY	14,	'-,	'=,	'=,	'=
KBDKEY	15,	'@,	'`,	'`,	'`
KBDKEY	16,	'^,	'~,	'~,	'~
KBDKEY	17,	10,	215,	215,	215	;BACK SPACE
KBDKEY	20,	32,	203,	203,	203	;CALL
KBDKEY	21,	204,	204,	204,	204	;CLEAR
KBDKEY	22,	11,	223,	223,	223	;TAB
KBDKEY	23,	33,	33,	33,	33	;ALT-MODE
KBDKEY	24,	'q,	'Q,	4,	4,	;and
KBDKEY	25,	'w,	'W,	37,	37	;or
KBDKEY	26,	'e,	'E,	22,	22	;intersection
KBDKEY	27,	'r,	'R,	23,	23	;union
KBDKEY	30,	't,	'T,	20,	20	;subset
KBDKEY	31,	'y,	'Y,	21,	21	;superset
KBDKEY	32,	'u,	'U,	5,	5	;not
KBDKEY	33,	'i,	'I,	26,	26	;xor
KBDKEY	34,	'o,	'O,	1,	1	;down arrow
KBDKEY	35,	'p,	'P,	13,	13	;up arrow
KBDKEY	36,	'[,	'{,	'{,	'{
KBDKEY	37,	'],	'},	'},	'}
KBDKEY	40,	'\,	'|,	'|,	'|
KBDKEY	41,	'/,	16,	16,	16	;infinity
KBDKEY	42,	206,	206,	205,	205	;circle minus, cap delta
KBDKEY	43,	210,	210,	207,	207	;circle plus, cap del
KBDKEY	44,	14,	214,	214,	214	;form
KBDKEY	45,	13,	216,	216,	216	;vertical tab
KBDKEY	46,	177,	177,	221,	221	;rubout
KBDKEY	47,	'a,	'A,	34,	34	;.leq.
KBDKEY	50,	's,	'S,	35,	35	;.geq
KBDKEY	51,	'd,	'D,	36,	36	;equivalence
KBDKEY	52,	'f,	'F,	17,	17	;delta (partial derivative)
KBDKEY	53,	'g,	'G,	32,	32	;not equals
KBDKEY	54,	'h,	'H,	213,	213	;HELP!!!!!
KBDKEY	55,	'j,	'J,	30,	30	;back arrow
KBDKEY	56,	'k,	'K,	31,	31	;forward arrow
KBDKEY	57,	'l,	'L,	27,	27	;both ways arrow
KBDKEY	60,	73,	'+,	'+,	'+	; ";"
KBDKEY	61,	':,	'*,	'*,	'*
KBDKEY	62,	15,	217,	217,	217	;carriage return
KBDKEY	63,	12,	220,	220,	220	;line feed
KBDKEY	64,	37,	212,	211,	211	;next, back
KBDKEY	65,	'z,	'Z,	2,	2	;alpha
KBDKEY	66,	'x,	'X,	3,	3	;beta
KBDKEY	67,	'c,	'C,	6,	6	;epsilon
KBDKEY	70,	'v,	'V,	10,	10	;lambda
KBDKEY	71,	'b,	'B,	7,	7	;pi
KBDKEY	72,	'n,	'N,	24,	24	;for all
KBDKEY	73,	'm,	'M,	25,	25	;there exists
KBDKEY	74,	54,	74,	74,	74	; <
KBDKEY	75,	'.,	76,	76,	76	; >
KBDKEY	76,	'/,	'?,	'?,	'?	; ?
KBDKEY	77,	40,	224,	222,	222	;space


.SBTTL TTY TABLES AND BUFFERS FOR TTYS

;  ADDRESS AND VALUE TABLES FOR MAIN PROGRAM SUBROUTINE CALLS 

.IRP NAM,<MCNT,ALCM,ALCP,RSTA,TSTA,RIBF,ROBF,TIBF,RSTR,TSTR>
VALCRE NAM,MXTTTY
.ENDM

.IRP NAM,<MCNT,ALCM,ALCP,RSTA,TSTA,RSTR,TSTR> ;MACRO TABLES
	ADRCRE NAM,MAXTTY
.ENDM
.IRP NAM,<MRTY,MRAL,MTTY,MTCG,ALCI,ALZM>  ;PREDEFINED TABLES
	ADRCRE NAM,MAXTTY
.ENDM

.IRP NAM,<RTST,RTBF>
	ADRCRE NAM,MXRTTY
.ENDM

.IRP NAM,<XTST,XTBF>
	ADRCRE NAM,MXXTTY
.ENDM

ALNUM:	.BLKW MXTTTY		; TABLE OF CURRENT ALLOCATIONS


;  TRANSMIT OUTPUT DEVICE STATUS TABLE (MANY TO ONE NECESSITATES INDIRECTION
; 	TO THIS TABLE)

	TOBFMC <0>

TDST0:	.WORD TOBF0
	.WORD TOBF0+TOBFLN
	.WORD TOBF0
	.WORD TOBF0
	.WORD 0

; TTY TCTYP TABLE
TCTYP:	%TCGLD			;TTY 23
	%TCTEK			;TTY 24
	%TCTEK			;TTY 25
	%TCIML			;TTY 26
	%TCAAD			;TTY 27
	%TCAAD			;TTY 30
	.REPT 4
	%TCGTV
	.ENDR
	%TCAAD		; ??

; TTY ESCAPE CHAR TABLE
ESCHTB:	-1		;TTY 23
	-1		;TTY 24
	-1		;TTY 25
	-1		;TTY 26
	33		;TTY 27
	33		;TTY 30
	-1
	-1
	-1
	-1
	-1

; VT52 TO ANN ARBOR DISPLAY CONTROLLER ESCAPE CODE TRANSLATIONS

VT52TB:	AANOOP
	AAMVUP		; A - MOVE UP
	AAMVDN		; B - MOVE DOWN
	AAMVRT		; C - MOVE RIGHT
	AAMVLF		; D - MOVE LEFT
	AANOOP
	AANOOP
	AANOOP
	AAHOME		; H - HOME UP
	AANOOP
	AAEOS		; J - ERASE TO END OF SCREEN
	AAEOL		; K - ERASE TO END OF LINE
	.REPT 15
	AANOOP
.ENDR
	AAPOS		; Y - ABSOLUTE CURSOR POSITIONING
	AANOOP

; ANN ARBOR CONTROLER CONTROL CHAR DISPATCH TABLE
AACTLT:	.REPT 7
	AACTRL
	.ENDR
	AABELL
	AABS
	AATAB
	AALF
	AAVT
	AAFF
	AACR
	.REPT 22
	AACTRL
	.ENDR


SKEYTB:	NONAS1
	KBRK
	KESC
	KCALL
	KCLEAR
	KDEL
	KCIRM
	KGRAD
	KCIRP
	KBACK
	KNEXT
	KHELP
	KFORM
	KBS
	KVT
	KCR
	KLINE
	FDELT
	KRPT
	KTAB
	KSPACE
	.REPT 13
	KNOOP
	.ENDR

.SBTTL  GOULD VARIABLES AND BUFFERS AND TABLES 
MARLEN:	.WORD 0
DATLEN:	.WORD 0
DATLN1:	.WORD 0
ENCLEN:	.WORD 0
MARLN1:	.WORD 0
TMPWRD:	.WORD 0
VALWRD:	.WORD 0
GLDPND:	.WORD CHRDEC
WRDPTR:	.WORD MAKWD1
GLDPTR:	.WORD DATDEC
EODFLG:	.WORD 0
QOTFLG:	.WORD 0
GRFFLG:	.WORD 0
COLOR:	.WORD 0
GLPTR:	.WORD GLDBUF
GTPTR:	.WORD GLDBUF
GLEND:	.WORD <CORLIM-<LBUFL+22>>
GLBEG:	.WORD GLDBUF
GLLIM:	.WORD GLDBUF
GTLIM:	.WORD GLDBUF
GLBLK:	.WORD 0

GLIPTR:	.WORD CMIDEC
JMPFLG:	.WORD 0
REPFLG:	.WORD 0
PNDR0:	.WORD 0
JMPRET:	.WORD 0
REPRET:	.WORD 0
REPCNT:	.WORD 0
GLIDL:	.WORD 0
GLERR:	.WORD 0
PAGMNG:	.WORD 0
SMRFLG:	.WORD 0
STMSG:	.WORD 177
STAPAG:	.WORD 177
STAERR:	.WORD 0
	.WORD 0
	.WORD 0
STLEN==<.-STMSG>/2

STAMSG:	.WORD STMSG
STALEN:	.WORD STLEN
GLDALC:	.WORD 0

;  START OF GOULD BUFFER 
GLDBUF:
.END INIT1
