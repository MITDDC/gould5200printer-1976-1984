
(COMMENT SPOOLER DOCUMENTATION)
; GRAPHICS SPOOLER FOR A MATRIX PRINTER (GOULD 5200)
; 
; SPOOL MESSAGES CONSIST OF FILE SPECIFICATIONS AND OPTION FLAGS.
; FILE SPECS ARE IN THE FORM:
;     <OUTPUT FILESPEC>_<FILESPEC1><FLAGS>,<FILESPEC2><FLAGS>, ...
; WHERE <FILESPEC> IS A STANDARD I.T.S. FILE SPEC (I.E. A SEQUENCE OF
; UP TO 4 WORDS WITH THE DEVICE AND DIRECTORY DISTINGUISHED BY : AND ;
; PREFIXES).  FLAGS ARE LOCAL TO THE PRECEEDING FILESPEC.  THE OPTIONAL
; FORM  _(<GLOBAL FLAGS>)<FILESPEC1>,... IS ALSO BE ALLOWED.
; <FLAGS> ARE SINGLE LETTERS, POSSIBLY FOLLOWED BY ARGUMENTS.  THE 2
; FORMS FOR FLAGS ARE (AS IN THE @ PROGRAM) (<FLAG><FLAG>...) OR
; /<FLAG>/<FLAG> ...  THE CHARS "/","(",")",",","^Q"  CAN BE QUOTED WITH ^Q.
; SUGGESTED FLAGS:
; CONTROL FLAGS:
; P	- PRIORITY, PRECEDED BY A SINGLE DIGIT (0-9)
; B	- BLACK BACKGROUND
; R	- ROTATE THE PAGE.
; V	- VERIFY.  INFORM THE USER WHEN HIS FILE HAS BEEN PRINTED (QUEUED?)
; D	- DELETE THE FILE ONCE IT HAS BEEN PRINTED.
; U	- UNSPOOL THE FILE (I.E. REMOVE IT FROM THE QUEUE).
; !	- WRAPAROUND ON OVER RUN LINES (DEFAULT IS TRUNCATE UNLESS IN ;LIST MODE)
; *	- RESET THE WORLD
; ?	- SEND A STATUS REPORT
; C	- COPIES.  PRECEEDED BY AN NUMERIC ARGUMENT.
; W	- PAGE WIDTH
; ~	- DON'T CUT PAPER. (DEFAULT IS TO CUT AT PAGE BOUNDARIES)
; @	- INDIRECT.  (I.E. TREAT FILE AS A COMMAND FILE)
; G	- OUTPUT A FILE IN GOULD FORMAT (THE DEFAULT WHEN NO OUTPUT SPECIFIED).
; O	- OUTPUT A FILE IN XGP SCAN FORMAT (THE DEFAULT WHEN OUTPUT SPECIFIED).
; &	- FORCE IMAGE MODE ENCODEING.
; $	- APPEND A GRAPHIC TAIL SHEET.
; FILE TYPE FLAGS (MUTUALLY EXCLUSIVE - DEFAULTS TO L):
; A	- ARDS.  FILE HAS CHARS PLUS ARDS GRAPHICS.
; X	- XGP.	FILE HAS XGP COMMANDS.
; L	- LIST THE FILE LIKE THE ;LIST COMMAND OF THE XGP SPOOLER
; H	- LIST THE FILE USING THE HARDWARE CHAR GENERATOR.
; T	- TEKTRONIX.  FILE HAS TEKTRONIX GRAPHICS COMMANDS (FROM A NETOUT FILE, ETC.)
; Y	- TTY GRAPHICS (SOFTWARE TTY CONVENTIONS, YET TO BE ESTABLISHED).
; I	- FILE IS BIT IMAGE.
; Z	- FILE IS XGP IMAGE MODE CRUFT.
; A DIGIT PRECEEDING ANY OF THE FILE TYPE FLAGS IS A PAGE NUMBER AT WHICH
; TO START PRINTING. + AND - ARE USED AS PREFIXES TO TURN FLAGS ON OR OFF (E.G. -!)


(COMMENT DECLARATIONS - MACROS - INITIALIZATION - MAIN LOOP)

(DECLARE (SPECIAL TO-BE-PROCESSED ROLL-PAPER Q-FILE
		  ASCII ARDS XGP TEK SOFTWARE-LPT IMAGE XGP-IMAGE GTS-LIST)
	 (FIXNUM I N CH)
	 (NEWIO T)
	 (*EXPR DIRECTORY TRUENAME CLOSE DELETEF OPEN PROBEF SET-UNAME))

(DECLARE (EVAL (READ)))
(FASLOAD LSPMAC FASL FASL JLK)

(DECLARE (EVAL (READ)))
(SETSYNTAX '/# 'MACRO '(LAMBDA () (+ 1_17 (READ)))) ; PRINTER COMMANDS

(SSTATUS FEATURE GRAPHICS-SPOOLER)

(ARRAY TV FIXNUM 1 63.)

(SETQ TO-BE-PROCESSED NIL ROLL-PAPER T ITEM NIL
      IN-FILE NIL MAIL-FILE NIL SPOOL-FILE NIL Q-FILE NIL
      DEF-GLOBAL-FLAGS '((??) (ARDS-COMMANDS) (ASCII-COMMANDS) (BACKGROUND . 0)
			 (COPIES . 1) (CUT-PAPER . T) (DELETE)
			 (FILE-TYPE . XGP) (IMAGE-COMMANDS)
			 (INDIRECT) (OUTPUT) (PAPER-HEIGHT . 850.)
			 (PAPER-WIDTH . 1100.) (PRIORITY . 0) (RUN-ENCODE . T)
			 (ROTATE . 0) (SKIP . 0) (SOFTWARE-TTY-COMMANDS)
			 (STATUS) (TAIL-SHEET) (TEK-COMMANDS) (TRUNCATE-LINES . T)
			 (VERIFY) (XGP-COMMANDS . '((LIST)))
			 (XGP-IMAGE-COMMANDS) (XGP-OUTPUT))
      GTS-LIST '(((AR1 JLK) GIRL PIC)
		 ((AR1 JLK) WUMPUS PIC)
		 ((AR1 JLK) DRAGON PIC)
		 ((AR1 JLK) WHEEL PIC)))

(NCONC GTS-LIST GTS-LIST)

; SPOOLER FUNCTIONS
(SETQ ASCII 'ASCII-PRINT
      ARDS  'ARDS-PRINT
      XGP   'XGP-PRINT
      TEK   'TEK-PRINT
      IMAGE 'IMAGE-PRINT
      XGP-IMAGE 'XGP-IMAGE-PRINT
      SOFTWARE-TTY 'TTY-PRINT)

; SPECIAL PRINTER CODES
(DECLARE (EVAL (READ)))
(SETQ TDACK 301 TDQIT 214 TDQOT 215 ESCHR 205 TDCLR 216 TDNOP 210 EOF 206 HOME #200
      LINE+ #201 INIT #4 ENABLE #3 FINISH #400 FORM-FEED #0 CUT-PAPER #2 GMODE #1
      LAST-LINE #5 ENABLE-INTS #6 DISABLE-INTS #7
      MAX-SLEEP-PERIODS 120. SPOOL-SLEEP-TIME 5. MAIL-TIME 5.)

; AUTOLOAD PROPERTIES FOR EXTERNAL FILES
(MAPC '(LAMBDA (X)
	(COND ((NOT (GETL (CAR X) '(SUBR EXPR)))
	       (PUTPROP (CAR X) (CDR X) 'AUTOLOAD))))

      '((ARDS-PRINT . ((DSK CFK) ARDS FASL))
	(TEK-PRINT  . ((DSK CFK) TEK FASL))
	(XGP-PRINT  . ((DSK CFK) XGP FASL))))

; USE THIS FUNCTION TO DUMP OUT A NEW GLPT;TS SPOOLR

(DEFUN INIT-DUMP NIL
       (SETQ ^W T)
       (SETQ MSGFILES NIL)
; SHOULD DO PURIFY$G WHEN NEWIO BUGS FIXED ??
       (SUSPEND '|:PDUMP DSK:GLPT;TS SPOOLR/î|)
       (COND ((EQ 'GSPOOL (STATUS JNAME))
	      (COND ((NULL (STATUS JCL))
		     (VALRET '|: MUST USE JCL WITH GSPOOLî:KILLî|)))
	      (SETQ MAIL-FILE (OPEN '|GLPT;.GSPL. OUTPUT| '(DSK ASCII OUT))
		    SENDER (STATUS XUNAME))
	      (PRINC (MAKNAM (STATUS JCL)) MAIL-FILE)
	      (CLOSE MAIL-FILE)
	      (OPEN MAIL-FILE '(DSK BLOCK IN))
	      (PROCESS-SPECS)
	      (CLOSE MAIL-FILE)
	      (DELETEF MAIL-FILE)
	      (PROCESS-FILE)
	      (VALRET '|:KILLî|)))
       (SSTATUS TOPLEVEL '(SPOOLER))
       (COND ((NOT (SET-UNAME)) (VALRET '|17|) (SET-UNAME))))

; THE TOPLEVEL SPOOLER.  ALTERNATE CHECKING FOR MAIL WITH SPOOLING FILES.
; IF NOTHING HAS HAPPENED IN MAX-SLEEP-PERIODS OF SLEEPING, THEN DIE OF BOREDOM.

(DEFUN SPOOLER NIL
       (COND ((PROBEF '|DSK:GLPT;[QUEUE FILE|)
	      (SETQ Q-FILE (OPEN '|DSK:GLPT;[QUEUE FILE| '(DSK IN BLOCK ASCII))
		    TO-BE-PROCESSED (READ Q-FILE))
	      (CLOSE Q-FILE)))
       (DO ((IBASE 10.) (BASE 10.) (*NOPOINT T)) (NIL)
	   (ALARMCLOCK 'TIME 1)
	   (CATCH
	    (DO ((I 0 (1+ I)))
		((> I %MAX-SLEEP-PERIODS) (SYSCALL 0 'LOGOUT 0) (VALRET '|:KILL |))
		(COND (TO-BE-PROCESSED (PROCESS-FILE) (SETQ I 0))
		      (T (SLEEP %SPOOL-SLEEP-TIME))))
	    TOP)))

(COMMENT SPOOLER MAIL PROCESSOR)

; PROCESS A MAIL FILE.  THIS MAY ALSO BE INVOKED BY THE CLI INTERRUPT HANDLER.
; QUEUE UP FILES TO BE PROCESSED BY THE SPOOLER.

; PROBEF THE FILE TO SEE IF IT EXISTS
; THE STRUCTURE OF QUEUED ITEMS IS (<FILE-NAME-LIST> <FILE-TYPE> <PRIORITY> 
; <FLAG ASSOCIATION LIST>).

(DECLARE (SPECIAL GLOBAL-FLAGS DEF-GLOBAL-FLAGS MAIL-FILE SENDER AT UNSPOOL))

(DEFUN PROCESS-MAIL () 
       (SETQ MAIL-FILE (OPEN '|DSK:GLPT;GLMAIL <| '(IN DSK ASCII)))
       (DO ((CH (TYI MAIL-FILE) (TYI MAIL-FILE)) (L NIL (CONS CH L)))
	   ((= 100 CH)
	    (SETQ SENDER (IMPLODE (NREVERSE L))
		  AT (IMPLODE (LIST (TYI MAIL-FILE) (TYI MAIL-FILE))))))
       (DO CH (TYI MAIL-FILE) (TYI MAIL-FILE) (= 15 CH))
       (DO CH (TYI MAIL-FILE) (TYI MAIL-FILE) (= CH 137))
       (PROCESS-SPECS)
       (CLOSE MAIL-FILE)
       (ERRSET (DELETEF MAIL-FILE) NIL)
       (CAR TO-BE-PROCESSED))

(DEFUN PROCESS-SPECS ()
       ; READ FILE SPECS AND FLAGS.  FORMAT IS:
       ; ((<INPUT FILESPEC> <OUTPUT SPEC> <FLAG A-LIST> ...) (...) ...)
       ; A SPECIAL VARIABLE, GLOBAL-FLAGS, IS SET TO A LIST OF ANY GLOBAL FLAGS.

       (SETQ GLOBAL-FLAGS NIL)
       (DO ((SPECSLIST (READ-FILE-SPECS MAIL-FILE) (CDR SPECSLIST))
	    (G-FLAGS (MERGE-FLAGS (DECODE-FLAGS GLOBAL-FLAGS) DEF-GLOBAL-FLAGS))
	    (DEF-DEVDIR (LIST 'DSK SENDER)) (DEF-FN1 '|.GLPT.|) (FILE) (FLAGS)
	    (OUTPUT) (UNSPOOL))
	   ((NULL SPECSLIST))
	   (SETQ FILE (MERGEF (CAAR SPECSLIST) (LIST DEF-DEVDIR DEF-FN1 '>))
		 DEF-DEVDIR (CAR FILE) DEF-FN1 (CADR FILE)
		 FLAGS (MERGE-FLAGS (DECODE-FLAGS (CDDAR SPECSLIST)) G-FLAGS))
	   (COND ((SETQ OUTPUT (CADAR SPECSLIST))
		  (SETQ OUTPUT (MERGEF OUTPUT (LIST DEF-DEVDIR 'XGPSCN '>)))))
	   (COND (UNSPOOL (UNQUEUE-FILE FILE))
		 (T (QUEUE-FILE FILE OUTPUT FLAGS)))))


(DECLARE (SPECIAL XGP-COMMANDS ARDS-COMMANDS IMAGE-COMMANDS XGP-IMAGE-COMMANDS
		  TEK-COMMANDS ASCII-COMMANDS))

(DEFUN DECODE-FLAGS (FLAG-LIST)
       (DO ((L FLAG-LIST (CDDR L)) (FL) (ITEM) (ARGS) (FLAG))
	   ((NULL L) FL)
	   (SETQ FLAG (CAR L) ARGS (CADR L)
		 ITEM
		 (COND ((NUMBERP FLAG) (CONS 'SKIP FLAG))
		       ((EQ 'P FLAG) (CONS 'PRIORITY (COND (ARGS (CAR ARGS))(T 0))))
		       ((EQ 'R FLAG) (CONS 'ROTATE (COND (ARGS (CAR ARGS))(T))))
		       ((EQ 'V FLAG) (CONS 'VERIFY (COND (ARGS (CAR ARGS))(T))))
		       ((EQ 'B FLAG) (CONS 'BACKGROUND (COND (ARGS (CAR ARGS))(T 1))))
		       ((EQ 'D FLAG) (CONS 'DELETE (COND (ARGS (CAR ARGS))(T))))
		       ((EQ 'G FLAG) (CONS 'XGP-OUTPUT 'NO))
		       ((EQ 'O FLAG) (CONS 'XGP-OUTPUT T))
		       ((EQ 'L FLAG)
			(SETQ FL (CONS '(FILE-TYPE . XGP) FL))
			(CONS 'XGP-COMMANDS (CONS '(LIST) ARGS)))
		       ((EQ 'U FLAG) (SETQ UNSPOOL T) NIL)
		       ((EQ '/~ FLAG) '(CUT-PAPER))
		       ((EQ '* FLAG)
			(COND ((MEMQ SENDER '(JLK CFK KH)) (SPOOL-RESET))))
		       ((EQ 'C FLAG) (CONS 'COPIES (COND (ARGS (CAR ARGS))(T 1))))
		       ((EQ '/$ FLAG) (CONS 'TAIL-SHEET T))
		       ((EQ '& FLAG) (CONS 'RUN-ENCODE NIL))
		       ((EQ '/! FLAG) (CONS 'TRUNCATE-LINES
					    (COND (ARGS (CAR ARGS))(T NIL))))
		       ((EQ '/@ FLAG) (CONS 'INDIRECT T))
		       ((EQ 'X FLAG)
			(SETQ FL (CONS '(FILE-TYPE . XGP) FL))
			(CONS 'XGP-COMMANDS ARGS)) 
		       ((EQ 'A FLAG)
			(SETQ FL (CONS '(FILE-TYPE . ARDS) FL))
			(CONS 'ARDS-COMMANDS ARGS)) 
		       ((EQ 'T FLAG)
			(SETQ FL (CONS '(FILE-TYPE . TEK) FL))
			(CONS 'TEK-COMMANDS ARGS))
		       ((EQ 'Y FLAG)
			(SETQ FL (CONS '(FILE-TYPE . SOFTWARE-TTY) FL))
			(CONS 'SOFTWARE-TTY-COMMANDS ARGS)) 
		       ((EQ 'H FLAG)
			(SETQ FL (CONS '(FILE-TYPE . ASCII) FL))
			(CONS 'ASCII-COMMANDS ARGS))
		       ((EQ 'I FLAG)
			(SETQ FL (CONS '(FILE-TYPE . IMAGE) FL))
			(CONS 'IMAGE-COMMANDS ARGS)) 
		       ((EQ 'Z FLAG)
			(SETQ FL (CONS '(FILE-TYPE . XGP-IMAGE) FL))
			(CONS 'XGP-IMAGE-COMMANDS ARGS))
		       (T (CONS '?? FLAG))))
	   (COND (ITEM (SETQ FL (CONS ITEM FL))))))

(DEFUN MERGE-FLAGS (FL DEF-FL)
       (SETQ FL (SORT FL (FUNCTION (LAMBDA(X Y) (ALPHALESSP (CAR X) (CAR Y))))))
       (DO ((L FL (CDR L)) (DL DEF-FL (CDR DL)) (NFL))
	   ((NULL L) (APPEND (REVERSE NFL) DL))
	   (SETQ NFL
		 (APPEND
		  (COND ((EQ (CAAR L) (CAAR DL)) (NCONS (CAR L)))
			(T (DO ((DL1 DL (CDR DL1)) (NFL1))
			       ((OR (NULL DL1) (EQ (CAAR L) (CAAR DL1)))
				(SETQ DL DL1) (CONS (CAR L) NFL1))
			       (SETQ NFL1 (CONS (CAR DL1) NFL1)))))
		  NFL))))

(COMMENT FILE SPECIFICATION READER AND PARSER)

(DECLARE (SPECIAL FILE-SPEC-TAB))

(DEFUN READ-FILE-SPECS (FILE)
       ; LEXICAL SCAN OF FILE SPECS USING LISP'S READER
       (DO ((L NIL (CONS (READ FILE 'E-O-F-R) L)) 
	    (READTABLE FILE-SPEC-TAB) (IBASE 10.))
	   ((AND L (OR (EQ 'E-O-F-R (CAR L)) (EQ (ASCII 15) (CAR L))))
	    (COND ((NULL (CDR L)) (MAIL-ERROR '|NULL FILE SPECIFICATION. |))
		  (T (PARSE-FILE-SPECS (NREVERSE (CDR L))))))))

(DEFUN PARSE-FILE-SPECS (L)
       ; CHECK FOR GLOBAL FLAGS AT THE START OF THE SPEC.
       (COND ((EQ '/( (CAR L))
	      (DO ((LL (CDR L) (CDR LL)) (F NIL (CONS (CAR LL) F)))
		  ((OR (NULL LL) (EQ '/) (CAR LL)))
		   (SETQ GLOBAL-FLAGS (PARSE-FLAGS F))
		   (SETQ L (AND LL (CDR LL)))))))
       ; BREAK UP MULTIPLE INPUT SPECS
       (DO ((L (NCONC L '(/,)) (CDR L)) (SPECS) (FLAGS) (OUTPUT) (ALL-SPECS))
	   ((NULL L) (NREVERSE ALL-SPECS))
	   (COND ((EQ '/, (CAR L))
		  (SETQ ALL-SPECS
			(CONS (CONS (PARSE-SPECS SPECS)
				    (CONS (COND (OUTPUT (PARSE-SPECS OUTPUT)))
					  (PARSE-FLAGS FLAGS)))
			      ALL-SPECS)
			OUTPUT NIL SPECS NIL FLAGS NIL))
		 ((EQ '/_ (CAR L))
		  (SETQ OUTPUT SPECS SPECS NIL)
		  (COND ((NULL OUTPUT) (SETQ OUTPUT '(*)))))
		 ((MEMQ (CAR L) '(// /())
		  (DO ((LL (CDR L) (CDR LL)))
		      ((OR (EQ '/, (CAR LL)) (NULL LL)) (SETQ L (CONS NIL LL)))
		      (COND ((MEMQ (CAR LL) '(// /( /) )))
			    (T (SETQ FLAGS (CONS (CAR LL) FLAGS))))))
		 (T (SETQ SPECS (CONS (CAR L) SPECS))))))

(DEFUN PARSE-SPECS (L)
       (COND (L ; SPECS ARE REVERSED AT THIS POINT
	      (DO ((L L (CDR L)) (DEV '*) (SNAME '*)
		   (FNLIST '(* *)))
		  ((NULL L) (LIST (LIST DEV SNAME) (CAR FNLIST) (CADR FNLIST)))
		  (COND  ((EQ '/: (CAR L))
			  (SETQ DEV (CAR (SETQ L (CDR L)))))
			 ((EQ '/; (CAR L))
			  (SETQ SNAME (CAR (SETQ L (CDR L)))))
			 (T (SETQ FNLIST (CONS (CAR L) FNLIST))))))))

; FLAG FORMATS:  <NUMBER>!<+ OR ->!<LETTER>![<CRUFT>]
; RETURNS A LIST OF PAIRS: FLAG, ARGS, ...

(DEFUN PARSE-FLAGS (FLAGS)
       (DO ((L (REVERSE FLAGS) (CDR L)) (FS) (ARGS) (FLAG) (SKIP 0))
	   ((NULL L) FS) (DECLARE (FIXNUM SKIP))
	   (COND ((NOT (= 1 (FLATC (CAR L))))
		  (SETQ L (NCONC (EXPLODEC (CAR L)) (CDR L)))))
	   (COND ((NUMBERP (CAR L)) (SETQ SKIP (CAR L)))
		 ((NUMBERP (SETQ FLAG (READLIST (LIST (CAR L))))) (SETQ SKIP FLAG))
		 ((MEMQ (CAR L) '(+ -))
		  (SETQ ARGS (CONS (CDR (ASSQ (CAR L) '((+ . T) (-)))) ARGS)))
		 (T (SETQ FLAG (CAR L))
		    (COND ((EQ '/[ (CADR L))
			   (DO ((LL (CDDR L) (CDR LL)) (AL) (AL1))
			       ((OR (NULL LL) (EQ '/] (CAR LL)))
				(SETQ L LL
				      ARGS (NCONC (NREVERSE (CONS (NREVERSE AL1) AL))
						  ARGS)))
			       (COND ((EQ '/| (CAR LL))
				      (SETQ AL (CONS (NREVERSE AL1) AL) AL1 NIL))
				     (T (SETQ AL1 (CONS (CAR LL) AL1)))))))
		    (SETQ ARGS (NREVERSE ARGS))
		    (COND ((NOT (ZEROP SKIP))
			   (SETQ ARGS (CONS (CONS 'SKIP SKIP) ARGS))))
		    (SETQ FS (CONS FLAG (CONS ARGS FS))
			  ARGS NIL SKIP 0)))))

; SETUP SYNTAX READ TABLE FOR LEXICAL SCANNING

(SETQ FILE-SPEC-TAB (GET (*ARRAY (GENSYM) 'READTABLE) 'ARRAY))

((LAMBDA(READTABLE) 
	(SETSYNTAX 15 601540 15)
	(SETSYNTAX '/; 600500 '/;)
	(SETSYNTAX '/: 600500 '/:)
	(SETSYNTAX '/, 600500 '/,)
	(SETSYNTAX '/ 402500 NIL)
	(SETSYNTAX '/. 1 '/.)
	(SETSYNTAX '/! 600500 '/!)
	(SETSYNTAX '/% 600500 '/%)
	(SETSYNTAX '/| 600500 '/|)
	(SETSYNTAX '/[ 600500 '/[)
	(SETSYNTAX '/] 600500 '/])
	(SETSYNTAX '/( 600500 '/()
	(SETSYNTAX '/) 600500 '/))
	(SETSYNTAX '/' 600500 '/')
	(SETSYNTAX '/^ 600500 '/^)
	(SETSYNTAX '/_ 600500 '/_)
	(SETSYNTAX '// 600500 '//)
	(SETSYNTAX '/ 600500 '/)
	(SETSYNTAX '/ 600500 '/)
	(SSTATUS TTYREAD NIL))
	FILE-SPEC-TAB)

(COMMENT QUEUEING - UNQUEUEING AND QUEUE PROCESSING FUNCTIONS)

(DECLARE (SPECIAL ITEM))

(DEFUN UNQUEUE-FILE (FILE-SPEC)
       (COND ((DO ((L TO-BE-PROCESSED (CDR L))) ((NULL L) T)
		  (COND ((EQUAL FILE-SPEC (CAAR L))
			 (COND ((CDR L) (RPLACA L (CADR L)) (RPLACD L (CDDR L)))
			       (T (RPLACA L NIL) (RPLACD L NIL)))
			 (RETURN NIL))))
	      (COND ((EQUAL FILE-SPEC (CAR ITEM))
		     (CLOSE MAIL-FILE)
		     (ERRSET (DELETEF MAIL-FILE) NIL)
		     (NOINTERRUPT NIL)
		     (THROW NIL TOP)))))
       (RECORD-Q))

(DEFUN QUEUE-FILE (FILE OUTPUT FLAGS)
       (COND ((NULL (PROBEF FILE)) (MAIL-ERROR '|FILE NOT FOUND.  |))
	     ((AND OUTPUT
		   (NULL (PROBEF (LIST (CAR OUTPUT) '|.FILE.| '|(DIR)|))))
	      (MAIL-ERROR '|NON EXISTENT DIRECTORY.  |))
	     (T (SETQ FILE (OPEN FILE)
		      TO-BE-PROCESSED
		      (PRIORITY-ARBITRATE
		               TO-BE-PROCESSED
			       (LIST (TRUENAME FILE)
				     OUTPUT
				     (OR (CDR (ASSQ 'FILE-TYPE FLAGS)) 'ASCII)
				     (OR (CDR (ASSQ 'PRIORITY FLAGS)) 0)
				     FLAGS)))
		(CLOSE FILE)
		(RECORD-Q))))

(DEFUN PRIORITY-ARBITRATE (LIST ITEM)
       (DO ((L LIST (CDR L)))
	   ((NULL L) (NCONC LIST (NCONS ITEM)))
	   (COND ((> (CADDDR ITEM) (CADDDR (CAR L)))
		  (RPLACD L (CONS (CAR L) (CDR L))) (RPLACA L ITEM) 
		  (RETURN LIST)))))

(DEFUN RECORD-Q NIL
       (COND (TO-BE-PROCESSED
	      (SETQ Q-FILE (OPEN '|DSK:GLPT;[QUEUE FILE| '(DSK OUT BLOCK ASCII)))
	      (PRIN1 TO-BE-PROCESSED Q-FILE) (TERPRI Q-FILE)
	      (CLOSE Q-FILE))
	     ((PROBEF '|DSK:GLPT;[QUEUE FILE|) (DELETEF '|DSK:GLPT;[QUEUE FILE|))))

(DECLARE (SPECIAL BACKGROUND COPIES CUT-PAPER DELETE FILE-TYPE INDIRECT OUTPUT
		  PAPER-HEIGHT PAPER-WIDTH PRIORITY RUN-ENCODE ROTATE SKIP STATUS
		  TRUNCATE-LINES VERIFY XGP-COMMANDS ARDS-COMMANDS ASCII-COMMANDS
		  TEK-COMMANDS SOFTWARE-TTY-COMMANDS IMAGE-COMMANDS XGP-OUTPUT
		  XGP-IMAGE-COMMANDS INIT-SIZE IN-FILE SPOOL-FILE TAIL-SHEET
		  TV-SIZE-X TV-SIZE-Y ITEM OUTPUT-FILE)
	 (*EXPR ARDS-PRINT))

(DECLARE (EVAL (READ))) (SETQ ASCII-INIT-SIZE 10000)

(DEFUN PROCESS-FILE NIL
       (LAMBIND
	((BACKGROUND 0) (COPIES 1) (CUT-PAPER T) (DELETE) (FILE-TYPE XGP)
	 (INDIRECT) (OUTPUT) (PAPER-HEIGHT 850.) (PAPER-WIDTH 1100.)
	 (PRIORITY 0) (RUN-ENCODE T) (ROTATE 0) (SKIP 0) (STATUS) (TRUNCATE-LINES T)
	 (VERIFY) (ITEM) (XGP-COMMANDS) (ASCII-COMMANDS) (ARDS-COMMANDS)
	 (TEK-COMMANDS) (IMAGE-COMMANDS) (SOFTWARE-TTY-COMMANDS) (XGP-OUTPUT)
	 (TAIL-SHEET) (TV-SIZE-X 63.) (TV-SIZE-Y 0)
	 (OUTPUT-FILE '|DSK:GLPT;[GLPT] >|))
	(NOINTERRUPT T)
	(DO ((L TO-BE-PROCESSED (CDR L)))
	    ((OR (NULL L) (CAR L))
	     (COND ((NULL L) (THROW NIL TOP)))
	     (SETQ ITEM (CAR L) TO-BE-PROCESSED (CDR L))))
	(NOINTERRUPT NIL)
	(DO ((L (CADDDR (CDR ITEM)) (CDR L))) ((NULL L)) (SET (CAAR L) (CDAR L)))
	(SETQ SPOOL-FILE (OPEN '|DSK:GLPT;.GLPT. OUTPUT| '(OUT DSK FIXNUM BLOCK)))
	(COND ((CADR ITEM) (SETQ OUTPUT-FILE (CADR ITEM))
	       (COND ((EQ 'NO XGP-OUTPUT) (SETQ XGP-OUTPUT NIL))))
	      (XGP-OUTPUT (SETQ OUTPUT-FILE (LIST (LIST 'DSK SENDER) 'XGPSCN '>))))
	(SETQ TV-SIZE-X (COND ((EQ T XGP-OUTPUT) 54.) (T 63.))
	      TV-SIZE-Y (COND ((MEMQ FILE-TYPE '(ARDS XGP TEK)) 1700.) (T 1.))
	      INIT-SIZE (COND ((EQ 'ASCII FILE-TYPE) %ASCII-INIT-SIZE)
			      (T (+ TV-SIZE-X 1))))
	(DO ((I 0 (1+ I)))
	    ((= I COPIES))
	    (INIT-OUTPUT)
	    (COND ((NOT XGP-OUTPUT)
		   (BLOCK-INIT) (CHECK-SPOOL-LOAD) (INIT-PRINTER)
		   (COND ((AND ROLL-PAPER CUT-PAPER) (DPWORD %CUT-PAPER)))))
	    (FUNCALL (EVAL (CADDR ITEM)) (CAR ITEM))
	    (COND (TAIL-SHEET (ARDS-PRINT (CAR (SETQ GTS-LIST (CDR GTS-LIST))))))
	    (COND ((NOT XGP-OUTPUT) (DPWORD %FINISH) (BLOCK-FINISH) (DPBYTE %EOF)))
	    (FINISH-OUTPUT))
	(CLEAN-UP)
	(COND (DELETE (DELETEF IN-FILE)))
	(RENAME SPOOL-FILE OUTPUT-FILE)
	(CLOSE SPOOL-FILE)
	(RECORD-Q)))

(COMMENT BLOCK INITIALIZATION AND BYTE/WORD ROUTINES)

(DECLARE (SPECIAL OUTARRAY WORD-COUNT OUT-SIZE PAGES
		  BLOCK-COUNT-PTR INIT-SIZE FILLER-CODE)
	 (FIXNUM (DPBYTE1 FIXNUM) (DPBYTE FIXNUM) TYO-COUNT OUT-SIZE
		 (IDPB FIXNUM NOTYPE) PAGES BLOCK-COUNT-PTR WORD-COUNT
		 (DPBYTE* FIXNUM) (DPWORD FIXNUM) (DPWORD1 FIXNUM)
		 INIT-SIZE OUT-SIZE BYTE WORD)
	 (ARRAY* (FIXNUM LINEARRAY 1)))

(ARRAY OUTARRAY FIXNUM 10)

(DECLARE (EVAL (READ)))
(SETQ MAX-BLOCK-SIZE 1776 BYTE-POINTER (+ 36._30. 8_24. 8._18. 1)
      NOP-WORD (+ 1 (LSH %TDNOP 4) (LSH %TDNOP 12.) (LSH %TDNOP 20.) (LSH %TDNOP 28.)))

(DEFUN INIT-PRINTER ()
       (DPWORD %INIT)
       (COND ((NOT (EQ 'ASCII FILE-TYPE)) (DPWORD %GMODE) (DPWORD %LAST-LINE)))
       (DPWORD %ENABLE))

(DEFUN INIT-OUTPUT NIL
       (*ARRAY 'OUTARRAY 'FIXNUM INIT-SIZE)
       (SETQ OUT-SIZE INIT-SIZE OUTARRAY (GET 'OUTARRAY 'ARRAY))
       (STORE (OUTARRAY 0) %BYTE-POINTER)
       T)

(DEFUN FINISH-OUTPUT NIL
       (DO NIL ((= (LSH (OUTARRAY 0) -36) 4)) (DPBYTE1 %TDNOP))
       (*REARRAY 'OUTARRAY 'FIXNUM (1+ (BOOLE 1 777777 (OUTARRAY 0))))
       (STORE (OUTARRAY 0) %NOP-WORD)
       (FILLARRAY SPOOL-FILE 'OUTARRAY)
       T)

(DEFUN CLEAN-UP NIL
       (*ARRAY 'OUTARRAY 'FIXNUM 10)
       (*ARRAY 'LINEARRAY 'FIXNUM 10)
       (GC))

(DEFUN BLOCK-INIT ()
       (DPBYTE %ESCHR) (SETQ BLOCK-COUNT-PTR (OUTARRAY 0) WORD-COUNT 0)
       (DO I 1 (1+ I) (> I 4) (DPBYTE1 %TDNOP))) ; MAKE SPACE FOR BYTE COUNT

(DEFUN BLOCK-FINISH ()
       (LAMBIND ((WORD (* 2 WORD-COUNT)) (BYTE-POINTER (OUTARRAY 0)))
		(STORE (OUTARRAY 0) BLOCK-COUNT-PTR)
		(DPBYTE (BOOLE 1 377 WORD))
		(DPBYTE (BOOLE 1 377 (LSH WORD -10)))
		(STORE (OUTARRAY 0) BYTE-POINTER))
       (FINISH-OUTPUT) (INIT-OUTPUT))

(DEFUN DPWORD (WORD)
       (DPWORD1 WORD)
       (SETQ WORD-COUNT (1+ WORD-COUNT))
       (COND ((= %MAX-BLOCK-SIZE WORD-COUNT)
	      (BLOCK-FINISH) (BLOCK-INIT)))
       WORD)

(DEFUN DPWORD1 (WORD)
       (DPBYTE* (BOOLE 1 377 WORD))
       (DPBYTE* (BOOLE 1 377 (LSH WORD -10)))
       WORD)

(DEFUN DPBYTE* (BYTE)
       (COND ((> BYTE 177)
	      (COND ((MEMBER BYTE '(%ESCHR %TDQOT %EOF %TDQIT %TDACK %TDNOP))
		    (DPBYTE %TDQOT)))))
       (COND ((> BYTE 177) (DPBYTE1 %TDQOT)))
       (DPBYTE1 BYTE))

(DEFUN DPBYTE (BYTE)
       (COND ((> BYTE 177) (DPBYTE1 %TDQOT)))
       (DPBYTE1 BYTE))

(DEFUN DPBYTE1 (BYTE)
       (COND ((= (BOOLE 1 777777 (OUTARRAY 0)) (1- OUT-SIZE))
	      (*REARRAY 'OUTARRAY 'FIXNUM (SETQ OUT-SIZE (+ OUT-SIZE 2000)))
	      (SETQ OUTARRAY (GET 'OUTARRAY 'ARRAY))))
       (IDPB BYTE OUTARRAY))

(COMMENT SPOOLER FOR ASCII FILES)

(DECLARE (EVAL (READ)))
(SETQ BOTTOM-MARGIN 3 TOP-MARGIN 5 DOLLAR 44 SPACE 40 CARET 136
      PAGE-SIZE 62. MAX-LINE-SIZE 132.)

;; IMPLEMENT SKIP FOR THIS MODE.  PAGE SIZE??

(DEFUN ASCII-PRINT (FILE)
       (SETQ FILLER-CODE %SPACE IN-FILE (OPEN FILE '(IN DSK IMAGE)))
       (ARRAY LINEARRAY FIXNUM (1+ %MAX-LINE-SIZE))
       (TOP-MARGIN)
       (DO ((CH (TYI IN-FILE) (TYI IN-FILE)) (LCNT 0)
	    (I 0 (1+ I)) (ID 1) (OVER-RUN)
	    (CC (CADDAR (DIRECTORY (LIST (TRUENAME IN-FILE)) '(CHARACTERS))))
	    (WORDC (CADDAR (DIRECTORY (LIST (TRUENAME IN-FILE)) '(WORDS)))))
	   ((= I CC) 
	    (FINISH-LINE ID) (ASCII-FF LCNT) (CLOSE IN-FILE))
	   (DECLARE (FIXNUM ID CH CC WORDC LCNT))
	   (COND ((NOT (AND (OR (= 3 CH) (= 14 CH))
			    (NOT (> WORDC (1+ (// (FILEPOS IN-FILE) 5))))))
		  (COND ((= 33 CH) (SETQ CH %DOLLAR)))
		  (COND ((OR (= 14 CH) (= 12 CH))
			 (FINISH-LINE ID)
			 (SETQ ID 1 LCNT (1+ LCNT)) OVER-RUN NIL))
		  (COND ((OR (= 14 CH) (= %PAGE-SIZE LCNT))
			 (ASCII-FF LCNT) (TOP-MARGIN) (SETQ LCNT 0))
			((OR (= 15 CH) (= 12 CH) OVER-RUN))
			((= 11 CH)
			 (DO I (- (MIN %MAX-LINE-SIZE (* 10 (1+ (// ID 10)))) ID)
			     (1- I) (= 0 I) (STORE (LINEARRAY ID) %SPACE)
			     (SETQ ID (1+ ID))))
			((< CH 40)
			 (STORE (LINEARRAY ID) %CARET)
			 (STORE (LINEARRAY (SETQ ID (1+ ID))) (+ 100 CH))
			 (SETQ ID (1+ ID)))
			(T (STORE (LINEARRAY ID) CH) (SETQ ID (1+ ID))))))
	   (COND ((OR (AND TRUNCATE-LINES (> ID %(1- %MAX-LINE-SIZE)))
		      (= ID %MAX-LINE-SIZE))
		  (COND ((NOT TRUNCATE-LINES)
			 (STORE (LINEARRAY ID) 174)
			 (SETQ ID (1+ ID))))
		  (FINISH-LINE ID) (SETQ ID 1 LCNT (1+ LCNT))
		  (SETQ OVER-RUN TRUNCATE-LINES)))))

(DEFUN FINISH-LINE (ID)
       (COND ((= 1 ID) (LINE-FEED))
	     (T (COND ((> (+ WORD-COUNT (// ID 2) 1) %MAX-BLOCK-SIZE)
		       (BLOCK-FINISH)(BLOCK-INIT)))
		(DPWORD (// ID 2))
		(DO ((I 1 (1+ (1+ I))))
		    ((NOT (< I ID)))
		    (DPWORD (+ (LSH (LINEARRAY I) 10)
			       (OR (AND (NOT (< (1+ I) ID)) FILLER-CODE)
				   (LINEARRAY (1+ I)))))))))

(DEFUN ASCII-FF (LC)
       (COND ((NOT ROLL-PAPER) (DPWORD %FORM-FEED))
	     (T (DO I LC (1+ I) (> I %(+ %BOTTOM-MARGIN %PAGE-SIZE)) (LINE-FEED))
		(COND (CUT-PAPER (DPWORD %CUT-PAPER)))))
       (CHECK-SPOOL-LOAD)
       (SETQ PAGES (1+ PAGES)))

(DEFUN LINE-FEED NIL
       (COND ((> (+ WORD-COUNT 2) %MAX-BLOCK-SIZE)
	      (BLOCK-FINISH)(BLOCK-INIT)))
       (DPWORD 1) (DPWORD (+ %SPACE (LSH %SPACE 10))))

(DEFUN TOP-MARGIN NIL
       (DO I 0 (1+ I) (= I %TOP-MARGIN) (LINE-FEED)))

(COMMENT COMPOSITION ARRAY SCAN OUT AND COMPRESSION FUNCTIONS)

(DECLARE (SPECIAL TV-SIZE-X TV-SIZE-Y)
	 (FIXNUM  TV-SIZE-X TV-SIZE-Y (ILDB* FIXNUM FIXNUM))
	 (*EXPR ILDB*))

(DECLARE (EVAL (READ))) (SETQ MAX-SCAN-SIZE 200 LFT-MAR 1)

(SETQ TV-SIZE-X 63. TV-SIZE-Y 0)

(DEFUN TV-FORMFEED ()
       (COND (XGP-OUTPUT (XGP-SCAN))
	     (T (ARRAY LINEARRAY FIXNUM (+ %MAX-SCAN-SIZE 5))
		(DO I 0 (1+ I) (= I TV-SIZE-Y) (SCAN-LINE I))
		(COND ((AND CUT-PAPER ROLL-PAPER) (DPWORD %CUT-PAPER)))
		(CHECK-SPOOL-LOAD))))

(DEFUN TEST-FORMFEED ()
       (SETQ SPOOL-FILE (OPEN '|DSK:GLPT;[GLPT] >| '(OUT DSK FIXNUM BLOCK)))
       (COND (ROLL-PAPER (SETQ INIT-SIZE 20)
	      (INIT-OUTPUT) (BLOCK-INIT) (DPWORD %INIT) (DPWORD %ENABLE)
	      (DPWORD %CUT-PAPER) (BLOCK-FINISH)))
       (ARRAY LINEARRAY FIXNUM (+ %MAX-SCAN-SIZE 5))
       (SETQ INIT-SIZE (+ TV-SIZE-X 1)) (INIT-OUTPUT)
       (BLOCK-INIT) (DPWORD %INIT) (DPWORD %GMODE) (DPWORD %LAST-LINE) (DPWORD %ENABLE)
       (DO I 0 (1+ I) (= I TV-SIZE-Y) (SCAN-LINE I))
       (COND (ROLL-PAPER (DPWORD %CUT-PAPER)))
       (DPWORD %FINISH) (BLOCK-FINISH) (DPBYTE %EOF) (FINISH-OUTPUT)
       (CLOSE SPOOL-FILE)
       NIL)

(DEFUN SCAN-LINE (LINEN)
       (DECLARE (FIXNUM LINEN))
       (PROG (START WIDTH MAX-ID WORDS IMAGE)
	     (DECLARE (FIXNUM START WIDTH MAX-ID WORDS))
	     (SETQ WIDTH TV-SIZE-X START 0)
	     (COND ((= 1 BACKGROUND) (SETQ WORDS (* 2 WIDTH)) (GO IMAGE)))
	     (DO ((I 0. (1+ I)))
		 ((OR (= I WIDTH) (NOT (= (TV LINEN I) 0.)))
		  (SETQ START I) NIL))
	     (COND ((= START WIDTH) (DPWORD %LINE+) (RETURN NIL)))
	     (SETQ START (MIN 76 START))
	     (DO ((I (1- WIDTH) (1- I)))
		 ((OR (< I START) (NOT (= (TV LINEN I) 0.)))
		  (SETQ WIDTH (1+ I)) NIL))
	     (SETQ WORDS (* 2 (- WIDTH START)))
	     (DO ((I START (1+ I)) (COUNT 0) (ID 0) (CBYTE 0) (BEGIN T)
		  (BYTE-PTR-LIST '(341001_18. 441001_18. 141001_18. 241001_18.))
		  (WORD))
		 ((= I WIDTH) 
		  (COND ((NOT (= 0 COUNT))
			 (STORE (LINEARRAY ID)
				(+ (LSH CBYTE 8) (BOOLE 1 200 CBYTE) (1- COUNT)))
			 (SETQ ID (1+ ID))))
		  (SETQ MAX-ID ID))
		 (DECLARE (FIXNUM COUNT ID CBYTE))
		 (COND ((> ID WORDS) (SETQ MAX-ID ID) (RETURN NIL)))
		 (SETQ WORD (TV LINEN I))
		 (DO ((L BYTE-PTR-LIST (CDR L)) (BYTE 0))
		     ((NULL L))
		     (SETQ BYTE (ILDB* WORD (CAR L)))
		     (COND ((AND BEGIN (OR (= 0 BYTE) (= 377 BYTE)))
			    (SETQ CBYTE BYTE BEGIN NIL)))
		     (COND ((NOT (= CBYTE BYTE))
			    (COND ((> COUNT 177)
				   (STORE (LINEARRAY ID)
					  (+ (LSH CBYTE 8) (BOOLE 1 200 CBYTE) 177))
				   (SETQ COUNT (- COUNT 200) ID (1+ ID))))
			    (STORE (LINEARRAY ID) (+ (LSH BYTE 8)
						     (BOOLE 1 200 CBYTE) COUNT))
			    (SETQ COUNT 0 ID (1+ ID) BEGIN T))
			   (T (SETQ COUNT (1+ COUNT))))))
IMAGE	     (SETQ IMAGE (OR (NOT RUN-ENCODE) (< WORDS MAX-ID) (= 1 BACKGROUND)))
	     (COND ((> (+ WORD-COUNT (COND (IMAGE WORDS) (T (MIN WORDS MAX-ID))) 2)
		       %MAX-BLOCK-SIZE)
		    (BLOCK-FINISH) (BLOCK-INIT)))
	     (COND (IMAGE
		    (DPWORD (+ (LSH (+ %LFT-MAR (* 2 START)) 8) WORDS))
		    (DO ((I START (1+ I)) (WORD 0) (MASK (* BACKGROUND 177777)))
			((= I WIDTH))
			(SETQ WORD (TV LINEN I))
			(DPWORD (BOOLE 6 MASK (LSH WORD -20.)))
			(DPWORD (BOOLE 6 MASK (LSH WORD -4)))))
		   (T
		    (DPWORD (+ 600 MAX-ID))
		    (DPWORD (+ 1_17  (LSH (+ %LFT-MAR (* 2 WIDTH)) 8) (LSH BACKGROUND 7)
			       (+ %LFT-MAR (* 2 START))))
		    (DO ((I 0 (1+ I)) (MASK (* BACKGROUND 477_7)))
			((= I MAX-ID)) (DECLARE (FIXNUM MASK))
			(DPWORD (BOOLE 6 MASK (LINEARRAY I)))))))
       T)

(COMMENT BIT IMAGE FILE PROCESSING)

(DECLARE (EVAL (READ))) (SETQ MAX-NO-FONTS 20 )

(DEFUN IMAGE-PRINT (FILE)
       (*ARRAY 'TV 'FIXNUM 2 TV-SIZE-X)
       (SETQ IN-FILE (OPEN FILE '(DSK IN FIXNUM)))
       (ARRAY LINEARRAY FIXNUM %(+ %MAX-SCAN-SIZE 5))
       (DO ((LINES  (// (CADDAR (DIRECTORY (LIST (TRUENAME IN-FILE)) '(WORDS)))
			TV-SIZE-X) (1- LINES)))
	   ((= 0 LINES) (CLOSE IN-FILE))
	   (DO I 0 (1+ I) (= I TV-SIZE-X) (STORE (TV 0 I) (IN IN-FILE)))
	   (SCAN-LINE 0))
       (COND ((AND CUT-PAPER ROLL-PAPER) (DPWORD %CUT-PAPER)))
       (CHECK-SPOOL-LOAD))

(DEFUN XGP-IMAGE-PRINT (FILE) FILE)	; USE CFK'S SCAN PLOT


(DECLARE (SPECIAL TV-SIZE-Y TV-SIZE-X)
	 (FIXNUM LINENO WIDTH BYTES COUNT XORMASK WORD COLACC I NUM DUM M WORDACC
		 OWORD SHIFT MASK1 MASK2 Y Y1 TV-SIZE-X TV-SIZE-Y BYTEPTR XGP-WIDTH
		 LAST-LINE)
	 (ARRAY* (FIXNUM WORKING-ARRAY 1.)))

(DECLARE (EVAL (READ))) (SETQ XGP-SCAN-START 0)

; CHECK FIX UP ARRAY BEFORE FILLARRAYS (0'TH ELEMENT, LENGTH, COUNT, ETC)
; CHECK BYTE-PTR.
(DEFUN XGP-SCAN () 
       (ARRAY WORKING-ARRAY FIXNUM (+ TV-SIZE-X 2.))
       (DO ((LINENO %XGP-SCAN-START (1+ LINENO)) (LAST-LINE (1- TV-SIZE-Y))
	    (WIDTH TV-SIZE-X TV-SIZE-X) (COUNT 6. 6.) (BYTES 0.) (WORD 0.)
	    (IMAGE NIL NIL) (XORMASK (LSH -1. -4.)) (MASK1 (+ 255._28. 255._12.))
	    (MASK2 (+ 255._20. 255._4.)) (WORKING-ARRAY (GET 'WORKING-ARRAY 'ARRAY))
	    (XGP-WIDTH 54.))
	   ((> LINENO LAST-LINE)
	    (OUT (LSH (+ 2._16. 1._15. (* 192. 11.)) 4.) SPOOL-FILE)
	    (OUT 0 SPOOL-FILE))
	   (STORE (WORKING-ARRAY 0) %(+ 20._30. 8._24. 8._18. 2))
	   (STORE (WORKING-ARRAY 1) 0) (STORE (WORKING-ARRAY 2) 0)
	   (SETQ BYTES (* 4. (1+ WIDTH)))
	   (DO ((I (1- WIDTH) (1- I)))
	       ((OR (< I 0.) (NOT (= (TV LINENO I) 0.))) (SETQ WIDTH (1+ I))))
	   (DO ((I 0. (1+ I)) (COLACC 0.) (COLOUR NIL))    ;NIL=WHITE T=BLACK
	       ((= I WIDTH)
		(COND ((= COUNT 6.) (SETQ COUNT 0.))
		      (T (IDPB 0 WORKING-ARRAY) (IDPB 0 WORKING-ARRAY)
			 (IDPB 0 WORKING-ARRAY) (IDPB 1 WORKING-ARRAY)
			 (SETQ COUNT (+ COUNT 4.))
			 (COND ((NOT (= (BOOLE 1. COUNT 3.) 0.))
				(IDPB 0 WORKING-ARRAY) (IDPB 0 WORKING-ARRAY)
				(SETQ COUNT (+ COUNT 2.))))
			 (SETQ COUNT (// COUNT 4.)))))
	       (SETQ WORD (LSH (TV LINENO I) -4.))
	       (COND (COLOUR (SETQ WORD (BOOLE 6. WORD XORMASK))))
	       (DO ((WORDACC 0.) (NUM 0.) (DUM 0.) (EXITP))
		   (NIL)
		   (SETQ NUM (- 32. (HAULONG WORD))
			 WORDACC (+ WORDACC NUM)
			 COLACC (+ COLACC NUM))
		   (COND ((> WORDACC 31.)
			  (SETQ COLACC (- COLACC WORDACC -32.))
			  (COND ((AND COLOUR (= (1+ I) WIDTH)) (SETQ EXITP T))
				(T (RETURN NIL)))))
		   (SETQ DUM (1- (* 2. (// (+ 254. COLACC) 255.))))
		   (COND ((NOT (< (+ COUNT DUM) BYTES)) (SETQ IMAGE T) (RETURN NIL)))
		   (SETQ DUM (// DUM 2.))
		   (DO ((M 0. (1+ M))) ((= M DUM))
		       (IDPB 255. WORKING-ARRAY) (IDPB 0 WORKING-ARRAY)
		       (SETQ COLACC (- COLACC 255.) COUNT (+ COUNT 2.)))
		   (IDPB COLACC WORKING-ARRAY) (SETQ COUNT (1+ COUNT))
		   (AND EXITP (RETURN NIL))
		   (SETQ WORD (BOOLE 6. (LSH WORD NUM) XORMASK) 
			 COLACC 0. COLOUR (NOT COLOUR)))
	       (AND IMAGE (RETURN NIL)))
	   (COND (IMAGE (STORE (WORKING-ARRAY 0) %(+ 28._30. 8._24. 8._18. 2))
			(IDPB 2. WORKING-ARRAY)
			(DO ((I 0. (1+ I)))  ((= I WIDTH))
			    (SETQ WORD (TV LINENO I))
			    (DO ((SHIFT -28. (+ SHIFT 8.))) ((> SHIFT 0.))
				(SETQ BYTES (BOOLE 1. 255. (LSH WORD SHIFT))
				      BYTES (DO ((NUM 1. (LSH NUM 1.))
						 (DUM 7. (- DUM 2.)) (WORDACC 0.))
						((< DUM -8.) WORDACC)
						(SETQ
						 WORDACC
						 (BOOLE 6. WORDACC
						  (LSH (BOOLE 1. BYTES NUM) DUM)))))
				(IDPB BYTES WORKING-ARRAY)))
			(IDPB 0 WORKING-ARRAY) (IDPB 0 WORKING-ARRAY)
			(SETQ COUNT (+ WIDTH 2.) WIDTH (+ TV-SIZE-X 2.))
			(DO ((I COUNT (1+ I))) ((= I WIDTH))
			    (STORE (WORKING-ARRAY (1+ I)) 0.))
			(SETQ COUNT XGP-WIDTH))
		 (T (SETQ WIDTH COUNT)))
	   (COND ((NOT (= COUNT 0.))
		  (STORE (WORKING-ARRAY 1.)
			 (+ (LSH COUNT 21.) (LSH (+ LINENO 32.) 4.)))
		  (DO ((I 1. (1+ I))) ((= I WIDTH))
		      (SETQ WORD (WORKING-ARRAY (1+ I)))
		      (STORE (WORKING-ARRAY (1+ I))
			     (+ (LSH (BOOLE 1. WORD MASK1) -8.)
				(LSH (BOOLE 1. WORD MASK2) 8.))))
		  (COND (IMAGE (DO ((I WIDTH (1+ I))) ((= I XGP-WIDTH))
				   (STORE (WORKING-ARRAY (1+ I)) 0.))
			       (SETQ WIDTH XGP-WIDTH)))
		  (*REARRAY 'WORKING-ARRAY 'FIXNUM WIDTH)
		  (STORE (WORKING-ARRAY 0) %NOP-WORD)
		  (FILLARRAY SPOOL-FILE 'WORKING-ARRAY))))
       (*REARRAY 'WORKING-ARRAY))

(COMMENT CORE LINK MESSAGE HANDLER AND ERROR HANDLERS)

(DECLARE (EVAL (READ)))
(SETQ MAX-SPOOL-LOAD 400000. OVER-LOAD-WAIT-TIME 5 MAX-FILE-SIZE 50000.)

(DEFUN CHECK-SPOOL-LOAD ()
       (COND ((> (FILEPOS SPOOL-FILE) %MAX-FILE-SIZE)
	      (COND ((NOT XGP-OUTPUT) (BLOCK-FINISH))
		    (T (FINISH-OUTPUT) (INIT-OUTPUT)))
	      (RENAME SPOOL-FILE OUTPUT-FILE)
	      (CLOSE SPOOL-FILE)
	      (SETQ SPOOL-FILE
		    (OPEN '|DSK:GLPT;.GLPT. OUTPUT| '(OUT DSK FIXNUM BLOCK)))
	      (COND ((NOT XGP-OUTPUT) (BLOCK-INIT) (INIT-PRINTER)))))
; FIX THIS LOOP FOR DSK OUTPUT CASES
       (DO ((I))
	   ((NULL (PROBEF '((DSK GLPT) [GLPT] >))))
	   (SETQ I (APPLY '+ (MAPCAR 'CADDR
				     (DIRECTORY '(((DSK GLPT) [GLPT] *)) '(WORDS)))))
	   (COND ((< I %MAX-SPOOL-LOAD) (RETURN T)))
	   (SLEEP %OVER-LOAD-WAIT-TIME)))

(DEFUN SPOOL-RESET ()
       (SETQ TO-BE-PROCESSED NIL) (RECORD-Q)
       (COND ((AND MAIL-FILE (STATUS FILEMODE MAIL-FILE)) (CLOSE MAIL-FILE)))
       (COND ((AND IN-FILE (STATUS FILEMODE IN-FILE)) (CLOSE IN-FILE)))
       (COND ((AND SPOOL-FILE (STATUS FILEMODE SPOOL-FILE)) (CLOSE SPOOL-FILE)))
       (COND ((PROBEF '|DSK:GLPT;GLMAIL <|) (DELETEF '|DSK:GLPT;GLMAIL <|)))
       (COND ((PROBEF '|DSK:GLPT;.GLPT. OUTPUT|) (DELETEF '|DSK:GLPT;.GLPT. OUTPUT|)))
       (COND ((PROBEF '|DSK:GLPT;[QUEUE FILE|) (DELETEF '|DSK:GLPT;[QUEUE FILE|)))
       (DO NIL ((NOT (PROBEF '|DSK:GLPT;[GLPT] >|))) (DELETEF '|DSK:GLPT;[GLPT] >|))
       (THROW NIL TOP))

(SETQ CLI-MESSAGE 'CLI-MESSAGE-HANDLER ALARMCLOCK 'ALARM-HANDLER)

(DEFUN CLI-MESSAGE-HANDLER (X)
       (SETQ X X)	; ALWAYS NIL
       (SETQ MAIL-FILE (OPEN '|CLA:| '(CLA BLOCK IN)))
       (SETQ SENDER (CADR (TRUENAME MAIL-FILE)) AT 'MC)
       (PROCESS-SPECS)
       (CLOSE MAIL-FILE))

(DEFUN ALARM-HANDLER (TYPE)
       (SETQ TYPE TYPE)
       (COND ((PROBEF '|DSK:GLPT;GLMAIL >|) (PROCESS-MAIL)))
       (ALARMCLOCK 'TIME %MAIL-TIME))

(DEFUN MAIL-ERROR (X)
       (COND ((EQUAL '|FILE NOT FOUND.  | X))
	     ((NULL ^W) (BREAK MAIL-ERROR T))))

(COMMENT LAP CODE FOR ILDB AND IDPB FUNCTIONS)

(DECLARE (EVAL (READ)) (EVAL (READ)))
(SETSYNTAX '/% 'MACRO NIL)
(SETSYNTAX '/# 'MACRO NIL)

; TAKE ADVANTAGE OF PDP-10 HARDWARE.
; ASSUMES AN ARRAY WHOSE 0'TH ELEMENT CONTAINS A BYTE POINTER
; WHICH SHOULD INDEX THRU D (AC 10) AND BEGIN AT 1.  SECOND ARG
; IS AN ARRAY POINTER
(LAP	IDPB SUBR)
(ARGS	IDPB (NIL . 2))
	(PUSH P (% 0 0 FIX1))	; NCALLABLE
	(MOVE TT 0 A)
	(MOVE D 1 B)
	(IDPB TT 0 D)		; DEPOSIT THE BYTE
	(POPJ P)

; ASSUMES AN ARRAY AS ABOVE.  RETURNS A BYTE
(ENTRY	ILDB SUBR)
(ARGS	ILDB (NIL . 1))
	(PUSH P (% 0 0 FIX1))	; NCALLABLE
	(MOVE D 1 B)
	(ILDB TT 0 D)
	(POPJ P)

(ENTRY	ILDB* SUBR)
(ARGS	ILDB* (NIL . 2))
	(PUSH P (% 0 0 FIX1))	; NCALLABLE
	(HLLZ D 0 B)
	(ILDB TT D)		; ASSUMES BYTE POINTER INDEXES THRU A
	(POPJ P)

(ENTRY	SET-UNAME SUBR)
(ARGS	SET-UNAME (NIL . 0))
	(*SUSET 0 (% 0 0 R 54))	; GET .OPTION USET
	(MOVEI A 'NIL)
	(TLNE R 10000)			; SKIP IF NOT UNDER A DDT
	(POPJ P)
WAIT	(*SUSET 0 (% 0 0 R 65))	; GET SUPERIOR'S INDEX
	(AOJN R WAIT)
	(MOVEI A 'T)
	(*SUSET 0 (% 0 0 (% (SIXBIT GLPTR)) 400004))	; CHANGE UNAME TO GLPTR
	(*SUSET 0 (% 0 0 (% %TBNVR) 400002))	; TELL IT NOT TO HANG WAITING FOR A TTY
	(POPJ P)
()
