.TITLE TERMINAL MULTIPEXER AND GOULD DRIVER


; %%%% REGISTER %%%%

R0=%0
R1=%1
R2=%2
R3=%3
R4=%4
R5=%5
SP=%6
PC=%7

; %%%% MISCELLANEOUS CONSTANT DEFINITIONS

MXTTTY==4		; MAXIMUM NUMBER OF TERMINALS THIS ASSEMBLY
MAXTTY==4		; MAXIMUM NUMBER OF CHANNELS SUPPORTED CURRENT ITS ASSEMBLY
MXRTTY==2		; NUMBER OF DEVICE REGISTER RECEIVE TTYS
MXXTTY==3		; NUMBER OF DEVICE REGISTER TRANSMIT TTYS
MXATTY==1		; NUMBER OF ANN ARBOR TERMINALS
PRIOR0==7_5		; MASK FOR BIC APPLIED TO PS
PRIOR7==7_5		; MASK FOR BIS APPLIED TO PS
CG==7			; <CNTL>-G
CBSL==34		; <CNTL>-\
NOPIN==240		; NOP INSTRUCTION
WAITIN==1		; WAIT INSTRUCTION
LBUFL==410	; MAXIMUM SIZE OF A LINE BUFFER (IN BYTES)
TMPLEN==24	; LENGTH OF TEMPORARY STRING BUFFERS
STRIP==177600	; BIT IN BUFFER WORD WHICH INDICATED STRIPED GRAPHICS
LHS==177400	; LEFT HAND SIDE OF WORD MASK
GLDTIM==30	; TIME (IN 30TH'S OF SECOND) FOR SMEAR TIMEOUT
CORLIM==137472	; LIMIT OF USABLE CORE (24K-LOADERS)

; %%%% CONSTANTS FOR INITIALIZATION OF NON-STANDARD DEVICES %%%%

DR11MI==0
KEYBDI==100
IMLACI==0


; %%%% RECEIVE BUFFER PARAMETERS %%%%
RIBFLN==300
ROBFLN==300
AABFLN==<2*ROBFLN>*MXATTY


ALCMAX==276	; MAXIMUM PERMISSABLE ALLOCATION
		; 2 CHARACTERS LESS THAN BUFFER SIZE, ONE TO ALLOW
		; FOR ^G INSERTION AND ONE FOR PATHOLOGICAL FENCEPOST
		; INTERACTIONS

ALCLIM==ALCMAX/2	; AT THIS POINT, ADD TO ALLOCATION
ALCINC==ALCMAX/2	; THIS IS HOW MUCH TO INCREMENT THE ALLOCATION BY

; GOULD COMMAND CODES
 %GCFF==0	; TOP-OF-FORM COMMAND (256 RASTERS ON ROLL PAPER)
 %GCGRF==1	; GRAPHIC MODE COMMAND
 %GCCUT==2	; CUT COMMAND (NO CUTTER ON THIS MACHINE, THOUGH)
 %GCON==3	; TURN PRINTER ON
 %GCOFF==4	; TURN PRINTER OFF
 %GCLSL==5	; LAST LINE (GRAPHIC MODE).  => 2 MORE SCAN LINES.
 %GCION==6	; INTERRUPT ON
 %GCIOF==7	; INTERRUPT OFF
 %GCHOM==200	; HOME (128 RASTER UNITS)
 %GCADV==201	; ADVANCE ONE LINE

; PSEUDO COMMAND CODES

 %GCSRP==300	; START OF REPEAT
 %GCERP==301	; END OF REPEAT


; MACRO COMMAND CODES

 SLALPH==140000	; SELECT ALPHA MODE
 SLLGRF==150000	; SELECT LOW SPEED GRAPHICS MODE
 SLHGRF==160000	; SELECT HIGH SPEED GRAPHICS MODE
 SLEOF==170000	; EOF (TAIL SHEET HACKERY)

; GOULD STATUS BITS
 %GSNRD==400	; NOT READY (INTERLOCK TRIPPED)
 %GSDON==2000	; DMA TRANSFER COMPLETE
 %GSBSY==4000	; BUSY (PAPER MOVEMENT, SYSTEM BEING RESET, ETC.)
 %GSVAC==10000	; VACUUM FAULT
 %GSPAP==20000	; PAPER LOW
 %GSTIM==40000	; HIGH SPEED GRAPHICS TIMEOUT
 %GSERR==60400	; ALL ERROR BITS EXCEPT PAPER LOW



;  SPECIAL GOULD COMMUNICATION BYTE CODES

%CCSOD=205	; ESCAPE FOR BEGINNING OF DATA
%CCEOD=206	; ESCAPE FOR END OF DATA
%CCQOT=215	; TO QUOTE 8 BIT CODES IN GRAPHICS MODE
%CCACK=301	; ARE WE BEING PAGED?


; %%%% TRANSMIT BUFFER PARAMETERS %%%%

TIBFLN==40
TOBFLN==MAXTTY*<40+6>


.PAGE
.SBTTL %%%% INTERFACE DEFINITIONS %%%%

; DEC INTERFACES

; SERIAL INTERFACES
%CRCSR==177560			; CONSOLE TTY
%CRBUF==177562
%CXCSR==177564
%CXBUF==177566
%DRCSR==175610			; DL-11E 40 KBAUD
%DRBUF==175612
%DXCSR==175614
%DXBUF==175616
%ERCSR==175620			; DL-11E 9600 BAUD
%ERBUF==175622
%EXCSR==175624
%EXBUF==175626
%FRCSR==175630			; DL-11E 9600 BAUD
%FRBUF==175632
%FXCSR==175634
%FXBUF==175636
%GRCSR==175640			; DL-11E 9600 BAUD
%GRBUF==175642
%GXCSR==175644
%GXBUF==175646

; PARALLEL INTERFACES
; INPUT
%I1ACS==167760			; DR-11L SIDE 1
%I1ABF==167762
%I1BCS==167764			; DR-11L SIDE 2
%I1BBF==167766
; OUT
%O1ACS==167770			; DR-11M SIDE 1
%O1ABF==167772
%O1BCS==167774			; DR-11M SIDE 2
%O1BBF==167776

%UNDEF==0

; HOME BREW HARDWARE

		; ANN ARBOR CONTROLLER
%AACS==%O1ACS
%AABF==%O1ABF

		; KEYBOARD MULTIPLEXOR
%KYSTA==%I1ACS		; STATUS REGISTER
%KYBUF==%I1ABF		; BUFFER REGISTER

		; DIGIVUE PLASMA DISPLAY
%PLACS==%UNDEF		; STATUS
%PLXBF==%UNDEF		; X REGISTER
%PLYBF==%UNDEF		; Y REGISTER
%PLDBF==%UNDEF		; DATA


; COMMERCIAL INTERFACES

		; GOULD ELECTROSTATIC PRINTER PLOTTER
%GLCSR=166000		; COMMAND AND STATUS REGISTER
%GLWC=166002		; NEGATIVE WORD COUNT REG
%GLCA=166004		; CURRENT ADDRESS REG


.PAGE
.SBTTL %%%% DEVICE AND TTY DEFINITIONS %%%%


RDST0==%DRCSR		; DEVICE 0 -> DL-11 CONNECTED TO PDP-10
RDBF0==%DRBUF
XDST0==%DXCSR
XDBF0==%DXBUF

RTST0==%ERCSR		; TTY 0 (T23) -> DL-11 CONNECTED TO IMLAC
RTBF0==%ERBUF
XTST0==%EXCSR
XTBF0==%EXBUF

RTST1==%CRCSR		; TTY 1 (T24) -> CONSOLE TTY, CONNECTED TO TEKTRONIX
RTBF1==%CRBUF		; (NO CHARACTER RECEPTION STATUS BITS)
XTST1==%CXCSR
XTBF1==%CXBUF

XTST2==%AACS		; TTY 2 (T25) -> ANN ARBOR DISPLAY CONTROLLER
XTBF2==%AABF

GLDCSR==%GLCSR		; TTY 3 (T26) -> GOULD LINE PRINTER (SPECIAL HARDWARE REGISTERS)
GLDWC==%GLWC
GLDCA==%GLCA

PLPSTA==%PLACS		; TTY 4  (T27) -> PLASMA PANEL DISPLAY
PLXBUF==%PLXBF
PLYBUF==%PLYBF
PLDBUF==%PLDBF

; SPECIAL DEVICES

KEYSTA==%KYSTA		; KEYBOARD MULTIPLEXOR
KEYBUF==%KYBUF

.PAGE
.SBTTL TABLE OFFSET DEFINITIONS

; %%%% RECEIVE STATUS TABLE OFFSETS %%%%
RI.PTR==0
RI.END==2
RI.BEG==4
RI.LIM==6
RI.FLG==10
RO.PTR==12
RO.END==14
RO.BEG==16
RO.LIM==20
AL.FLG==22
TTYNUM==25
RI.BLK==30
RO.BLK==32
MR.BLK==34
CG.BLK==36
R.FLGS==40
RS.PTR==42
RS.CNT==44

; %%%% ANN ARBOR STATUS TABLE OFFSETS

AA.PTR==0
AA.END==2
AA.BEG==4
AA.LIM==6
AA.BLK==10

; %%%% TRANSMIT STATUS TABLE OFFSETS %%%%

TI.PTR==0
TI.END==2
TI.BEG==4
TI.LIM==6
TI.FLG==10
TO.PTR==12
TO.END==14
TO.BEG==16
TO.LIM==20
CG.FLG==22
TTYNUM==25
TI.BLK==30
TO.BLK==32
MT.BLK==34
AL.BLK==36
T.FLGS==40
TS.PTR==42
TS.CNT==44

; %%%% TRANSMIT OUTPUT DEVICE STATUS OFFSETS %%%%

OD.PTR==0
OD.END==2
OD.BEG==4
OD.LIM==6
OD.BLK==10

.PAGE
.SBTTL ; %%%% INTERRUPT AND TRAP VECTORS %%%%

%ERRV=4
%ILIV=10
%BPTV=14
%IOTV=20
%PWRV=24
%EMTV=30
%TRPV=34
%CLRV=60
%CLXV=64
%LKV=100
%GLDV=174
%KEYV=200

%AADCV=210
%PLPV=214
%DLRV=300
%DLXV=304
%ELRV=310
%ELXV=314
%FLRV=320
%FLXV=324
%GLRV=330
%GLXV=334

%MSTR==340	; MASTER PRIORITY, NO CONDITION CODES SET

	; THESE GIVE MASTER PRIORITY WITH CONDITION CODE BITS SET TO
	; NOTIFY THE UNEXPECTED TRAP HANDLER WHICH STATE WAS RAISED
	; IDEALLY THEY SHOULD NEVER HAVE TO BE USED

%MSTR1==341
%MSTR2==342
%MSTR3==343
%MSTR4==344
%MSTR5==345
%MSTR6==346
%MSTR7==347

%CLRPR=200		; PRI 4, (DEVICE AT BR4)
%CLTPR=200		; PRI 4, (DEVICE AT BR4)
%KEYPR=200		; PRI 4, (DEVICE AT BR4)
%PLPPR=200
%AADPR=200		; PRI 4, (DEVICE AT BR4)
%ELRPR=200		; PRI 4, (DEVICE AT BR4)
%ELXPR=200		; PRI 4, (DEVICE AT BR4)
%FLRPR=200		; PRI 4, (DEVICE AT BR4)
%FLXPR=200		; PRI 4, (DEVICE AT BR4)
%GLRPR=200		; PRI 4, (DEVICE AT BR4)
%GLXPR=200		; PRI 4, (DEVICE AT BR4)
%GLDPR=240		; PRI 5, (DEVICE AT BR5)
%DLRPR=300		; PRI 6, (DEVICE AT BR6)
%DLXPR=300		; PRI 6, (DEVICE AT BR6)
%LKPR=300		; PRI 6, (DEVICE AT PSEUDO BR6)

.=%ERRV
	CPUERR			; CPU ERROR
	%MSTR1
.=%ILIV
	ILLOPR			; ILLEGAL INSTRUCTIONS
	%MSTR2
.=%BPTV
	BPTTRP			; BREAKPOINT TRAP
	%MSTR3
.=%IOTV
	IOTTRP			; IOT TRAP
	%MSTR4
.=%PWRV
	POWROF			; POWER FAIL - RESTART
	%MSTR
.=%EMTV
	EMTTRP			; EMULATOR TRAP
	%MSTR5
.=%TRPV
	UUOH			; TRAP INSTRUCTION
	%MSTR6
.=%CLRV
	INRT1			; CONSOLE RECEIVED CHARACTER
	%CLRPR
.=%CLXV
	INTT1			; CONSOLE TRANSMITTED CHARACTER
	%CLTPR
.=%LKV
	CLKHND			; LINE FREQUENCY CLOCK
	%LKPR
.=%GLDV
	GLDINT			; GOULD INTERRUPT
	%GLDPR
.=%KEYV
	KEYINT			; KEYBOARD MULTIPLEXOR
	%KEYPR
.=%AADCV
	INTT2			; ANN ARBOR DISPLAY CONTROLLER
	%AADPR
.=%PLPV
	PLPINT			; PLASMA PANEL (BUFFER EMPTY)
	%PLPPR
.=%DLRV
	INRD0			; DL-11 #1 RECEIVED CHARACTER
	%DLRPR
.=%DLXV
	INTD0			; DL-11 #1 TRANSMITTED CHARACTER
	%DLXPR
.=%ELRV
	INRT0			; DL-11 #2 RECEIVED CHARACTER
	%ELRPR
.=%ELXV
	INTT0			; DL-11 #2 TRANSMITTED CHARACTER
	%ELXPR
.=%FLRV
	INRT0			; DL-11 #3 RECEIVED CHARACTER
	%FLRPR
.=%FLXV
	INTT0			; DL-11 #3 TRANSMITTED CHARACTER
	%FLXPR
.=%GLRV
	INRT0
	%GLRPR
.=%GLXV
	INTT0
	%GLXPR

.PAGE
.SBTTL TABLE AND VARIABLE DEFINITION MACROS
; %%%% UTILITY MACROS %%%%


.MACRO PUSH X
.IRP Y,<X>
	MOV Y,-(SP)
.ENDM
.ENDM


.MACRO POP X
.IRP Y,<X>
	MOV (SP)+,Y
.ENDM
.ENDM


.MACRO MASK LEVEL
	PUSH %PS
	MOV #<LEVEL>_5,%PS
.ENDM

.MACRO UNMASK
	POP %PS
.ENDM

.MACRO CALL X
	JSR PC,X
.ENDM

.MACRO RET
	RTS PC
.ENDM

.MACRO MSG X
.NCHR ZZ,^\X\
	.WORD ZZ
	.ASCII \X\
	.EVEN
.ENDM

; %%%% BRANCH MACROS %%%%

.MACRO SRTYMC NM
PLAC=.
.=SRTY+<NM*2>
SRTY'NM:	BR .+<MRAL'NM-MRTY'NM>
.=PLAC
.ENDM

.MACRO STTYMC NM
PLAC=.
.=STTY+<NM*2>
STTY'NM:	BR .+<MTCG'NM-MTTY'NM>
.=PLAC
.ENDM

.MACRO SRALMC NM,NM1
PLAC=.
.=SRAL+<NM*2>
SRAL'NM:	BR .+<MRTY'NM1-MRAL'NM>
.=PLAC
.ENDM

.MACRO STCGMC NM,NM1
PLAC=.
.=STCG+<NM*2>
STCG'NM:	BR .+<MTTY'NM1-MTCG'NM>
.=PLAC
.ENDM

; %%%% INQUIRY LOOP MACROS %%%%

.MACRO RPROC NM,NM1,MRTYSB,MRALSB	; CREATE A RECEIVE PROCESS
MRTY'NM:	BR MRAL'NM
	MOV #NM*2,R3
	CALL MRTYSB
	JMP TESTLB
	SRTYMC NM
MRAL'NM:	BR MRTY'NM1
	MOV #NM*2,R3
	CALL MRALSB
	JMP TESTLB
	SRALMC NM,NM1
.ENDM

.MACRO RSYM NM			; INQUIRE LOOP RECEIVE TERMINATION SYMBOL
MRTY'NM:
.ENDM

.MACRO TPROC NM,NM1,MTTYSB,MTCGSB	; CREATE A TRANSMIT PROCESS
MTTY'NM:	BR MTCG'NM
	MOV #NM*2,R3
	CALL MTTYSB
	JMP TESTLB
	STTYMC NM
MTCG'NM:	BR MTTY'NM1
	MOV #NM*2,R3
	CALL MTCGSB
	JMP TESTLB
	STCGMC NM,NM1
.ENDM

.MACRO TSYM NM			; INQUIRE LOOP TRANSMIT TERMINATION SYMBOL
MTTY'NM:
.ENDM

; %%%% BUFFER MACROS %%%%

.MACRO	RIBFMC NM		; RECEIVE INPUT BUFFER MACRO
RIBF'NM:	.BLKW RIBFLN/2
.ENDM

.MACRO	ROBFMC NM		; RECEIVE OUTPUT BUFFER MACRO
ROBF'NM:	.BLKW ROBFLN/2
.ENDM

.MACRO	TIBFMC NM		; TRANSMIT INPUT BUFFER MACRO
TIBF'NM:	.BLKW TIBFLN/2
.ENDM

.MACRO	TOBFMC NM		; TRANSMIT OUTPUT BUFFER MACRO
TOBF'NM:	.BLKW TOBFLN/2
.ENDM

.MACRO RSTRMC NM
RSTR'NM:	.BLKW TMPLEN/2
.ENDM

.MACRO	TSTRMC NM
TSTR'NM:	.BLKW TMPLEN/2
.ENDM


; %%%% TABLE UTILITY MACROS %%%%

.MACRO VALCRE NAM,NUM		; VALUE TABLE CREATING MACRO
	.REPT NUM
	NAM'MC \.RPCNT,\.RPCNT+1
.ENDR
.ENDM

.MACRO ADRMAC NAME,NM		; MACRO FOR ADDRESS TABLE ENTRY
	.WORD NAME'NM
.ENDM

.MACRO ADRCRE NAM,NUM		; ADDRESS TABLE CREATING MACRO
NAM:	.REPT NUM
	ADRMAC NAM,\.RPCNT
.ENDR
.ENDM


; %%%% STATUS TABLE MACROS %%%%

.MACRO	RSTAMC NM		; RECEIVE STATUS TABLE MACRO
RSTA'NM:	.WORD RIBF'NM
	.WORD RIBF'NM+RIBFLN
	.WORD RIBF'NM
	.WORD RIBF'NM
	.WORD MRTY'NM
	.WORD ROBF'NM
	.WORD ROBF'NM+ROBFLN
	.WORD ROBF'NM
	.WORD ROBF'NM
	.WORD MRAL'NM
	.BYTE 0,200+NM,0,0
	.WORD 0
	.WORD 0
	.WORD 0
	.WORD 0
	.WORD 0
	.WORD RSTR'NM
	.WORD 0
.ENDM



.MACRO	TSTAMC NM		; TRANSMIT STATUS TABLES MACRO
TSTA'NM:	.WORD TIBF'NM
	.WORD TIBF'NM+TIBFLN
	.WORD TIBF'NM
	.WORD TIBF'NM
	.WORD MTTY'NM
	.WORD TDST0+OD.PTR	;INDIRECT POINTER
	.WORD TDST0+OD.END	;INDIRECT POINTER
	.WORD TDST0+OD.BEG	;INDIRECT POINTER
	.WORD TDST0+OD.LIM	;INDIRECT POINTER
	.WORD MTCG'NM
	.BYTE 0,200+NM,0,0
	.WORD 0
	.WORD TDST0+OD.BLK	;INDIRECT POINTER
	.WORD 0
	.WORD 0
	.WORD 0
	.WORD TSTR'NM
	.WORD 0
.ENDM

; %%%% INTERRUPT HANDLER MACROS %%%%

.MACRO INRTMC NM,INRTSB		; TTY RECEIVE INTERRUPT HANDLER
INRT'NM:	PUSH R3
	MOV #NM*2,R3
	CALL INRTSB
	POP R3
	RTI
.ENDM

.MACRO INTTMC NM,INTTSB		; TTY TRANSMIT INTERRUPT HANDLER
INTT'NM:	PUSH R3
	MOV #NM*2,R3
	CALL INTTSB
	POP R3
	RTI
.ENDM

; %%%% ALLOCATION DATA MACROS %%%%

.MACRO ALCMMC NM		; ALLOCATION MESSAGE MACRO
ALZM'NM:	.BYTE 200+NM,34	; ^\
		.BYTE 200+NM,32	; ^Z
ALCM'NM:	.BYTE 200+NM,34	; ^\
		.BYTE 200+NM,1	; ^A
		.BYTE 200+NM,0	; ALLOCATION
ALCI'NM==.-1
.ENDM


.MACRO MCNTMC NM
MCNT'NM:	.WORD 3		; MACRO FOR STORAGE OF COUNT OF MESSAGE
.ENDM

.MACRO ALCPMC NM
ALCP'NM:	.WORD ALCM'NM	; MACRO FOR STORAGE OF MESSAGE POINTER
.ENDM

.PAGE
.SBTTL $$$$$$ INITIALIZATION $$$$$

.=2000

INIT:	MOV #340,%PS
	RESET
	MOV #INIT,SP			; INITIALIZE STACK
			; INITIALIZE DEVICES
	MOV #TDST0,R1			; DEVICE 0
	MOV #SLRD0,VCRD0		; INTERNAL POINTER IN DEVICE 0
					; RECEIVE INTERRUPT HANDLER
	MOV OD.BEG(R1),OD.PTR(R1)
	MOV OD.BEG(R1),OD.LIM(R1)
	CLR OD.BLK(R1)
	BIS #100,RDST0			; ENABLE DL-11 RECEIVE INTERRUPTS
	BIC #100,XDST0			; DISABLE DL-11 TRANSMIT INTERRUPTS

	BIS #100,RTST0			; ENABLE DL-11 RECEIVE INTERRUPTS
	BIC #100,XTST0			; DISABLE DL-11 TRANSMIT INTERRUPTS

	BIS #100,RTST1			; ENABLE CONSOLE TTY RECEIVE INTERRUPTS
	BIC #100,XTST1			; DISABLE CONSOLE TTY TRANSMIT INTERRUPTS

	BIC #100,%LKS			; TURN OFF LINE CLOCK INTERRUPTS

	BIC #100,XTST2			; DISABLE ANN ARBOR CONTROLLER INTERRUPTS

	CLR KEYBUF			; KEYBOARD MULTIPLEXOR
	MOV #KEYBDI,KEYSTA

			; INTIALIZE ALL TTY CHANNELS
	MOV #<MAXTTY-1>*2,R3
1$:	CALL INTYSB			; INTYSB VECTORS TO PROPER INIALIZING ROUTINE
	SUB #2,R3
	BPL 1$

	MOV #WAITIN,WAITPL		; FIX WAIT INSTRUCTION
	CLR %PS				; ALLOW INTERRUPTS
	BR TESTLB			; SKIP OVER BRANCH PATCH TABLES

SRTY:	.BLKW MXTTTY
STTY:	.BLKW MXTTTY
SRAL:	.BLKW MXTTTY
STCG:	.BLKW MXTTTY

.PAGE
.SBTTL %%%% INQUIRY LOOP %%%%

TESTLB:
GLDTTY==3				; TTY CHANNEL NUMBER ASSOCIATED WITH GOULD
	RPROC 3,0,MRGLSB,MRALSB			; TTY 26
	RPROC 0,1,MRTYSB,MRALSB			; TTY 23
	RPROC 1,2,MRTYSB,MRALSB			; TTY 24
AATYST==2				; START OF ANN ARBOR TERMINALS
	RPROC 2,4,MRTYSB,MRALSB			; TTY 25
	RSYM \MXTTTY

	TPROC 0,1,MTTYSB,MTCGSB			; TTY 23
	TPROC 1,2,MTTYSB,MTCGSB			; TTY 24
	TPROC 2,3,MTTYSB,MTCGSB			; TTY 25
	TPROC 3,4,MTTYSB,NULLSB			; TTY 26
	TSYM \MXTTTY

STATBR:	BR GLIBR		; MAIN PROGRAM LEVEL STATUS MESSAGE DAEMON
	MOV #GLDTTY*2,R3
	MOV TSTA(R3),R4
	MOV TI.PTR(R4),R5
	MOV STAMSG,R0
12$:	TST TI.BLK(R4)
	 BEQ 1$
	MOV R0,STAMSG
	MOV R5,TI.PTR(R4)
	CLRB @TI.FLG(R4)
	 JMP TESTLB		; (SINCE CHARACTERS ARE NOT DEPOSITED WITH INTERRUPTS
				; WAITPL HACKERY IS NOT NEEDED)
1$:	MOV (R0)+,(R5)+
	CMP R5,TI.END(R4)
	 BNE 3$
	 MOV TI.BEG(R4),R5
3$:	CMP R5,TI.LIM(R4)
	 BNE 4$
	INC TI.BLK(R4)
4$:	DEC STALEN
	 BNE 12$
	MOV #STLEN,STALEN	; CLEAN UP
	MOV #STMSG,STAMSG
	MOV R5,TI.PTR(R4)
	MOV SSTABR,STATBR
	CLRB @TI.FLG(R4)
	JMP TESTLB

GLIBR:	BR GLIBR		; MAIN PROGRAM ACTIVATION OF GOULD
				; (USEFUL ALSO FROM INTERRUPT LEVELS >= 5)
	TST GLERR
	BNE WAITPL		; SKIP IF GOULD ERROR
	MASK 5
	CALL GLDINT
	MOV SGLIBR,GLIBR	; CLEAN UP AND FALL THROUGH

WAITPL:	WAIT
	JMP TESTLB

SSTABR:	BR .+<GLIBR-STATBR>
SGLIBR:	BR .+<WAITPL-GLIBR>

.PAGE
.SBTTL %%%% TTY INTERRUPT DISPATCH %%%%

	INRTMC 0,INRTSB			; IMLAC		STANDARD RECEIVE INTERRUPT
	INRTMC 1,INRTSB			; TEKTRONIX	STANDARD RECEIVE INTERRUPT
	INRTMC 3,NULLSB			; GOULD		STANDARD RECEIVE INTERRUPT
					; DIGIVUE	KEYMUX   RECEIVE INTERRUPT
					; ANN ARBOR #1  KEYMUX   RECEIVE INTERRUPT
					; ANN ARBOR #2  KEYMUX   RECEIVE INTERRUPT


	INTTMC 0,INTTSB			; IMLAC		STANDARD TRANSMIT INTERRUPT
	INTTMC 1,INTTSB			; TEKTRONIX	STANDARD TRANSMIT INTERRUPT
	INTTMC 2,INTTSB			; ANN ARBOR	STANDARD TRANSMIT INTERRUPT
	INTTMC 3,NULLSB			; GOULD		STANDARD TRANSMIT INTERRUPT


.PAGE
.SBTTL %%%% INTERRUPT HANDLERS %%%%

; %%%% FATAL INTERRUPT HANDLER %%%%

CPUERR:
ILLOPR:
BPTTRP:
IOTTRP:
EMTTRP:
UUOH:
	HALT
 
; %%% CLOCK HANDLER %%%

CLKHND:	BIC #200,%LKS
	TST EODFLG
	BEQ 3$
	TST GLIDL
	BNE 31$
	CLR CLKCNT		; GOULD NOT SETTLED YET
	RTI

3$:	BIC #100,%LKS		; SHOW'S OVER, GO HOME
	CLR CLKCNT
	RTI

31$:	INC CLKCNT		; COUNTDOWN TO INDICATE LOSS OF ENABLE STATUS ON GOULD
	CMP #GLDTIM,CLKCNT	; SHORT TIMEOUT (1/2 SECOND) FOR PAPER SMEAR
	BEQ 2$
	RTI

2$:	PUSH R4
	MOV GLPTR,R4
	MOV #100000,(R4)+
	MOV SMEARP,(R4)+
	MOV R4,GLPTR
	MOV R4,GTPTR
	CLRB GLIBR
	POP R4
	CLR CLKCNT
	BIC #100,%LKS
	RTI



SMEARP:	.WORD SMRBLK

; %%%% POWER FAIL HANDLER %%%%

POWROF:	MOV #RSTALL,%PWRV
	HALT

RSTALL:	MOV #POWROF,%PWRV
	JMP INIT

.PAGE
; %%%% INTERRUPT ROUTINE FOR RECEIVE INPUT FROM PDP-10 VIA DL-11 %%%%
;			DEVICE 0
VCRD0:	.WORD SLRD0		; VECTOR TO ONE OF THREE ROUTINES:
				;	(LINE SELECT, COUNT, CHARACTER OUT HANDLER)
CTRT0:	.WORD 0			; COUNT OF CHARACTERS REMAINING FOR THIS LINE
VCRT0:	.WORD 0			; VECTOR TO TTY STATUS TABLE

INRD0:	PUSH <R0,R1,R2>
	MOV RDBF0,R0		; PICK UP CHARACTER
	BPL 1$
	MOV R0,DLSTA1
	HALT			; BAD CHARACTER
1$:	JMP @VCRD0

SLRD0:	BIT #200,R0		; SELECT LINE FOR INPUT
	BNE 1$
	HALT			; NO LINE SELECT WHEN EXPECTED
1$:	BIC #200,R0		; CLEAR OUT LINE SELECT BIT
	CMP R0,#MAXTTY-1
	BLOS 2$
	HALT			; NON-EXISTENT TTY
2$:	ASL R0			; CONTRUCT INDEX TO PROPER INPUT QUEUE STATUS TABLE
	MOV RSTA(R0),VCRT0
	MOV #CTRD0,VCRD0
	POP <R2,R1,R0>
	RTI

CTRD0:	MOV R0,CTRT0
	BNE 1$
	HALT			; ZERO LENGTH STRING
1$:	MOV #PTRD0,VCRD0
	POP <R2,R1,R0>
	RTI

PTRD0:	MOV VCRT0,R1		; PLACE CHARACTER INTO INPUT QUEUE
	MOV RI.PTR(R1),R2
	MOVB R0,(R2)+		; THERE IT GOES ... (PLOP)
	CMP R2,RI.END(R1)
	BNE 1$
	MOV RI.BEG(R1),R2
1$:	CMP R2,RI.LIM(R1)
	BNE 2$
	HALT			; DATA OVERRUN, SCREWED ALLOCATION
2$:	MOV R2,RI.PTR(R1)
	DEC CTRT0
	BNE 3$
	MOV #SLRD0,VCRD0
3$:	CLRB @RI.FLG(R1)		; SIGNAL MAIN PROGRAM THAT A CHARACTER IS READY
	MOV #NOPIN,WAITPL
	POP <R2,R1,R0>
	RTI

.PAGE
; %%%% INTERRUPT ROUTINE FOR TRANSMIT OUTPUT TO PDP-10 VIA DL-11 %%%%

;NOTE: HAVE MTTY'S INDIRECT THROUGH TRANSMIT OUTPUT STATUS TABLE
; (IMPLIMENTS MANY TO ONE FUNCTION)

INTD0:	PUSH <R0,R1,R2>		; INTERRUPT TRANSMIT DEVICE 0
	MOV #TDST0,R1		; PICK UP POINTER TO STATUS TABLE FOR TRANSMIT DEVICE 0
	MOV OD.LIM(R1),R2	; PICK LOAD POINTER TO CHATACTER DATA
	MOVB (R2)+,R0		; PICK UP CHARACTER
	CMP R2,OD.END(R1)	; ARE WE AT END OF BUFFER
	BNE 1$
	MOV OD.BEG(R1),R2	; THEN CIRCLE AROUND TO THE BEGINNING
1$:	MASK 7			;	TO MAKE SURE NOTHING CAN CATCH US
				;	DISABLING INTERRUPTS WHILE STUFF PENDING
	CMP R2,OD.PTR(R1)	; HAVE WE CAUGHT UP WITH INSERTION POINTER?
	BNE 2$
	BIC #100,XDST0		; THEN TURN OFF INTERRUPT
2$:	UNMASK
	MOV R2,OD.LIM(R1)	; UPDATE POINTER
	MOV R0,XDBF0		; AND PUT OUT CHARACTER
	CLR OD.BLK(R1)
	POP <R2,R1,R0>
	RTI

.PAGE
; %%%% INTERRUPT ROUTINE FOR INPUT FROM TTY %%%%

INRTSB:	PUSH <R0,R1,R2,R5>	; INTERRUPT RECEIVE TTY 0
	MOV @RTBF(R3),R0	; PICK UP CHARACTER
	 BPL 1$
	MOV R0,DLSTA2		; SAVE BITS FOR A PORT MORTEM
	HALT			; SCREWED CHARACTER
1$:	MOV TSTA(R3),R1		; PICK UP POINTER TO TRANSMIT STATUS TABLE 0
	TST TI.BLK(R1)
	 BEQ 2$
	CLRB @CG.FLG(R1)
	MOV RSTA(R3),R5
	INC MR.BLK(R5)
	 BR 5$
2$:	MOV TI.PTR(R1),R2
	MOV R0,(R2)+
	CMP R2,TI.END(R1)
	 BNE 3$
	MOV TI.BEG(R1),R2
3$:	CMP R2,TI.LIM(R1)
	BNE 4$
	INC TI.BLK(R1)
4$:	MOV R2,TI.PTR(R1)
	CLRB @TI.FLG(R1)
5$:	MOV #NOPIN,WAITPL
	POP <R5,R2,R1,R0>
	RET

.PAGE
; %%%% INTERRUPT ROUTINE FOR OUTPUT TO TTY %%%%

INTTSB:	PUSH <R0,R1,R2>
	MOV RSTA(R3),R1
	MOV RO.LIM(R1),R2
	MASK 7
	TST RO.BLK(R1)
	BNE 1$
	CMP R2,RO.PTR(R1)
	BNE 1$
	BIC #100,@XTST(R3)
	UNMASK
	BR 3$
1$:	UNMASK
	MOVB (R2)+,R0
	CMP R2,RO.END(R1)
	 BNE 2$
	MOV RO.BEG(R1),R2
2$:	MOV R0,@XTBF(R3)
	MOV R2,RO.LIM(R1)
	CLR RO.BLK(R1)
3$:
	POP <R2,R1,R0>
	RET
.PAGE
; %%%% KEYBOARD MULTIPLEXER INTERRUPT ROUTINE %%%%

KEYINT:	PUSH <R0,R1,R2,R3,R5>
	MOV KEYBUF,R0
	MOV R0,R3
	BIC #7777,R0		; 12 BIT DATA
	BIC #170000,R3		; KEYBOARD ID
	SWAB R3			; FIND TERMINAL ID FROM KEYBOARD ID
	ASR R3
	ASR R3
	ASR R3
	MOV KEYTAB(R3),R3
	MOV TSTA(R3),R1
	TST TI.BLK(R1)		; IS THE <TI> QUEUE FULL?
	BEQ 4$
	CLRB @CG.FLG(R1)	; THEN SIGNAL FOR A ^G
	MOV RSTA(R3),R5
	INC MR.BLK(R5)		; BE ADAMANT ABOUT IT, BLOCK MP PROCESSING
				; GOING INTO THE <RO> QUEUE
	 BR 5$
4$:	MOV TI.PTR(R1),R2
	BIT #100000,R0		; SET BIT 15 TO INDICATE THAT BIT CHARACTER
				; WAS FROM KEYBOARD
	MOV R0,(R2)+
	CMP R2,TI.END(R1)
	BNE 1$
	MOV TI.BEG(R1),R2
1$:	CMP R2,TI.LIM(R1)
	BNE 2$
	INC TI.BLK(R1)
2$:	MOV R2,TI.PTR(R1)
	CLRB @TI.FLG(R1)
5$:	MOV #NOPIN,WAITPL
	POP <R5,R3,R2,R1,R0>
	RTI

; KEYBOARD VECTOR TABLE ( EACH ENTRY CONTAINS <TTY_CHANNEL_NUMBER>*2)

; KEYBOARD 0 -> DIGIVUE (TTY 3)
; KEYBOARD 1 -> TEKTRONIX ALTERNATE (TTY 1)
; KEYBOARD 2 -> ANN ARBOR #1 (TTY 4)
; KEYBOARD 3 -> ANN ARBOR #2 (TTY 5)

KEYTAB:	.WORD 6
	.WORD 2
	.WORD 10
	.WORD 12

	.BLKW 14	; LEAVE SPACE FOR TOTAL OF SIXTEEN (DECIMAL) ENTRIES
.PAGE
; %%%% GOULD INTERRUPT HANDLER %%%%

GLDINT:	PUSH <R0,R4,R5>
	MOV GTLIM,R4
GLDERR:	TST GLERR		; ARE WE ALREADY IN AN ERROR STATE?
	BNE 2$
	BIT #%GSERR,GLDCSR	; SHOULD WE GO TO AN ERROR STATE?
	BEQ 1$

	MOVB GLDCSR+1,STAERR		; YEP
	INC GLERR		; INFORM WORLD THAT GOULD IS IN TROUBLE
	INC PAGMNG		; COUNT OF PAGE MUNGING INCIDENTS
				; FOR END OF GOULD ERROR MONITOR
	CLRB STATBR		; TELL UNSPOOLR WHAT HAPPENED
	JMP GLIXIT

2$:	BIT #%GSERR,GLDCSR	; IS AN ERROR STILL PRESENT?
	BEQ 3$
	 JMP GLIXIT		; YEP

3$:	CLR GLERR		; NOPE, CLEAN UP
			; WE ARE ASSUMING THAT SELECTION IS PRESERVED WHEN SYSTEM
			; RESET IS ACHIEVED FOLLOWING MANUAL ERROR CORRECTION
			; (HOPEFULLY, THIS OCCURS WHEN THE PRINTER IS BROUGHT ON LINE)

1$:	JMP @GLIPTR

CMIDEC:	TST JMPFLG		; IF IN MIDDLE OF JUMP MACRO, SHOULD NOT
				; TEST FOR BUFFER LIMITS OR COMMAND COMPLETION
	 BNE 112$
	CMP R4,GLEND		; ARE WE EQUAL TO OR GREATER THAN THE END OF
				; THE FIRST BUFFER LIMIT?
	BLO 111$
	MOV GLBEG,R4		; THEN CIRCLE AROUND TO BEGINNING
111$:	TST REPFLG		; IF IN REPEAT, SHOULD NOT TEST COMMAND COMPLETION
	 BNE 1$
	MOV R4,GLLIM		; SUCCESSFUL COMPLETION OF A FULL COMMAND,
				; UPDATE POINTER THAT MAIN PROGRAM LOOKS AT

	CLR GLBLK		; IN CASE M.P. IS HUNG FOR LACK OF SPACE

1$:	CMP R4,GLPTR		; NOTHING LEFT TO DO?
	BNE 112$
	INC GLIDL		; COMPLAIN TO WORLD
	JMP GLIXIT

112$:	BIT #%GSPAP,GLDCSR	; IS GOULD RUNNING LOW ON PAPER?
	BEQ 11$
	MOVB GLDCSR+1,STAERR		; YEP
	CLRB STATBR		; TELL UNSPOOLER WHAT IS ABOUT TO HAPPEN

11$:	CLR GLIDL		; WE GOT SOMETHING TO DO
	MOV (R4)+,R0
	BMI 2$			; BRANCH IF INTERNAL MACRO COMMAND

14$:	CMP R0,#5		; IF LAST LINE FLAG, DON'T WANT TO WAIT FOR SBUSY
	BEQ 15$


	BIT #%GSBSY,GLDCSR
	BNE 12$			; BRANCH IF BUSY
15$:	SWAB R0
	TSTB R0			; TEST FOR DELAYED COMMAND
	BNE 4$

; IMMEDIATE GOULD COMMAND
	SWAB R0
	BIT #170,R0		; THE FOUR UNUSED BITS IN THE GOULD
				; COMMAND BYTE
	 BEQ 115$
	MOV #PAGLST,R5		; REQUEST FOR TAILSHEET PAGE MUNGING STATUS
	MOV PAGMNG,R0
	CALL CHRNUM
	CLR PAGMNG		; RESET FOR NEXT FILE
	 BR 116$
115$:	MOVB R0,GLDCSR
116$:	MOV #CMIDEC,GLIPTR
	 JMP CMIDEC

; DELAYED GOULD COMMAND
4$:	SWAB R0
	MOVB R0,GLDCSR
	MOV #CMIDEC,GLIPTR
	BR GLIXIT	

12$:	MOV R0,PNDR0
	MOV #13$,GLIPTR
	 BR GLIXIT
	
13$:	MOV PNDR0,R0
	BR 14$


2$:
; MOBY COMMAND
	BIT #17400,R0
	BNE 5$			; DMA COMMAND
	BIT #40000,R0		; REPEAT COMMAND
	BNE 3$
	BIT #20000,R0		; CURRENT PAGE COMMAND
	BNE 6$


; JMP COMING UP
	BIT #1,R0
	BEQ 21$

; POP
	MOV JMPRET,R4
	CLR JMPFLG
	 JMP CMIDEC

;PUSH
21$:	MOV (R4)+,R0		; PUT JUMP ADDRESS INTO R0
	MOV R4,JMPRET		; JMPRET IS ADDRESS AFTER JUMP COMMAND
	INC JMPFLG
	MOV R0,R4
	 JMP CMIDEC

3$:
; REPEAT COMING UP
	BIT #1,R0
	BEQ 31$

; POP
	DEC REPCNT
	 BNE 32$
	CLR REPFLG
	 JMP CMIDEC		; R4 IS LEFT POINT TO INSTRUCTION AFTER REPEAT LOOP

32$:
; ITERATE
	MOV REPRET,R4
	 JMP CMIDEC



;PUSH
31$:	MOV (R4)+,REPCNT	; REPEAT COUNT GOES INTO R0
	MOV R4,REPRET		; REPRET IS THE ADDRESS OF BEGINNING OF LOOP
	INC REPFLG
	 JMP CMIDEC

6$:
; CURRENT PAGE COMMAND COMING UP
	MOVB R0,STAPAG
	 JMP CMIDEC

5$:
; DMA COMMAND COMMING UP
	BIT #%GSDON,GLDCSR
	 BEQ 51$
	MOV R0,GLDWC		; COUNT
	MOV R4,GLDCA		; ADDRESS
	NEG R0
	ASL R0
	ADD R0,R4

53$:	BIT #%GSDON,GLDCSR
	 BEQ 52$
	MOV #CMIDEC,GLIPTR
	 JMP CMIDEC

52$:	MOV #53$,GLIPTR
	 BR GLIXIT

51$:	MOV #5$,GLIPTR
	 BR GLIXIT

GLIXIT:	MOV R4,GTLIM

	POP <R5,R4,R0>
	RTI

.PAGE
; %%%% ANN ARBOR DISPALY MULTIPLEXOR INTERRUPT HANDLER %%%%
; REMEMBER TO CLEAR INTERRUPT ENABLES IN INITIALIZATION
;SPECIAL QUEUE

;AADINT:	PUSH <R0,R1,R2>
;	MOV #AAMST,R1
;	MOV AA.LIM(R1),R2
;	MOV (R2)+,R0
;	CMP R2,AA.END(R1)
;	 BNE 1$
;	MOV AA.BEG(R1),R2
;1$:	MASK 7
;	CMP R2,AA.PTR(R1)
;	BNE 2$
;	BIC #100,AAMSTA
;2$:	UNMASK
;	MOV R0,AAMBUF
;	MOV R2,AA.LIM(R1)
;	CLR AA.BLK(R1)
;	POP <R2,R1,R0>
;	RTI


PLPINT:	RTI

NULL:	RTI


.PAGE
.SBTTL MAIN PROGRAM QUEUE PROCESSING ROUTINES
; %%%% MAIN PROGRAM ROUTINE FOR RECEIVED CHARACTER PROCESSING %%%%

MRTYSB:	MOV RSTA(R3),R1		; CREATE POINTER TO RECEIVE STATUS BLOCK
	TST RO.BLK(R1)
	 BNE 11$
	TST MR.BLK(R1)
	 BEQ 10$
11$:	ADD #4,(SP)
	RET
10$:	MOV RI.LIM(R1),R2
	MOVB (R2)+,R0		; PICK UP CHARACTER
	CMP R2,RI.END(R1)	; ARE WE AT THE END OF THE BUFFER?
	 BNE 2$
	MOV RI.BEG(R1),R2	; CIRCLE AROUND TO BEGINNING THEN
2$:	MOV RO.PTR(R1),R4	;			"
	MOVB R0,(R4)+		; PUT THE CHAR INTO THE RECEIVE OUTPUT BUFFER
	CMP R4,RO.END(R1)	; ARE WE AT THE END OF THE BUFFER?
	BNE 3$
	MOV RO.BEG(R1),R4	; CIRCLE AROUND TO BEGINNING THEN
3$:	MOV R4,RO.PTR(R1)	; UPDATE POINTER
	CMP R4,RO.LIM(R1)	; ANY ROOM IN THE RECEIVE OUTPUT BUFFER?
	 BNE 4$
	INC RO.BLK(R1)		; BLOCK QUEUE

4$:	BIS #PRIOR7,%PS				; MASK
	CMP R2,RI.PTR(R1)	; GOT ANY MORE CHARACTERS LEFT?
; IF NEED CHARACTERS TO COME OUT IN EXACT SEQUENTIAL ORDER,
; SET CG.BLK AND CLEAR WHEN FINISHED (NO ^G ON TI BUFFER FULL)


	 BNE 6$
	MOV SRTY(R3),@MRTY(R3)	; NOPE, PATCH UP BRANCH INSTRUCTION
6$:	BIC #PRIOR0,%PS				; UNMASK
	MOV R2,RI.LIM(R1)	; UPDATE POINTER
	DEC ALNUM(R3)		; UPDATE ALLOCATION
	BGT 7$
	HALT			; ALLOCATION SCREWED
7$:	CMP ALNUM(R3),#ALCLIM	; NEED TO ALLOCATE CHARACTERS?
	BGE 12$
	CALL ALLCSB		; CALL ALLOCATION SUBROUTINE
12$:	MOV #WAITIN,WAITPL	; PATCH WAIT INSTRUCTION
	MASK 7
	BIT #100,@XTST(R3)	; INTERRUPTS ENABLED?
	BEQ 14$			; NO
	UNMASK
	RET
14$:	UNMASK
	CALL INTTSB		; GET THE BALL ROLLING
	BIS #100,@XTST(R3)	; ACTIVATE INTERRUPT FOR OUTPUT TO DEVICE
	RET

.PAGE
; %%%% MAIN PROGRAM ROUTINE FOR TRANSMITED CHARACTER PROCESSING %%%%

MTTYSB:	MOV TSTA(R3),R1
	TST MT.BLK(R1)
	BNE 11$
	TST @TO.BLK(R1)		; IS OUTPUT BLOCKED
	 BEQ 10$
11$:	ADD #4,(SP)		; YEP, PRETEND NOTHING HAPPENED
	RET
10$:	MOV TI.LIM(R1),R2
110$:	TST TS.CNT(R1)
	BEQ 100$

; TEMPORARY STRING HANDLER
; NOTE, REMEMBER TO SET TS.PTR AND TS.CNT IN INTIALIZER
	MOV @TS.PTR(R1),R0
	DEC TS.CNT(R1)
	BNE 111$
	MOV TSTR(R3),TS.PTR(R1)
	CLR AL.BLK(R1)
	BR 12$

111$:	ADD #2,TS.PTR(R1)
	BR 12$

100$:	MOV (R2)+,R0
	CMP R2,TI.END(R1)
	 BNE 1$
	MOV TI.BEG(R1),R2
1$:	MOV @TO.PTR(R1),R4
	BIC #100000,R0		; CLEAR OUT BIT, WHICH WHEN SET, INDICATES SOURCE
				; OF CHARACTER, BIT =0 IMPLIES THE DEVICE, BIT =1
				; IMPLIES THE KEYBOARD MULTIPLEXOR
	CMP R0,#CBSL		; CNTL BACKSLASH?
	BNE 22$
; CONTROL BACKSLASH HANDLER (I.E. QUOTE IT WITH ANOTHER CNTL BACKSLASH)
	MOV TS.PTR(R1),R5
	MOV R0,(R5)+
	MOV R0,(R5)+
	MOV #2,TS.CNT(R1)
	MOV TSTR(R3),TS.PTR(R1)
	INC AL.BLK(R1)
	BR 110$

22$:	BIT #7600,R0		; ANY META, CNTL, TOP, ETC. STUFF?
	BEQ 12$

; %%%% INSERT 12 BIT CODE HANDLER HERE %%%%
	MOV R0,R5
	BIC #177600,R0
	ASL R5
	SWAB R5
	BIC #177740,R5
	BIS #100,R5
	PUSH R5			; CONSTRUCT TEMPORARY CHARACTER STRING FOR SPECIAL
				; CHARACTER ESCAPE SEQUENCE
	MOV TS.PTR(R1),R5
	MOV #CBSL,(R5)+
	MOV (SP)+,(R5)+
	MOV R0,(R5)+
; NOTE, SHOULD WE QUOTE A ^/ IF THAT IS THE THIRD CHARACTER IN THE ESCAPE?
; SEQUENCE ... I DON'T THINK SO
	MOV #3,TS.CNT(R1)
	MOV TSTR(R3),TS.PTR(R1)
	INC AL.BLK(R1)
	BR 110$

12$:	MOVB TTYNUM(R1),-(SP)	; CONSTRUCT CHARACTER MESSAGE (CHARACTER,,LINE SELECT)
	MOVB R0,1(SP)
	MOV (SP)+,(R4)+
	CMP R4,@TO.END(R1)
	 BNE 2$
	MOV @TO.BEG(R1),R4
2$:	CMP R4,@TO.LIM(R1)
	 BNE 3$
	INC @TO.BLK(R1)
3$:	MOV R4,@TO.PTR(R1)
	TST TS.CNT(R1)
	 BNE 51$
	BIS #PRIOR7,%PS		;MASK
	CMP R2,TI.PTR(R1)
	 BNE 4$
	MOV STTY(R3),@MTTY(R3)
4$:	BIC #PRIOR7,%PS		;UNMASK
51$:	MOV R2,TI.LIM(R1)
	CLR TI.BLK(R1)
5$:	MOV #WAITIN,WAITPL
	BIS #100,XDST0
	RET

.PAGE
; %%%% GOULD MAIN PROGRAM ROUTINE %%%%

MRGLSB:	MOV RSTA(R3),R1
;	TST MR.BLK(R1)		; NOTHING SHOULD SET THIS
;	 BNE 11$
;	TST RO.BLK(R1)		; UNNECESSARY UNTIL WE GET A CONSOLE DEVICE
;	 BNE 11$
	TST GLBLK		; OUTPUT QUEUE FILLED
	 BNE 11$
	TST GLERR		; IN THE MIDST OF SOME ERROR
	 BEQ 10$
11$:	ADD #4,(SP)
	RET

10$:	MOV RI.LIM(R1),R2
	MOV GTPTR,R4		; TEMPORARY POINTER (NECESSARY SINCE ITEMS
				; IN QUEUE HAVE "WIDTH")

JMPDEC:	JMP @GLDPND		; DISPATCH TO ANY PENDING OPERATIONS DUE TO GL QUEUE
				; BLOCKAGE (DEFAULT IS CHRDEC)

CHRDEC:	DEC ALNUM(R3)
	BGT 4$
	HALT
4$:	MOVB (R2)+,R0		; PICK UP CHARACTER
	BPL DATHAC		; SKIP AROUND IF CHARACTER IS NOT AN EIGHT BIT CODE
	TST QOTFLG		; IS THIS CHARACTER TO BE QUOTED?
	 BEQ 2$
	CLR QOTFLG		; YEP, PASS IT ON
	BR DATACH
2$:	CMPB R0,#%CCACK		; ARE WE BEING PAGED?
	 BNE HERE
	MOVB GLDCSR+1,STAERR
	CLRB STATBR		; RESPOND WITH STATUS (ACTIVATE DAEMON)
	 JMP GLOOP

HERE:	CMPB R0,#%CCSOD		; START OF DATA?
	BNE 4$
	CLR EODFLG		; YEP, FLAG START OF DATA
	 JMP GLOOP
4$:	TST EODFLG		; ARE WE RECEIVING RANDOM CHARACTERS?
	 BEQ 51$
	 JMP GLOOP		; FORGET THEM
51$:	CMPB R0,#%CCQOT		; SHOULD WE QUOTE THE NEXT CHARACTER?
	 BNE 5$
	INC QOTFLG		; YEP
	 JMP GLOOP
5$:	CMPB R0,#%CCEOD		; END OF DATA?
	 BNE DATACH
	INC EODFLG		; YEP, FLAG END OF DATA
	BIS #100,%LKS 		; START UP CLOCK (COUNT DOWN FOR SMEAR PAGE)
	 JMP GLOOP

DATHAC:	TST EODFLG		; NON EIGHT BIT CODE, IS IT RANDOM DATA?
	BEQ DATACH
	JMP GLOOP

DATACH:	JMP @WRDPTR		; MUST BE DATA THEN

MAKWD1:	MOVB R0,TMPWRD		;FIRST PIECE OF WORD
	MOV #MAKWD2,WRDPTR
	 JMP GLOOP

MAKWD2:	MOVB R0,TMPWRD+1	;SECOND PIECE OF WORD
	MOV #MAKWD1,WRDPTR

	JMP @GLDPTR		; DISPATCH TO PROPER COMMAND HANDLER

DATDEC:	TST TMPWRD		; COMMAND OR LINE BUFFER?
	 BMI COMDEC
	 JMP DMADEC		; BIT 15 NOT SET, LINE BUFFER


.PAGE
; %%%% COMMAND DECODING %%%%


COMDEC:	BIC #100000,TMPWRD	; REMOVE COMMAND BIT
	MOV R4,R5
	ADD #4,R5		; ADD 4, R5 POINTS TO LAST LOCATION IN POTENTIAL COMMAND

	BIS #PRIOR7,%PS		;MASK
	CMP GTPTR,GLLIM		; ARE WE AHEAD OF PICK UP POINTER ANYWAY?  (THEN OK)
	BHIS 2$
	CMP R5,GLLIM		; IF WE GO THROUGH WITH THIS COMMAND, WILL WE
				; LAP OTHER POINTER?  (THEN NOT OK)
	BLO 2$
	INC GLBLK		; GL QUEUE IS BLOCKED, WAIT FOR QUEUE TO EMPTY A LITTLE
	BIC #PRIOR0,%PS
	MOV #COMDEC,GLDPND	; AND MAKE SURE WE WIND UP IN THE RIGHT PLACE ON RETURN
	 JMP GLDXIT
2$:	BIC #PRIOR0,%PS		; NO PROBLEM
	MOV #CHRDEC,GLDPND

	BIT #40000,TMPWRD	; MACRO BIT TEST
	 BEQ DLYTST		; NOPE, IS STANDARD OR PSEUDO COMMAND

; GOULD MACRO COMMANDS
	MOVB TMPWRD,UPWORD	; UP COMING PAGE NUMBER
	MOVB TMPWRD+1,R0
	BIC #177700,R0	
	ASR R0
	ASR R0
	ASR R0
	MOV UPWORD,(R4)+
	MOV #100000,(R4)+
	MOV MACTAB(R0),(R4)+
	ASR R0
	MOV R0,GRFFLG
	CMP R0,#3
	BNE 4$
	CLR GRFFLG
4$:	 JMP GLDFIN		; COMPLETION OF COMMAND
	
MACTAB:	.WORD SALBLK
	.WORD SLGBLK
	.WORD SHGBLK
	.WORD EOFBLK

UPWORD:	.WORD 120000


; NORMAL GOULD COMMANDS

;DETERMINE IF THIS IS A DELAYED COMMAND
DLYTST:	BIT #200,TMPWRD		; LINE ADVANCE OR HOME? (OR PSEUDO COMMAND)
	 BNE DLAYCM
	CMPB #%GCON,TMPWRD	; ENABLE?
	 BEQ DLAYCM
	TSTB TMPWRD		; FEED?
	BEQ DLAYCM

;IF WE GOT TO HERE, MUST BE AN IMMEDIATE COMMAND
	CMPB #%GCGRF,TMPWRD	; GRAPHIC SELECT?
	 BNE 1$
	INC GRFFLG
1$:	CMPB #%GCOFF,TMPWRD	; DISABLE?
	 BNE 2$
	CLR GRFFLG		; CLEAR MODE SELECTION
2$:	CLRB TMPWRD+1		; IMMEDIATE COMMAND SIGNIFIED BY 0 IN BYTE 1
	MOV TMPWRD,(R4)+
	 JMP GLDFIN		; COMPLETION OF A COMMAND

DLAYCM:	BIT #100,TMPWRD
	BEQ HERE4

; REQUEST FOR REPEAT, IN ACTUALITY
	BIT #2,TMPWRD
	BNE 1$

; START OF REPEAT
	MOV #140000,(R4)+
	MOV #REPTRN,GLDPTR	; WE NEED ANOTHER WORD HERE (THE REPEAT COUNT)
	 JMP GLDXIT

; END OF REPEAT
1$:	MOV #140001,(R4)+
	 JMP GLDFIN		; COMPLETION OF A COMMAND

REPTRN:	MOV TMPWRD,(R4)+
	MOV #DATDEC,GLDPTR
	 JMP GLDFIN		; COMPLETION OF A COMAND


HERE4:	MOVB #1,TMPWRD+1	; DELAYED COMMAND SIGNIFIED BY 1 IN BYTE 1
	MOV TMPWRD,(R4)+
	JMP GLDFIN		; COMPLETION OF A COMMAND


.PAGE
; %%%% DMA BUFFER DECODING %%%%


DMADEC:	TST GRFFLG
	BEQ ALPHAM		; MUST BE ALPHA MODE

; %%%% GRAPHICS MODE %%%%

GRAPHM:	BIT #200,TMPWRD		; RUN LENGTH ENCODED?
	 BEQ IMAGE
	 JMP RUNLEN		; YEP

; %%%% IMAGE TYPE GRAPHICS %%%%

IMAGE:	MOVB TMPWRD,DATLEN	; LENGTH OF DATA
	MOVB TMPWRD+1,R5
	MOV R5,MARLEN		; LENGTH OF MARGIN
	ADD DATLEN,R5		; TOTAL SIZE OF BUFFER (IN WORDS)
	MOV R5,MARLN1		; SAVE FOR DMA COUNT
	ASL R5			; NOW IN BYTES
	ADD R4,R5
				; LOCATION OF PROPOSED BUFFER

	BIS #PRIOR7,%PS		; MASK
	CMP R4,GLLIM		; ARE WE AHEAD OF PICK UP POINTER ANYWAY? (THEN OK)
	BHIS 4$
	CMP R5,GLLIM		; IF WE GO THROUGH WITH THIS BUFFER, WILL WE
				; LAP THE OTHER POINTER? (THEN NOT OK)
	BLO 4$
	INC GLBLK		; BLOCKED OUTPUT, WAIT FOR QUEUE TO EMPTY A LITTLE
	BIC #PRIOR0,%PS		; UNMASK
	MOV #IMAGE,GLDPND	; MAKE SURE WE COME BACK TO THE RIGHT PLACE
	 JMP GLDXIT		; NEED MORE SPACE

4$:	BIC #PRIOR0,%PS		; NO PROBLEM
	MOV #CHRDEC,GLDPND	; WE HAVE ENOUGH SPACE NOW

	NEG MARLN1		; NEGATION OF TOTAL SIZE OF BUFFER
	MOV MARLN1,(R4)+	; WORD COUNT HEADER FOR DMA COMMAND
	TST MARLEN		; ZERO MARGIN?
	BEQ 2$
1$:	CLR (R4)+
3$:	DEC MARLEN
	BNE 1$
2$:	MOV #IMTRAN,GLDPTR
	 JMP GLDXIT		; NEED MORE WORDS (REST OF LINE BUFFER)


IMTRAN:	MOV TMPWRD,(R4)+
	DEC DATLEN
	 BEQ 2$
	 JMP GLDXIT		; IF MORE IMAGE DATA COMING (NEED MORE WORDS)
2$:	MOV #DATDEC,GLDPTR	; DON'T NEED ANY MORE WORDS
	 JMP GLDFIN		; COMPLETION OF COMMAND

; %%%% ALPHA %%%%

ALPHAM:	MOVB TMPWRD,R5
	MOV R5,DATLEN
	MOV R5,DATLN1
	ASL R5
	ADD R4,R5


	BIS #PRIOR7,%PS		;MASK
	CMP R4,GLLIM		; ARE WE AHEAD OF PICK UP POINTER ANYWAY? (OK)
	BHIS 2$
	CMP R5,GLLIM		; IF WE GO THROUGH WITH THIS BUFFER, WILL WE
				; LAP OTHER POINTER? (NOT OK)
	BLO 2$
	INC GLBLK		; BLOCKED OUTPUT, WAIT FOR QUEUE TO EMPTY A LITTLE
	BIC #PRIOR0,%PS		;UNMASK
	MOV #ALPHAM,GLDPND	; MAKE SURE WE COME BACK HERE (NEED MORE SPACE)
	 JMP GLDXIT
2$:	BIC #PRIOR0,%PS		;UNMASK, NO PROBLEM
	MOV #CHRDEC,GLDPND	; WE'VE GOT THE SPACE NOW

	NEG DATLN1
	MOV DATLN1,(R4)+
	MOV #ALPTRN,GLDPTR	; GOBBLE WORDS FOR BUFFER
	 JMP GLDXIT

ALPTRN:	MOV TMPWRD,(R4)+
	DEC DATLEN
	 BEQ 2$
	 JMP GLDXIT		; WE NEED MORE WORDS
2$:	MOV #DATDEC,GLDPTR
	 JMP GLDFIN		; COMPLETION OF COMMAND


; %%%% RUN LENGTH ENCODED TYPE GRAPHICS %%%%

RUNLEN: MOVB TMPWRD,ENCLEN
	BIC #STRIP,ENCLEN	; WORD COUNT OF RUN LENGTH ENCODED DATA
	MOV #RUNLN2,GLDPTR	; WE NEED ANOTHER WORD OF COMMAND
	 JMP GLDXIT

RUNLN2:	CLR COLOR
	MOVB TMPWRD,MARLEN
	 BPL 1$
	INC COLOR
	BIC #STRIP,MARLEN	; LENGTH OR MARGIN (IN WORDS)
1$:	MOVB TMPWRD+1,R5
	BIC #STRIP,R5		; LENGTH OF DECODED BUFFER, LESS MARGIN
	ADD MARLEN,R5		; TOTAL LENGTH OF BUFFER (IN WORDS)
	MOV R5,DATLEN
	ASL R5			; NOW IN BYTES
	ADD R4,R5

	BIS #PRIOR7,%PS		;MASK
	CMP R4,GLLIM		; ARE WE AHEAD OF PICK UP POINTER ANYWAY? (OK)
	BHIS 2$
	CMP R5,GLLIM		; IF WE GO THROUGH WITH THIS BUFFER, WILL WE
				; LAP OTHER POINTER (NOT OK)
	BLO 2$
	INC GLBLK		; BLOCKED OUTPUT, WAIT FOR QUEUE TO EMPTY A LITTLE
	BIC #PRIOR0,%PS		;UNMASK
	MOV #RUNLN2,GLDPND
	 JMP GLDXIT
2$:	BIC #PRIOR0,%PS		;UNMASK, NO PROBLEM
	MOV #CHRDEC,GLDPND	; WE'VE GOT ENOUGH SPACE NOW

	MOV #RUNTRN,GLDPTR
	NEG DATLEN
	MOV DATLEN,(R4)+	; WORD COUNT, DMA COMMAND HEADER
	CLR DATLEN
	TST MARLEN
	BEQ 3$			; ZERO LENGTH MARGIN?
	TST COLOR
	BEQ 21$			; IF COLOR = 0, THEN WHITE MARGIN
22$:	MOV #177777,(R4)+
	DEC MARLEN
	BNE 22$
	BR 3$

21$:	CLR (R4)+
	DEC MARLEN
	BNE 21$

3$:	 JMP GLDXIT		; NEED MORE WORDS

RUNTRN:	MOVB TMPWRD,R5
	BPL 1$
	BIC #STRIP,R5
	 BEQ 4$
2$:	MOVB #177777,(R4)+
	DEC R5
	 BNE 2$
	 BR 4$

1$:	 BEQ 4$
3$:	CLRB (R4)+
	DEC R5
	 BNE 3$

4$:	MOVB TMPWRD+1,(R4)+
	DEC ENCLEN
	 BEQ 41$
	 JMP GLDXIT		; STILL NEED MORE WORDS

41$:	MOV #DATDEC,GLDPTR
	 JMP GLDFIN		; COMPLETED COMMAND


.PAGE
GLDFIN:	CMP R4,GLEND
	BLO 1$
	MOV GLBEG,R4
1$:	CMP R4,GLLIM
	BNE 2$
	INC GLBLK
2$:	MOV R4,GLPTR
	MOV R4,GTPTR
	TST GLIDL		; IS THE GOULD IDLE?
	BEQ GLOOP
	MASK 5			; FAKE AN INTERRUPT
	CALL GLDINT		; GO TO HANDLER WITH ANXIOUSLY AWAITED CRUFT
	BR GLOOP

GLDXIT:	MOV R4,GTPTR

GLOOP:	CMP R2,RI.END(R1)	; END OF INPUT QUEUE?
	 BNE 1$
	MOV RI.BEG(R1),R2	; CIRCLE AROUND TO BEGINNING
1$:	MOV R2,RI.LIM(R1)
	CMP ALNUM(R3),#ALCLIM
	BGE 5$
	CALL ALLCSB
	INC GLDALC		; NECESSARY, ELSE GOULD LOCKS OUT ITS OWN ALLOCATER
5$:	BIS #PRIOR7,%PS
	CMP R2,RI.PTR(R1)
	 BEQ 3$
	BIC #PRIOR0,%PS
;	TST RO.BLK(R1)
;	 BNE 6$			; UNNECESSARY UNTIL CONSOLE DEVICE EXISTS
	TST GLBLK
	 BNE 6$
	TST GLDALC
	 BNE 7$
	 JMP JMPDEC

7$:	CLR GLDALC
	 BR 8$

3$:	MOV SRTY(R3),@MRTY(R3)
	BIC #PRIOR0,%PS

6$:	MOV #WAITIN,WAITPL
8$:	RET


.PAGE
; %%%% PREDEFINED  GOULD MACRO BLOCKS %%%%

			; ALPHA MODE SELECT
SALBLK:	.WORD 4			; DISABLE
	.WORD 403		; ENABLE
	.WORD 2			; CUT
	.WORD 100001		; POPJ
SALEND:

			; LOW SPEED GRAPHICS MODE SELECT
SLGBLK:	.WORD 4			; DISABLE
	.WORD 1			; GRAPHIC COMMAND
	.WORD 5			; LAST LINE FLAG
	.WORD 403		; ENABLE
	.WORD 2			; CUT
	.WORD 100001		; POPJ
SLGEND:

			; HIGH SPEED GRAPHICS MODE SELECT
SHGBLK:	.WORD 4			; DISABLE
	.WORD 1			; GRAPHIC COMMAND
	.WORD 403		; ENABLE
	.WORD 2			; CUT
	.WORD 100001		; POPJ
SHGEND:


			; EOF OF FILE
EOFBLK:	.WORD 4			; DISABLE
	.WORD 403		; ENABLE
	.WORD 2			; CUT
	.WORD 140000		; REPEAT 12 (OCTAL) TIMES
	.WORD 12
	.WORD -102			; DMA COUNT
	.REPT 102
	.NLIST
	.WORD 36475		; DOUBLE DASH
	.LIST
.ENDR
	.WORD 140001		; END OF REPEAT
	.WORD 100		; END OF FILE INDICATOR
	.WORD -22			; DMA COUNT
	.ASCII /          /
	.BLKW 3
PAGLST:	.ASCII /  O(TCLA )APEG SAB D/	;  (OCTAL) PAGES BAD
	.WORD 140000		; REPEAT 12 (OCTAL) TIMES
	.WORD 12
	.WORD -102			; DMA COUNT
	.REPT 102		; DOUBLE DASH
	.NLIST
	.WORD 36475
	.LIST
.ENDR
	.WORD 140001		; END OF REPEAT

	.WORD 100001		; JMP TO WHERE WE WERE BEFORE
EOFEND:


			; SMEAR PROTECTION PAGE
SMRBLK:	.WORD 4			; DISABLE
	.WORD 403		; ENABLE
	.WORD 2			; CUT
	.WORD 140000		; START REPEAT
	.WORD 25		;	25 (OCTAL) TIMES
	.WORD -1		; DMA COUNT
	.WORD 20040		; DOUBLE SPACE
	.WORD 140001		; END REPEAT
	.WORD 100001		; END JUMP
SMREND:

		;NUMBER TO STRING CONVERSION ROUTINE
CHRNUM:	PUSH <R1,R4>
	MOV #5,R4
1$:	MOV R0,R1
	BIC #177770,R1
	ADD #60,R1
	MOVB R1,-(R5)
	DEC R4
	BEQ 2$
	ASR R0
	ASR R0
	ASR R0
	BR 1$
2$:	TST R0
	BMI 3$
	MOVB #60,-(R5)
	 BR 4$
3$:	MOVB #61,-(R5)
4$:	SWAB (R5)+		; GOULD LIKES 'EM BACKWARDS
	SWAB (R5)+
	SWAB (R5)+
	POP <R4,R1>
	RET


.PAGE
; %%%% MAIN PROGRAM ROUTINE FOR ALLOCATION MESSAGE HANDLING %%%%

; AL.BLK SET FOR 12 BIT CODE EXPANSION AND ^\ DOUBLING


MRALSB:	MOV TSTA(R3),R1		; CREATE POINTER TO TRANSMIT STATUS BLOCK
	TST @TO.BLK(R1)
	 BNE 11$
	TST AL.BLK(R1)		; ARE WE OUT OF ORDER?
	 BEQ 10$
11$:	ADD #4,(SP)		; THEN PRETEND NOTHING HAPPENED
	RET
10$:	MOV @ALCP(R3),R0	; POINTER ALLOCATION MESSAGE
	MOV @MCNT(R3),R5	; COUNT OF WORDS TO TRANSFER
	MOV @TO.PTR(R1),R2	; LOAD POINTER TO QUEUE
4$:	MOV (R0)+,(R2)+		; OUTPUT CHARACTER MESSAGE
	CMP R2,@TO.END(R1)	; ARE WE AT END OF QUEUE?
	 BNE 1$
	MOV @TO.BEG(R1),R2	; CIRCLE AROUND TO BEGINNING THEN
1$:	CMP R2,@TO.LIM(R1)	; POINTER OVERLAP?
	 BNE 2$
	INC @TO.BLK(R1)
	DEC R5			; HAVE WE FINISHED YET
	BEQ 3$	
	MOV R5,@MCNT(R3)		; NOPE, SAVE COUNT
	MOV R0,@ALCP(R3)	; AND ALLOCATION MESSAGE POINTER
	MOV R2,@TO.PTR(R1)	; RESTORE POINTER
	INC MT.BLK(R1)
	MOV #WAITIN,WAITPL	; PATCH WAIT SINCE WE MADE SOME HEADWAY
	RET
2$:	DEC R5
	BNE 4$
3$:	MOV SRAL(R3),@MRAL(R3)	; PATCH FLAG
	MOV #3,@MCNT(R3)	; RE-INITIALIZE COUNT
	MOV #WAITIN,WAITPL	; PATCH WAIT
	CLR MT.BLK(R1)		; UNBLOCK NORMAL TTY OUTPUT
	MOV R2,@TO.PTR(R1)	; RESTORE POINTER	
	BIS #100,XDST0		; ACTIVATE INTERRUPT
	RET


.PAGE
; %%%% MAIN PROGRAM ROUTINE FOR CONTROL-G MESSAGE HANDLING %%%%
; NOTE: IF IN THE FUTURE MORE THAN ONE CHARACTER MUST BE OUTPUT
;(I.E. MORE THAN JUST ^G) REMEMBER TO INCREMENT MR.BLK(R1)
; WHEN CAN'T FINSIH MESSAGE DUE TO FULL RO QUEUE


MTCGSB:	MOV RSTA(R3),R1
	TST CG.BLK(R1)
	BNE 11$
	TST RO.BLK(R1)
	 BEQ 10$
11$:	ADD #4,(SP)		; RETURN TO .+4
	RET
10$:	MOV #CG,R0
	MOV RO.PTR(R1),R2
	MOVB R0,(R2)+
	CMP R2,RO.END(R1)
	 BNE 1$
	MOV RO.BEG(R1),R2
1$:	CMP R2,RO.LIM(R1)
	 BNE 2$
	INC RO.BLK(R1)
2$:	MOV R2,RO.PTR(R1)
	BIS #100,@XTST(R3)
	MOV STCG(R3),@MTCG(R3)
	MOV #WAITIN,WAITPL
	CLR MR.BLK(R1)
	RET

.PAGE
; %%%% MAIN PROGRAM ROUTINE FOR HANDLING ANN ARBOR TERMINAL DISPLAY %%%%

MRAASB:	MOV RSTA(R3),R1
	TST RO.BLK(R1)
	 BNE 11$
	TST MR.BLK(R1)
	 BEQ 10$
11$:	ADD #4,(SP)
	RET
10$:	MOV RI.LIM(R1),R2
	MOVB (R2)+,R0
	BIC #LHS,R0
	MOV R3,R5		;CALCULATE ANN ARBOR INDEX
	ASR R5
	SUB #AATYST,R5
	SWAB R5
	BIS R5,R0		; INDEX LOCATED IN HIGH BYTE
	CMP R2,RI.END(R1)
	 BNE 1$
	MOV RI.BEG(R1),R2
1$:	MOV @RO.PTR(R1),R4
	MOV R0,(R4)+
	CMP R4,@RO.END(R1)
	 BNE 2$
	MOV @RO.BEG(R1),R4
2$:	CMP R4,@RO.LIM(R1)
	 BNE 6$
	INC @RO.BLK(R1)
6$:	MOV R4,@RO.PTR(R1)
	BIS #PRIOR7,%PS
	CMP R2,RI.PTR(R1)
	 BNE 3$
	MOV SRTY(R3),@MRTY(R3)
3$:	BIC #PRIOR0,%PS
	MOV R2,RI.LIM(R1)
	DEC ALNUM(R3)
	 BGT 4$
	HALT
4$:	CMP ALNUM(R3),#ALCLIM
	BGE 5$
	CALL ALLCSB
5$:	MOV #WAITIN,WAITPL
;	BIS #100,AAMSTA
	RET




MRDGSB:	RET

MRIMSB:	RET

MTIMSB:	RET

NULLSB:	RET



.PAGE
; %%%% ROUTINE FOR INTIALIZING TTY CHANNEL
INTYSB:	MOV RSTA(R3),R1
	MOV RI.BEG(R1),RI.PTR(R1)
	MOV RI.BEG(R1),RI.LIM(R1)
	MOV RO.BEG(R1),RO.PTR(R1)
	MOV RO.BEG(R1),RO.LIM(R1)
	CLR RI.BLK(R1)
	CLR RO.BLK(R1)
	CLR MR.BLK(R1)
	CLR CG.BLK(R1)
	MOV SRTY(R3),@RI.FLG(R1)
;	MOV SRAL(R3),@AL.FLG(R1)	; GOING TO BE FLAGGED ANYWAY
	CLR ALNUM(R3)
	MOV #5,@MCNT(R3)		; MOVE WORD COUNT OF MESSAGE INTO PLACE
	CLR RS.CNT(R1)
	MOV RSTR(R3),RS.PTR(R1)

	MOV TSTA(R3),R1
	MOV TI.BEG(R1),TI.PTR(R1)
	MOV TI.BEG(R1),TI.LIM(R1)
; TO.PTR IS AN INDIRECT POINTER
; TO.LIM IS AN INDIRECT POINTER
	CLR TI.BLK(R1)
; TO.BLK IS AN INDIRECT POINTER
	CLR MT.BLK(R1)
	CLR AL.BLK(R1)
	MOV STTY(R3),@TI.FLG(R1)
	MOV STCG(R3),@CG.FLG(R1)
	CALL ALLCSB
	CLR TS.CNT(R1)
	MOV TSTR(R3),TS.PTR(R1)
	MOV ALZM(R3),@ALCP(R3)		; MOVE ALLOCATION POINTER INTO PLACE
	JSR PC,@INSPTB(R3)		; CALL TERMINAL DEPENDANT ROUTINES
	RET

INSPTB:	.WORD NULLSB
	.WORD NULLSB
	.WORD INGLSB
	.WORD NULLSB
	.WORD NULLSB
	.WORD NULLSB

ALLCSB:	PUSH <R5,R1>
	MOV RSTA(R3),R1
	MOVB #ALCINC,@ALCI(R3)		;SET ALLOCATION
	ADD #ALCINC,ALNUM(R3)
	MOV ALCM(R3),@ALCP(R3)		;SET POINTER TO ALLOCATION
	MOV TSTA(R3),R5			;GET POINTER TO TRANSMIT STATUS TABLE
	INC MT.BLK(R5)			;BLOCK MAIN PROGRAM TRANSMIT CHAR PROCESSING
	CLRB @AL.FLG(R1)		;AND SET FLAG
	POP <R1,R5>
	RET

INGLSB:
	MOV GLBEG,GLPTR		; INITALIZE GOULD DATA QUEUE POINTERS
	MOV GLBEG,GTPTR
	MOV GLBEG,GLLIM
	MOV GLBEG,GTLIM
	MOV SSTABR,STATBR	; FIX BRANCH FOR STATUS ROUTINE
	MOV SGLIBR,GLIBR	; FIX BRANCH FOR M.P. FAKERY OF GOULD INTERRUPT
	MOV #STLEN,STALEN
	MOV #STMSG,STAMSG
	.IRP VAL,<GLBLK,JMPFLG,REPFLG,GLERR,PAGMNG,QOTFLG,GRFFLG,CLKCNT,GLDALC>
	CLR VAL
.ENDM
	MOV #1,GLIDL
	MOV #CMIDEC,GLIPTR
	MOV #CHRDEC,GLDPND
	MOV #MAKWD1,WRDPTR
	MOV #DATDEC,GLDPTR
	MOVB #177,STAPAG
	MOV #1,EODFLG
	MOV #%GCOFF,@#GLDCSR	; DISABLE THE PRINTER TO CLEAR ANY OLD INTERRUPTS
	MOV #%GCION,@#GLDCSR	; ENABLE GOULD INTERRUPTS
	RET	



.PAGE
.SBTTL EXPANSION OF TABLES AND BUFFERS

; %%%% ADDRESS AND VALUE TABLES FOR MAIN PROGRAM SUBROUTINE CALLS %%%%

.IRP NAM,<MCNT,ALCM,ALCP,RSTA,TSTA,RIBF,ROBF,TIBF,RSTR,TSTR>
VALCRE NAM,MAXTTY
.ENDM

.IRP NAM,<MCNT,ALCM,ALCP,RSTA,TSTA,RSTR,TSTR> ;MACRO TABLES
	ADRCRE NAM,MAXTTY
.ENDM
.IRP NAM,<MRTY,MRAL,MTTY,MTCG,ALCI,ALZM>  ;PREDEFINED TABLES
	ADRCRE NAM,MAXTTY
.ENDM

.IRP NAM,<RTST,RTBF>
	ADRCRE NAM,MXRTTY
.ENDM

.IRP NAM,<XTST,XTBF>
	ADRCRE NAM,MXXTTY
.ENDM

ALNUM:	.BLKW MXTTTY		; TABLE OF CURRENT ALLOCATIONS


; %%%% TRANSMIT OUTPUT DEVICE STATUS TABLE (MANY TO ONE NECESSITATES INDIRECTION
; %%%%	TO THIS TABLE)

	TOBFMC <0>

TDST0:	.WORD TOBF0
	.WORD TOBF0+TOBFLN
	.WORD TOBF0
	.WORD TOBF0
	.WORD 0


; %%%% ANN ARBOR RECEIVE OUTPUT STATUS TABLE (MANY TO ONE NECESSITATES INDIRECTION
; %%%% THROUGH THIS TABLE)

AABF:	.BLKW AABFLN/2

AAMST:	.WORD AABF
	.WORD AABF+AABFLN
	.WORD AABF
	.WORD AABF
	.WORD 0

.PAGE
.SBTTL %%%% GOULD VARIABLES AND BUFFERS AND TABLES %%%%

MARLEN:	.WORD 0
DATLEN:	.WORD 0
DATLN1:	.WORD 0
ENCLEN:	.WORD 0
MARLN1:	.WORD 0
TMPWRD:	.WORD 0
VALWRD:	.WORD 0
GLDPND:	.WORD CHRDEC
WRDPTR:	.WORD MAKWD1
GLDPTR:	.WORD DATDEC
EODFLG:	.WORD 0
QOTFLG:	.WORD 0
GRFFLG:	.WORD 0
COLOR:	.WORD 0
DLSTA1:	.WORD 0
DLSTA2:	.WORD 0


CLKCNT:	.WORD 0


GLPTR:	.WORD GLDBUF
GTPTR:	.WORD GLDBUF
GLEND:	.WORD <CORLIM-<LBUFL+22>>
GLBEG:	.WORD GLDBUF
GLLIM:	.WORD GLDBUF
GTLIM:	.WORD GLDBUF
GLBLK:	.WORD 0

GLIPTR:	.WORD CMIDEC
JMPFLG:	.WORD 0
REPFLG:	.WORD 0

PNDR0:	.WORD 0
JMPRET:	.WORD 0
REPRET:	.WORD 0
REPCNT:	.WORD 0

GLIDL:	.WORD 0
GLERR:	.WORD 0
PAGMNG:	.WORD 0
SMRFLG:	.WORD 0

STMSG:	.WORD 177
STAPAG:	.WORD 177
STAERR:	.WORD 0
	.WORD 0
	.WORD 0
STLEN==<.-STMSG>/2

STAMSG:	.WORD STMSG
STALEN:	.WORD STLEN
GLDALC:	.WORD 0

; %%%% START OF GOULD BUFFER %%%%

GLDBUF:
.END
